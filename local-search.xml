<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——协程拓展实践</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将介绍两种序列生成器，序列生成器包含“序列”和“生成器”两部分，我们先来仿写一个Python的Generator。</p><h2 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h2><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> nums<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-></span> Generator<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> generator <span class="token punctuation">&#123;</span> start<span class="token operator">:</span> Int <span class="token operator">-></span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">yield</span><span class="token punctuation">(</span>start <span class="token operator">+</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">val</span> gen<span class="token operator">:</span> Generator<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">nums</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token keyword">in</span> gen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 运行结果 </span><span class="token number">10</span><span class="token number">11</span><span class="token number">12</span><span class="token number">13</span><span class="token number">14</span><span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> GeneratorImpl<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> block<span class="token operator">:</span> <span class="token keyword">suspend</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> parameter<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">:</span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">GeneratorIterator</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 构建一个序列生成器 */</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">generator</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token keyword">suspend</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> parameter<span class="token operator">:</span> T <span class="token operator">-></span>        <span class="token function">GeneratorImpl</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> State <span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token function">NotReady</span><span class="token punctuation">(</span><span class="token keyword">val</span> continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> Ready<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">,</span> <span class="token keyword">val</span> nextValue<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">object</span> Done <span class="token operator">:</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png?lastModify=1612513743" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 获取下一个元素 * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程 * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态 */</span><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">val</span> currentState <span class="token operator">=</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>NotReady <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>Ready<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            state <span class="token operator">=</span> State<span class="token punctuation">.</span><span class="token function">NotReady</span><span class="token punctuation">(</span>currentState<span class="token punctuation">.</span>continuation<span class="token punctuation">)</span>            <span class="token punctuation">(</span>currentState <span class="token keyword">as</span> State<span class="token punctuation">.</span>Ready<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">.</span>nextValue        <span class="token punctuation">&#125;</span>        State<span class="token punctuation">.</span>Done <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span>  <span class="token function">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"No value left."</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 使用suspendCoroutine挂起当前协程 * 并将当前状态流转为[State.Ready]状态，返回value */</span><span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">yield</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">&#123;</span> continuation <span class="token operator">-></span>    state <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>NotReady <span class="token operator">-></span> State<span class="token punctuation">.</span><span class="token function">Ready</span><span class="token punctuation">(</span>continuation<span class="token punctuation">,</span> value<span class="token punctuation">)</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>Ready<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">-></span> <span class="token keyword">throw</span> <span class="token function">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"cannot yield while ready."</span><span class="token punctuation">)</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>Done <span class="token operator">-></span> <span class="token keyword">throw</span>  <span class="token function">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"cannot yield while done."</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">yield</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">&#123;</span>    <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> state <span class="token operator">!=</span> State<span class="token punctuation">.</span>Done<span class="token punctuation">&#125;</span><span class="token comment">/** * 启动或者恢复协程 * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次 */</span><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">val</span> currentState <span class="token operator">=</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">is</span> State<span class="token punctuation">.</span>NotReady <span class="token operator">-></span> currentState<span class="token punctuation">.</span>continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 创建协程的completion回调 * 协程执行完成后回调 */</span><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    state <span class="token operator">=</span> State<span class="token punctuation">.</span>Done    <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">init</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> coroutineBlock<span class="token operator">:</span> <span class="token keyword">suspend</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">block</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// 带Receiver的方式创建协程</span>    <span class="token keyword">val</span> start <span class="token operator">=</span> coroutineBlock<span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token comment">// 初始化状态</span>    state <span class="token operator">=</span> State<span class="token punctuation">.</span><span class="token function">NotReady</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> GeneratorIterator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> block<span class="token operator">:</span> <span class="token keyword">suspend</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">,</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> parameter<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">:</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">generator</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token keyword">suspend</span> GeneratorScope<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> parameter<span class="token operator">:</span> T <span class="token operator">-></span>        <span class="token function">GeneratorImpl</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h2 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h2><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sequence <span class="token operator">=</span> sequence <span class="token punctuation">&#123;</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token function">yieldAll</span><span class="token punctuation">(</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>num <span class="token keyword">in</span> sequence<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> fibonacci <span class="token operator">=</span> sequence <span class="token punctuation">&#123;</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> current <span class="token operator">=</span> <span class="token number">1L</span>    <span class="token keyword">var</span> next <span class="token operator">=</span> <span class="token number">1L</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">yield</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>        next <span class="token operator">+=</span> current        current <span class="token operator">=</span> next <span class="token operator">-</span> current    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fibonacci<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span> <span class="token comment">// 使用take(10)获取前10个元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——基本原理</title>
    <link href="/2021/02/03/2a3d271f/"/>
    <url>/2021/02/03/2a3d271f/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">suspendFunc01</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">suspendFunc02</span><span class="token punctuation">(</span>a<span class="token operator">:</span> String<span class="token punctuation">,</span> b<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">&#123;</span> continuation <span class="token operator">-></span>    thread <span class="token punctuation">&#123;</span>        continuation<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">notSuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCoroutine<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token punctuation">&#123;</span> continuation <span class="token operator">-></span>    continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即Continuation传递变换，通过传递Continuation实例来控制异步调用流程。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend</strong>函数发现，<strong>notSuspend</strong>函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，我们称为<strong>CPS变换</strong>。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token function">notSuspend</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">Continuation</span> $completion<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">boolean</span> var1 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var2 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var3 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token class-name">SafeContinuation</span> var4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SafeContinuation</span><span class="token punctuation">(</span><span class="token class-name">IntrinsicsKt</span><span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span>$completion<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">Continuation</span> continuation <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Continuation</span><span class="token punctuation">)</span>var4<span class="token punctuation">;</span>   <span class="token keyword">int</span> var6 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token class-name">Integer</span> var8 <span class="token operator">=</span> <span class="token class-name">Boxing</span><span class="token punctuation">.</span><span class="token function">boxInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var9 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token class-name">Companion</span> var10 <span class="token operator">=</span> <span class="token class-name">Result<span class="token punctuation">.</span>Companion</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> var11 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   continuation<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token punctuation">.</span>constructor<span class="token operator">-</span><span class="token function">impl</span><span class="token punctuation">(</span>var8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">Object</span> var10000 <span class="token operator">=</span> var4<span class="token punctuation">.</span><span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>var10000 <span class="token operator">==</span> <span class="token class-name">IntrinsicsKt</span><span class="token punctuation">.</span><span class="token function">getCOROUTINE_SUSPENDED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">DebugProbesKt</span><span class="token punctuation">.</span><span class="token function">probeCoroutineSuspended</span><span class="token punctuation">(</span>$completion<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> var10000<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@PublishedApi</span><span class="token keyword">internal</span> <span class="token keyword">actual</span> <span class="token keyword">fun</span> <span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Any<span class="token operator">?</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token comment">// atomic read</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">===</span> UNDECIDED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>RESULT<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> UNDECIDED<span class="token punctuation">,</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> COROUTINE_SUSPENDED        result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token comment">// reread volatile var</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">when</span> <span class="token punctuation">&#123;</span>        result <span class="token operator">===</span> RESUMED <span class="token operator">-></span> COROUTINE_SUSPENDED <span class="token comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span>        result <span class="token keyword">is</span> Result<span class="token punctuation">.</span>Failure <span class="token operator">-></span> <span class="token keyword">throw</span> result<span class="token punctuation">.</span>exception        <span class="token keyword">else</span> <span class="token operator">-></span> result <span class="token comment">// either COROUTINE_SUSPENDED or data</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">launch <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> deferred <span class="token operator">=</span> async <span class="token punctuation">&#123;</span>        <span class="token comment">// 发起了一个网络请求</span>        <span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 做了一些操作</span>    <span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span>    deferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 假设在这里deferred已经执行完毕</span>    <span class="token comment">// 后续的一些操作</span>    <span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> coroutineContext<span class="token operator">:</span> CoroutineContext <span class="token operator">=</span> EmptyCoroutineContext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">list <span class="token operator">+=</span> <span class="token number">0</span>coroutineContext <span class="token operator">+=</span> Dispatchers<span class="token punctuation">.</span>IO  <span class="token comment">// Dispatchers.IO实现了Element接口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>我们来看下协程上下文中的元素类型：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> Element <span class="token operator">:</span> CoroutineContext <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * A key of this coroutine context element.     */</span>    <span class="token keyword">public</span> <span class="token keyword">val</span> key<span class="token operator">:</span> Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>E <span class="token operator">:</span> Element<span class="token operator">></span> <span class="token keyword">get</span><span class="token punctuation">(</span>key<span class="token operator">:</span> Key<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> E<span class="token operator">?</span> <span class="token operator">=</span>        <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"UNCHECKED_CAST"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token keyword">this</span> <span class="token keyword">as</span> E <span class="token keyword">else</span> <span class="token keyword">null</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">fold</span><span class="token punctuation">(</span>initial<span class="token operator">:</span> R<span class="token punctuation">,</span> operation<span class="token operator">:</span> <span class="token punctuation">(</span>R<span class="token punctuation">,</span> Element<span class="token punctuation">)</span> <span class="token operator">-></span> R<span class="token punctuation">)</span><span class="token operator">:</span> R <span class="token operator">=</span>        <span class="token function">operation</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">minusKey</span><span class="token punctuation">(</span>key<span class="token operator">:</span> Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> CoroutineContext <span class="token operator">=</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> EmptyCoroutineContext <span class="token keyword">else</span> <span class="token keyword">this</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token function">AbstractCoroutineContextElement</span><span class="token punctuation">(</span><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">val</span> key<span class="token operator">:</span> Key<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">:</span> Element<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">AbstractCoroutineContextElement</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> Key <span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span>CoroutineName<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token function">CoroutineExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">val</span> onErrorAction<span class="token operator">:</span> <span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token function">AbstractCoroutineContextElement</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> Key <span class="token operator">:</span> CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span>CoroutineExceptionHandler<span class="token operator">></span>    <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        error<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">onErrorAction</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">coroutineContext <span class="token operator">+=</span> <span class="token function">CoroutineName</span><span class="token punctuation">(</span><span class="token string">"Download Coroutine"</span><span class="token punctuation">)</span>coroutineContext <span class="token operator">+=</span> CoroutineExceptionHandler<span class="token punctuation">&#123;</span>    <span class="token comment">//  ... ...</span><span class="token punctuation">&#125;</span><span class="token keyword">suspend</span> <span class="token punctuation">&#123;</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> context<span class="token operator">:</span> CoroutineContext <span class="token operator">=</span> coroutineContext    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span>context<span class="token punctuation">[</span>CoroutineName<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        result<span class="token punctuation">.</span><span class="token function">onFailure</span> <span class="token punctuation">&#123;</span>            context<span class="token punctuation">[</span>CoroutineExceptionHandler<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">suspend</span> <span class="token punctuation">&#123;</span>    <span class="token function">suspendFunc02</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span>    <span class="token function">suspendFunc02</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Coroutine"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> LogInterceptor <span class="token operator">:</span> ContinuationInterceptor <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> key <span class="token operator">=</span> ContinuationInterceptor    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">interceptContinuation</span><span class="token punctuation">(</span>continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span>        <span class="token function">LogContinuation</span><span class="token punctuation">(</span>continuation<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> LogContinuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">:</span>    Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">by</span> continuation <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before resumeWith : <span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>        continuation<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after resumeWith."</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">before resumeWith <span class="token operator">:</span> <span class="token function">Success</span><span class="token punctuation">(</span>kotlin<span class="token punctuation">.</span>Unit<span class="token punctuation">)</span>after resumeWith<span class="token punctuation">.</span>before resumeWith <span class="token operator">:</span> <span class="token function">Success</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>after resumeWith<span class="token punctuation">.</span>before resumeWith <span class="token operator">:</span> <span class="token function">Success</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>after resumeWith<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">SafeContinuation</span><span class="token punctuation">(</span>IntrinsicsKt<span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span>$completion<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">actual</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span>    <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">as</span><span class="token operator">?</span> ContinuationImpl<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token keyword">this</span>    <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">></span> <span class="token operator">=</span>        intercepted            <span class="token operator">?:</span> <span class="token punctuation">(</span>context<span class="token punctuation">[</span>ContinuationInterceptor<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">interceptContinuation</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">&#123;</span> intercepted <span class="token operator">=</span> it <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Kotlin标准库1.4.21</p><p><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p>**Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现。 **不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>    completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">SafeContinuation</span><span class="token punctuation">(</span><span class="token function">createCoroutineUnintercepted</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> COROUTINE_SUSPENDED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> continuation <span class="token operator">=</span> <span class="token keyword">suspend</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine Start."</span><span class="token punctuation">)</span>    <span class="token string">"return value."</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">override</span> <span class="token keyword">val</span> context<span class="token operator">:</span> CoroutineContext        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> EmptyCoroutineContext    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine End : <span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span>   <span class="token comment">// 启动协程</span><span class="token comment">// 控制台输出：</span>Coroutine Start<span class="token punctuation">.</span>Coroutine End <span class="token operator">:</span> <span class="token function">Success</span><span class="token punctuation">(</span><span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>    completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">createCoroutineUnintercepted</span><span class="token punctuation">(</span>completion<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intercepted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，这里就不贴源码了毕竟这篇只是个初识（笑），这里要说的是SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>Unit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">suspend</span> R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createCoroutine</span><span class="token punctuation">(</span>    receiver<span class="token operator">:</span> R<span class="token punctuation">,</span>    completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">suspend</span> R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>    receiver<span class="token operator">:</span> R<span class="token punctuation">,</span>    completion<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>R<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token function">launchCoroutine</span><span class="token punctuation">(</span>receiver<span class="token operator">:</span> R<span class="token punctuation">,</span> block<span class="token operator">:</span> <span class="token keyword">suspend</span> R<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    block<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> <span class="token keyword">object</span> <span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">override</span> <span class="token keyword">val</span> context<span class="token operator">:</span> CoroutineContext            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> EmptyCoroutineContext        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coroutine End : <span class="token interpolation variable">$result</span>"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> MainScope<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">xor</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">ushr</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">fun</span> <span class="token function">callLaunchCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">launchCoroutine</span><span class="token punctuation">(</span>MainScope<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Start Coroutine."</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>        <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们**main()**函数可以直接被声明为suspend：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var0<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">RunSuspendKt</span><span class="token punctuation">.</span><span class="token function">runSuspend</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CoroutineKt</span>$$$<span class="token function">main</span><span class="token punctuation">(</span>var0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">internal</span> <span class="token keyword">fun</span> <span class="token function">runSuspend</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token keyword">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> run <span class="token operator">=</span> <span class="token function">RunSuspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    block<span class="token punctuation">.</span><span class="token function">startCoroutine</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span>    run<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><div class="code-wrapper"><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">resumeWith</span><span class="token punctuation">(</span>result<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Unit<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> result    <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"PLATFORM_CLASS_MAPPED_TO_KOTLIN"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">as</span> Object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">fun</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">null</span> <span class="token operator">-></span> <span class="token annotation builtin">@Suppress</span><span class="token punctuation">(</span><span class="token string">"PLATFORM_CLASS_MAPPED_TO_KOTLIN"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">as</span> Object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// throw up failure</span>                <span class="token keyword">return</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><p>参考：</p><p><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a></p><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
