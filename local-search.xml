<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程——从ReentrantLock来看AQS的应用</title>
    <link href="/2021/08/12/d2738127/"/>
    <url>/2021/08/12/d2738127/</url>
    
    <content type="html"><![CDATA[<p><a href="2021/08/05/d2738127/">上篇文章</a>简单梳理了一下AQS原理，这篇文章通过ReentrantLock来看JUC包是如何应用AQS的。</p><h2 id="ReentrantLock概述"><a href="#ReentrantLock概述" class="headerlink" title="ReentrantLock概述"></a>ReentrantLock概述</h2><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁，它通过AQS框架来提供公平锁与非公平锁的两种实现。</p><p>可以将其与<strong>Synchronized</strong>对比，区别如下：</p><table><thead><tr><th align="center"></th><th align="center">ReentrantLock</th><th align="center">Synchronized</th></tr></thead><tbody><tr><td align="center">锁实现机制</td><td align="center">依赖AQS</td><td align="center">依赖Monitor</td></tr><tr><td align="center">灵活性</td><td align="center">支持响应中断、超时、尝试获取锁</td><td align="center">不灵活</td></tr><tr><td align="center">释放形式</td><td align="center">必须显示调用unlock()释放锁</td><td align="center">由编译器来保证monitorexit</td></tr><tr><td align="center">锁类型</td><td align="center">公平锁与非公平锁</td><td align="center">非公平锁</td></tr><tr><td align="center">条件队列</td><td align="center">可关联多个条件队列</td><td align="center">关联一个条件队列</td></tr><tr><td align="center">可重入性</td><td align="center">可重入</td><td align="center">可重入</td></tr></tbody></table><p>ReentrantLock本身没有实现AQS，而是通过内部类<strong>FairSync</strong>和<strong>NonfairSync</strong>来实现AQS，这两个类对应公平锁和非公平锁的实现，下面分别来看具体实现。</p><h2 id="非公平锁实现"><a href="#非公平锁实现" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h2><p>ReentrantLock 要实现非公平锁只需在创建时传入 false 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁的实现在NonfairSync类中，下面以代码为例，分析ReentrantLock在非公平锁的实现下的加锁与解锁过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> val reentrantLock = ReentrantLock(<span class="hljs-keyword">false</span>)<br><br><span class="hljs-function">fun <span class="hljs-title">tryGetResourceLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    reentrantLock.lock()<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        reentrantLock.unlock()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>当前线程执行到reentrantLock.lock方法时，会尝试获取锁，来到NonfairSync的lock方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通过CAS操作来修改state，即插队</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-comment">// 修改成功，设置当前持有锁的线程</span><br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 修改失败，进入正常流</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于非公平锁，它允许线程插队争夺锁，因此代码中首先利用了CAS机制来争夺锁，即插队，成功则更新当前持有锁的线程，失败调用<code>acquire</code>方法。</p><p><code>acquire</code>方法在<a href="2021/08/05/d2738127/">上篇文章</a>中已经详细介绍了，我们再来看一下它的方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>之前我们说到<code>tryAcquire</code>方法是由子类实现，来看NonfairSync是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br></code></pre></td></tr></table></figure><p>仅仅是调用了<code>nonfairTryAcquire</code>方法，这个方法定义在NonfairSync的父类<strong>Sync</strong>里，来看看它是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果c=0，再次尝试获取锁</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// c不为0，但当前线程为独占锁持有者</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-comment">// 直接增加重入次数</span><br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>      <br>        <span class="hljs-comment">// 可能溢出</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法中重新获取了当前同步状态state，并且根据state的状态有：</p><ul><li>如果state为0，说明有线程释放了锁，可以尝试再次获取锁，成功则返回true</li><li>如果state不为0，并且当前线程为锁持有者，则直接增加重入次数，这说明ReentrantLock是可重入的。另外还增加了对于可能存在的Int值的溢出判断，不过这里实际上目前是不太可能执行到的，因为在这之前可能已经出现StackOverflow了。</li><li>其他情况返回false，表示获取锁失败</li></ul><p>假如方法返回了false，则表示当前线程未能成功抢到锁，则会加入到CLH同步队列中并阻塞，这个在上篇文章已经详细介绍过了，这里不再赘述。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>当代码执行到reentrant.unlock方法时，会执行锁的释放操作，来看看unlock的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法直接调用了AQS中的release方法，同样在上篇文章详细介绍过，再来看下方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryRelease</code>方法在Sync类中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-comment">// state的预期值</span><br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>  <br>    <span class="hljs-comment">// c为0，表示所有线程都释放了锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 独占模式不需要CAS</span><br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于独占锁来说，只有可能是锁的持有线程才可能修改State的值，因此整个释放过程不需要CAS来参与。</p><p>由于可能存在多次重入，本次释放后可能当前state不为0，那么当前线程依然是锁的持有者。</p><p>如果释放后state为0，则表示当前线程已经完全释放了锁，则进入后续操作，唤醒后继节点。</p><p>到这里NonfairSync类就解析完成了，可以看到在AQS框架的基础上要实现一个锁还是非常简单的。</p><h2 id="公平锁实现"><a href="#公平锁实现" class="headerlink" title="公平锁实现"></a>公平锁实现</h2><p>下面来看看公平锁实现，在FairSync类中。</p><p>FairSync与NonFairSync仅仅在获取锁的过程有差别，因此我们只需要关注获取锁即可。</p><p>同样的在<code>lock</code>方法和<code>tryAcquire</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里的实现与非公平锁非常类似，仅有少许差别，分别是：</p><ul><li>在<code>lock</code>方法中，不同于非公平锁会先采用CAS尝试插队，公平锁直接调用了<code>acquire</code>方法来尝试获取锁</li><li>在<code>tryAcquire</code>方法中，如果此时已经同步资源已经处于无锁状态（state为0），当前线程将不会立马去尝试获取锁，而是先判断队列中有没有正在等待的线程，而且这个线程不是当前线程，如果有的话将返回false，没有才会尝试获取锁。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章基于ReentrantLock的源码了解了AQS框架的应用，学习了如果使用AQS来实现公平锁与非公平锁，同时也加深了对于这两种锁的区别的理解。</p>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AQS</tag>
      
      <tag>ReentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程——AQS原理</title>
    <link href="/2021/08/05/d2738127/"/>
    <url>/2021/08/05/d2738127/</url>
    
    <content type="html"><![CDATA[<p>AQS 全称是 <strong>Abstract Queued Synchronizer</strong>，一般翻译为<strong>同步器</strong>。它是一套实现多线程同步功能的<strong>框架</strong>，由大名鼎鼎的 Doug Lea 操刀设计并开发实现的。AQS 在源码中被广泛使用，尤其是在 JUC包中，比如 <strong>ReentrantLock</strong>、<strong>Semaphore</strong>、<strong>CountDownLatch</strong>、<strong>ThreadPoolExecutor</strong>。</p><p>理解 AQS 对我们理解 JUC 中其他组件至关重要，并且在实际开发中也可以通过自定义 AQS 来实现各种需求场景。</p><h2 id="框架概览"><a href="#框架概览" class="headerlink" title="框架概览"></a>框架概览</h2><p>首先，我们来纵览一下整个AQS框架：</p><p><img src="/img/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="AQS框架概览（图源美团技术团队）"></p><p>其中：</p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架。</p><h2 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h2><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p><p>这个机制就是<strong>CLH同步队列</strong>，想要搞懂AQS原理我们需要了解一下这个数据结构。</p><p> CLH同步队列是一个FIFO双向队列，其名字源于Craig、Landin 和 Hagersten三位大佬的名字首字母，AQS依赖它来完成同步状态的管理。</p><p>当前线程如果获取同步状态失败时，AQS则会将当前线程和等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>这里说的节点，在源码中为<strong>Node</strong>类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">/** 共享 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br><br>    <span class="hljs-comment">/** 独占 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/** 等待状态 */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br>    <span class="hljs-comment">/** 前驱节点 */</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br><br>    <span class="hljs-comment">/** 后继节点 */</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br><br>    <span class="hljs-comment">/** 获取同步状态的线程 */</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>    Node nextWaiter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>        Node p = prev;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    Node() &#123;<br>    &#125;<br><br>    Node(Thread thread, Node mode) &#123;<br>        <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br><br>    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123;<br>        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的方法和属性：</p><table><thead><tr><th align="center">方法和属性值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SHARED</td><td align="center">表示线程以共享的模式等待锁</td></tr><tr><td align="center">EXCLUSIVE</td><td align="center">表示线程正在以独占的方式等待锁</td></tr><tr><td align="center">waitStatus</td><td align="center">当前节点在队列中的状态</td></tr><tr><td align="center">thread</td><td align="center">表示处于该节点的线程</td></tr><tr><td align="center">prev</td><td align="center">前驱指针</td></tr><tr><td align="center">predecessor</td><td align="center">返回前驱节点，没有的话抛出npe</td></tr><tr><td align="center">nextWaiter</td><td align="center">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="center">next</td><td align="center">后继指针</td></tr></tbody></table><p>其中<strong>SHARED</strong>和<strong>EXCLUSIVE</strong>表示锁的两种模式。</p><p>waitStatus表示节点在队列中的等待状态，它有几个枚举值：</p><ul><li><strong>0</strong>：当一个Node被初始化的时候的默认值，或者当前Node对应线程刚刚被唤醒</li><li><strong>1（CANCELLED）</strong>：由于超时或者中断，线程获取的锁的请求已经取消了，节点一旦被取消了就不会再改变状态，取消节点的线程不会再阻塞。</li><li><strong>-1（SIGNAL）</strong>：表示此节点的后继节点已经处于阻塞状态，当此节点在释放或者取消时，需要唤醒后继节点。</li><li><strong>-2（CONDITION）</strong>：表示节点在条件等待队列中，标记为CONDITION的节点会被移动到一个特殊的条件等待队列，直到条件时才会被重新移动到同步等待队列 。</li><li><strong>-3（PROPAGATE）</strong>：当前线程处在SHARED情况下，该字段才会使用，表示应将releaseShared传播到其他节点。</li></ul><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>看过上面Node结点我们知道CHL是基于链表的实现，那么入队其实只需要尾节点即可，不过过程中由于涉及到多线程所以需要配合CAS操作使用。</p><p>具体的实现在<code>addWaiter</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 快速设置</span><br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 自旋尝试</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>addWaiter方法首先尝试使用CAS将AQS中保存的tail，即队尾替换为当前需要入队的Node，如果成功则Node成功入队，如果失败说明其他线程也在调用addWaiter进行入队，则自旋不断尝试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node t = tail;<br>        <span class="hljs-comment">// tail为null，此时队列未初始化</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-comment">// 尝试更新tail</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于tail为null的情况，说明此时CHL队列还未初始化，那么将会创建一个head来初始化队列。这里有个关键的地方在于，队列的Head是通过Node的无参构造创建的，这说明CHL中队头CLH是一个亚节点（Dummy Head），不具备其他意义。</p><p>对于tail不为null的情况，使用CAS替换tail引用来更新尾节点。</p><p>过程图如下：</p><p><img src="/img/image-20200922235737756.png" alt="入队"></p><p> 虚线表示此次入队所做操作，包括：</p><ol><li>将current的prev指针指向Node2，即tail</li><li>将Node2的next指针指向current</li><li>将AQS中保存的tail指针指向current</li></ol><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>CLH同步队列遵循FIFO，首节点对应的线程释放同步状态后，将会<strong>唤醒它的后继节点</strong>，而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><p>首先来看如何唤醒后继节点，在方法<code>unparkSuccessor</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意这里node为队头head</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// head的next指针为真正的队头</span><br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 从队尾开始寻找队列中head的合适的后继节点</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-comment">// waitStatus大于0即取消状态（1）</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 唤醒后继节点对应线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可知所谓后继节点并不一定就是head的next指针指向的节点，如果next指针指向的节点的waitStatus大于0，则会跳过。根据前面的小节，我们知道大于0其实就是<code>CANCELLED</code>状态，此状态表示该节点对应线程已经取消了此次锁的申请，对应的我们可以直接跳过此节点使其出队。</p><p>后继节点被唤醒后，需要更改指向将自己设置为首节点，对应代码在<code>acquireQueued</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获取node的前驱节点</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 前驱节点为头节点且获取同步状态成功</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 更新Node为头节点，即出队</span><br>                <span class="hljs-comment">// 同时会断开prev指针</span><br>                setHead(node);<br>                <span class="hljs-comment">// 断开原头节点的nex指针</span><br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程图如下：</p><p><img src="/img/image-20200923000041778.png" alt="出队"></p><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><p>在了解数据结构后，接下来了解一下AQS的同步状态——<strong>State</strong>。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><p>AQS中提供了几个方法给子类来访问这个字段：</p><table><thead><tr><th align="left">方法名</th><th>描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td>获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td>设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td>使用CAS方式更新State</td></tr></tbody></table><p>仅仅只需要上面三个方法，我们就可以实现共享资源的两套模式：<strong>独占模式（EXCLUSIVE）</strong>和<strong>共享模式（SHARED）</strong>。</p><p> 如果熟悉操作系统的话，可以将state类比为Linux中的信号量，信号量的值表示当前空闲的共享资源数量，而state的值则表示当前持有同步状态的线程数量。</p><p>那么对于独占模式，即互斥模式来说，state只会有两个可能的值：0和1。</p><p>其中0表示当前没有线程持有同步状态，即没有线程持有锁，这时如果线程A尝试获取锁，只需要使用CAS替换state的状态为1，如果成功则表示它拿到了这个互斥锁，失败表示存在锁竞争。</p><p>1表示有线程持有同步状态，即当前有线程持有这个互斥锁，这时如果未持有锁的线程尝试获取锁发现state为1，将直接进行入队。</p><p>下面我们就来看看独占模式和共享模式分别是如何实现的。</p><h3 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h3><p>独占模式表示同一时刻有且仅有一个线程能够持有同步状态，也就是我们常说的<strong>互斥</strong>模式。</p><h4 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h4><p>AQS提供了<code>acquire(int arg)</code>模版方法为独占式获取同步状态。</p><p>该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法只有三行，但涉及到了三个方法，定义如下：</p><ul><li>tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。此方法涉及到具体实现，因此由子类来完成，注意实现时必须要保证获取同步状态操作是线程安全的。</li><li>addWaiter：此方法上一节介绍过，如果<code>tryAcquire</code>返回false，表示获取同步状态失败，则调用该方法将当前线程加入到CLH同步队列尾部。</li><li>acquireQueued：此方法上一节介绍过，当前线程在获取锁失败后会进行阻塞，不过不是立马阻塞，而是先设置前一个节点为<code>SIGNAL</code>，再进行阻塞，知道前一个节点将其唤醒。</li><li>selfInterrupt：产生一个中断。</li></ul><p>其中逻辑主要在<code>addWaiter</code>和<code>acquireQueued</code>中，其中<code>addWaiter</code>在上一节已经详细介绍了，<code>acquireQueued</code>只介绍了替换头部的这部分，这里我们再来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果前驱节点不为head或者获取锁时失败了</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用<code>addWaiter</code>之后执行此方法，假设此时Node的前驱节点不是Head，或者Node获取同步状态失败了，那么会调用<code>shouldParkAfterFailedAcquire</code>方法和<code>parkAndCheckInterrupt</code>方法。</p><h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">// 前驱结点已经设置了SIGNAL，当前节点可以直接阻塞等待被唤醒</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果前驱节点已经处于CANCELLED状态时</span><br>        <span class="hljs-comment">// 跳过这些无效的前驱节点</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 前驱节点的waitStatus为0或者PROPAGATE</span><br>        <span class="hljs-comment">// 这种情况当前节点线程不能直接阻塞，因为前驱结点还未设置SIGNAL</span><br>        <span class="hljs-comment">// CAS操作设置前驱结点waitStatus为SIGNAL</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法主要做了以下工作：</p><ul><li><p>如果前驱节点的状态为<code>SIGNAL</code>，说明闹钟标志已设好，返回true表示当前节点可以阻塞了。</p></li><li><p>如果前驱节点的状态为<code>CANCELLED</code>，说明前驱节点本身不再等待了，需要跨越这些节点，然后找到一个有效节点，再把node和这个有效节点的前驱后继连接好。</p></li><li><p>如果是其他情况，那么CAS尝试设置前驱节点为<code>SIGNAL</code>。</p></li></ul><p>可以看到此方法主要是要保证前驱节点设置好了<code>SIGNAL</code>状态，只要前驱节点已经为<code>SIGNAL</code>状态就会返回true，表示当前节点可以被阻塞了。</p><p>而<code>shouldParkAfterFailedAcquire</code>在死循环中调用，因此对于前驱不为head的情况，可以保证最终一定能设置前驱为<code>SIGNAL</code>成功。</p><p>当<code>shouldParkAfterFailedAcquire</code>返回了true时，调用<code>parkAndCheckInterrupt</code>阻塞线程。</p><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h5><p>此方法将会阻塞当前线程，并且在唤醒后检测中断状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 注意返回值是是否响应了中断而唤醒</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里整个<code>acquire</code>方法执行流程就分析完了，如下图所示：</p><p><img src="/img/image-20201023181429840.png" alt="acquire执行流程"></p><blockquote><p>注意：对于独占式同步状态的获取，AQS支持响应中断与超时检测，对应<code>acquireInterruptibly</code>、<code>doAcquireInterruptibly</code>和<code>tryAcquireNanos</code>、<code>doAcquireNanos</code>方法，这些方法与上文介绍的流程大同小异，因此这里不再赘述。</p></blockquote><h4 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h4><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS提供了了<code>release(int arg)</code>方法释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，类似于<code>tryAcquire</code>，<code>release</code>方法中首先通过<code>tryRelease</code>方法来判断是否释放成功，<code>tryRelease</code>也是一个抽象方法需要子类实现。</p><p>释放成功后，会调用<code>unparkSuccessor</code>方法唤醒后继节点。<code>unparkSuccessor</code>方法在<strong>出队</strong>这一小节已经详细介绍过了，不再赘述。</p><h3 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h3><p>共享模式表示允许多个线程同时持有同步状态，我们常说的读写锁中的读锁就是这种模式。</p><h4 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h4><p>AQS提供<code>acquireShared</code>方法共享式获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用<code>tryAcquireShared</code>方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。</p><p><code>tryAcquireShared</code>同样是一个未实现的方法，需要由子类实现，不过对于这个方法的返回值需要重点注意下：</p><ul><li>返回值小于0：表示获取共享同步状态失败</li><li>返回值等于0：表示获取共享同步状态成功，但没有剩余同步状态可以获取</li><li>返回值大于0：表示获取共享同步状态成功，并且还有”返回值“个同步状态资源可以获取，需要传播到队列的后继节点中</li></ul><p>如何利用这个返回值呢，来看看<code>doAcquireShared</code>。</p><h5 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 向队列中添加一个节点，其nextWaiter指向SHARED</span><br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 前驱节点</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 如果p是头节点，尝试获取共享同步状态</span><br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-comment">// 获取共享同步状态成功</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 设置头节点并且传播共享锁</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法与上节独占式同步获取中<code>acquireQueued</code>十分类似，区别在于这里使用<code>tryAcquireShared</code>方法来获取共享同步状态，并且调用了<code>setHeadAndPropagate</code>方法来设置头节点。</p><p><code>setHeadAndPropagate</code>由名字可知，其除了设置头节点外，还需要传播共享锁状态，来看看源码。</p><h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    <span class="hljs-comment">// 保存旧头节点</span><br>    Node h = head;<br>    <span class="hljs-comment">// 设置新头节点，执行完后head为当前node</span><br>    setHead(node);<br><br>    <span class="hljs-comment">// 满足条件的情况下释放共享锁并唤醒后继节点</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<br>            <span class="hljs-comment">// 释放共享同步状态</span><br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看两个入参：<strong>node代表的线程一定是当前线程，propagate则表示剩余可获取的共享同步状态</strong>。</p><p>方法中首先保存了旧头节点，同时设置了node为新的头节点。</p><p>第一个if条件判断逻辑较为复杂，我们来重点梳理一下：</p><ul><li><code>propagate  &gt; 0</code>：传入的propagate可能是0也可能是正整数，当大于0时表示需要传播共享锁，因此可以直接短路。</li><li><code>h == null || h.waitStatus &lt; 0</code>：由于方法一开始就将head赋值给了h，因此这里h == null是不可能成立的。而h的waitStatus可能有两种情况：<ul><li>h.waitStatus为<strong>0</strong>：这个情况表示某个线程释放了锁，或者在获取共享锁时传播给后继节点共享锁状态，将h的h.waitStatus更新为了0，具体实现在<code>doReleaseShared</code>方法中，下一节会介绍。</li><li>h.waitStatus为<strong>PROPAGATE</strong>：同样是<code>doReleaseShared</code>中唤醒后继节点时将head的waitStatus更新为0，但又有其他线程执行了<code>doReleaseShared</code>，将waitStatus更新为了PROPAGATE。</li></ul></li><li><code>(h = head) == null || h.waitStatus &lt; 0)</code>：判断新head（下称：node）是否为null或者h.waitStatus小于0。一般node不会为null，而node的waitStatus可能有多种情况：<ul><li>node.waitStatus为<strong>0</strong>：后继节点刚好入队列，还没有走到<code>shouldParkAfterFailedAcquire</code>中的修改前继节点<code>waitStatus</code>的代码。</li><li>node.waitStatus为<strong>PROPAGATE</strong>：上一个共享节点被唤醒后，成为新head，后继节点刚入队列，又有其他线程释放锁调用<code>doReleaseShared</code>，<code>node.waitStatus</code>从0改为-3。</li><li>node.waitStatus为<strong>SIGNAL</strong>：已经调用了<code>shouldParkAfterFailedAcquire</code>，<code>node.waitStatus</code>从0或者PROPAGATE改为SIGNAL，可能阻塞，可能未阻塞。</li></ul></li></ul><p>可以看到由于共享锁的特殊性，相比于独占锁，这里更多的是要考虑其他线程可能会修改新/旧头节点的情况，逻辑较为复杂，了解即可。</p><p>上面多个条件只需满足一个即可if代码块中，当后继节点为共享状态时，调用<code>doReleaseShared</code>将共享状态传播给后继节点。</p><h4 id="共享式同步状态释放"><a href="#共享式同步状态释放" class="headerlink" title="共享式同步状态释放"></a>共享式同步状态释放</h4><p>共享式同步状态释放逻辑在<code>doReleaseShared</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了保证线程安全，共享锁的释放操作同样需要自旋配合CAS来完成。</p><p>释放时同样需要判断当前head的waitStatus来确保成功：</p><ul><li>当waitStatus为SIGNAL时：尝试更新head的waitStatus为0，成功则调用<code>unparkSuccessor</code>唤醒后继节点，并且<code>unparkSuccessor</code>中会更新waitStatus为SIGNAL，失败表示有其他线程更改了waitStatus，重新循环</li><li>当waitStatus为0时：此状态说明有线程执行了<code>doReleaseShared</code>并将waitStatus成功更新为0，但还未执行<code>unparkSuccessor</code>，或在<code>unparkSuccessor</code>更新waiStatus失败，此时当前线程刚好执行到<code>doReleaseShared</code>就会发现waitStatus为0。这种情况尝试更新waitStatus为PROPAGATE，失败将会继续循环。</li></ul><p>当上面两个操作中有一个执行成功时，将会继续执行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>当前head如果发生了改变，继续循环，没有发生改变则说明此次释放操作成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从数据结构到独占和共享锁的获取与释放过程简单分析了AQS框架的一些原理，当然这些只是冰山一角，实际上整个框架的设计非常巧妙，阅读源码时感觉很晦涩，可能是自己的多线程知识掌握的不够好。</p><p>下一篇文章将会从ReentrantLock的实现来看AQS的应用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《Java并发编程实战》</li><li>《Java并发编程的艺术》</li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67#/detail/pc?id=1864">深入理解 AQS 和 CAS 原理</a></li><li><a href="https://www.cmsblogs.com/article/1391311158086078464">J.U.C之AQS：CLH同步队列</a></li><li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href="http://www.tuicool.com/articles/MveUNzF">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></li><li><a href="https://blog.csdn.net/anlian523/article/details/106448512/">AQS深入理解 shouldParkAfterFailedAcquire源码分析 状态为0或PROPAGATE的情况分析</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AQS</tag>
      
      <tag>CLH</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（六）——ANR机制从产生到消费</title>
    <link href="/2021/07/30/8c057ce7/"/>
    <url>/2021/07/30/8c057ce7/</url>
    
    <content type="html"><![CDATA[<p>最近看了几篇关于ANR机制的文章，本篇文章来源码跟踪一下ANR消息的产生、消费与dump的全过程，彻底理解ANR出现的原因，并且讨论如何监控ANR的产生。</p><h2 id="ANR机制原理"><a href="#ANR机制原理" class="headerlink" title="ANR机制原理"></a>ANR机制原理</h2><p>ANR（Application Not Responding）机制是Android系统中一种监控用户App是否长时间未响应的一种机制，类似于Windows系统中的“窗口未响应”。</p><p>既然是监控耗时，类似于我们监控一个方法的执行时间，一定会在方法执行前做一些记录，然后与方法执行结束后进行对比，ANR中也是类似的。</p><h3 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h3><p>那么哪些场景下会导致ANR呢？主要有以下几种情况：</p><ol><li><strong>KEY_DISPATCHING_TIMEOUT</strong>：输入事件分发超过5秒，包括触摸事件与按键事件。</li><li><strong>BROADCAST_FG_TIMEOUT</strong>：前台广播在10秒内未执行完成。</li><li><strong>BROADCAST_BG_TIMEOUT</strong>：后台广播在60秒内未执行完成。</li><li><strong>SERVICE_TIMEOUT</strong>：前台服务在20秒内未执行完成。</li><li><strong>SERVICE_BACKGROUND_TIMEOUT</strong>：后台服务在200秒内未执行完成。</li><li><strong>CONTENT_PROVIDER_PUBLISH_TIMEOUT</strong>：内容提供者在publish时超过10秒。</li></ol><p>以上时间是基于Android 10.0源码的，具体时间定义在<code>ActivityManagerService.java</code>、<code>ActivityTaskManagerService</code>和<code>ActiveServices.java</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">[ActivityManagerService.java]<br><span class="hljs-comment">// How long we wait for an attached process to publish its content providers</span><br><span class="hljs-comment">// before we decide it must be hung.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONTENT_PROVIDER_PUBLISH_TIMEOUT = <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// How long we allow a receiver to run before giving up on it.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BROADCAST_FG_TIMEOUT = <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BROADCAST_BG_TIMEOUT = <span class="hljs-number">60</span>*<span class="hljs-number">1000</span>;<br><br>[ActivityTaskManagerService.java]<br><span class="hljs-comment">// How long we wait until we timeout on key dispatching.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> KEY_DISPATCHING_TIMEOUT_MS = <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>;<br><br>[ActiveServices.java]<br><span class="hljs-comment">// How long we wait for a service to finish executing.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_TIMEOUT = <span class="hljs-number">20</span>*<span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// How long we wait for a service to finish executing.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>下面以后台服务为例，分析ANR机制的触发流程。</p><h3 id="触发流程"><a href="#触发流程" class="headerlink" title="触发流程"></a>触发流程</h3><p>我们从服务的启动过程来寻找ANR相关代码，由于代码比较多，并且启动Service的过程与Activity的启动很类似，而前面已经写了篇文章来详细讲解Activity的启动过程了，所以这里选择跳过部分代码。</p><h4 id="ActiveServices-realStartServiceLocked"><a href="#ActiveServices-realStartServiceLocked" class="headerlink" title="ActiveServices#realStartServiceLocked"></a>ActiveServices#realStartServiceLocked</h4><p>直接来到ActiveServices中的<code>realStartServiceLocked</code>方法中：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realStartServiceLocked</span><span class="hljs-params">(ServiceRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">        ProcessRecord app, <span class="hljs-keyword">boolean</span> execInFg)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> newService = app.services.add(r);<br>    bumpServiceExecutingLocked(r, execInFg, <span class="hljs-string">&quot;create&quot;</span>);<br>    mAm.updateLruProcessLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>    updateServiceForegroundLocked(r.app, <span class="hljs-comment">/* oomAdj= */</span> <span class="hljs-keyword">false</span>);<br>    mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE);<br>     ···<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法首先调用了<code>bumpServiceExecutingLocked</code>，这里有我们寻找的代码，跟进。</p><h4 id="ActiveServices-bumpServiceExecutingLocked"><a href="#ActiveServices-bumpServiceExecutingLocked" class="headerlink" title="ActiveServices#bumpServiceExecutingLocked"></a>ActiveServices#bumpServiceExecutingLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bumpServiceExecutingLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> fg, String why)</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 记录当前时间</span><br>    <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>    <span class="hljs-keyword">if</span> (r.executeNesting == <span class="hljs-number">0</span>) &#123;<br>        r.executeFg = fg;<br>        ServiceState stracker = r.getTracker();<br>        <span class="hljs-keyword">if</span> (stracker != <span class="hljs-keyword">null</span>) &#123;<br>            stracker.setExecuting(<span class="hljs-keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r.app != <span class="hljs-keyword">null</span>) &#123;<br>            r.app.executingServices.add(r);<br>            r.app.execServicesFg |= fg;<br>            <span class="hljs-keyword">if</span> (timeoutNeeded &amp;&amp; r.app.executingServices.size() == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// </span><br>                scheduleServiceTimeoutLocked(r.app);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.app != <span class="hljs-keyword">null</span> &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;<br>        r.app.execServicesFg = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (timeoutNeeded) &#123;<br>            <span class="hljs-comment">// </span><br>            scheduleServiceTimeoutLocked(r.app);<br>        &#125;<br>    &#125;<br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>这里无论是哪个if分支都调用了<code>scheduleServiceTimeoutLocked</code>方法，看名字猜测其余Service的超时有关，继续跟进。</p><h4 id="ActiveServices-scheduleServiceTimeoutLocked"><a href="#ActiveServices-scheduleServiceTimeoutLocked" class="headerlink" title="ActiveServices#scheduleServiceTimeoutLocked"></a>ActiveServices#scheduleServiceTimeoutLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleServiceTimeoutLocked</span><span class="hljs-params">(ProcessRecord proc)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (proc.executingServices.size() == <span class="hljs-number">0</span> || proc.thread == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// mAm为ActivityManager</span><br>    Message msg = mAm.mHandler.obtainMessage(<br>            ActivityManagerService.SERVICE_TIMEOUT_MSG);<br>    msg.obj = proc;<br>    mAm.mHandler.sendMessageDelayed(msg,<br>            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里通过<strong>ActivityManager</strong>的Handler创建一个消息，指定类型为<strong>ActivityManagerService.SERVICE_TIMEOUT_MSG</strong>，并且根据服务是否前后台来设置了不同的Delay值。</p><p>接下来我们可以直接去Handler的handleMessage方法中寻找对应的消息是如何处理的。</p><h4 id="MainHandler-handleMessage"><a href="#MainHandler-handleMessage" class="headerlink" title="MainHandler#handleMessage"></a>MainHandler#handleMessage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>        <span class="hljs-keyword">case</span> GC_BACKGROUND_PROCESSES_MSG: &#123;<br>            <span class="hljs-keyword">synchronized</span> (ActivityManagerService.<span class="hljs-keyword">this</span>) &#123;<br>                performAppGcsIfAppropriateLocked();<br>            &#125;<br>        &#125; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;<br>            <span class="hljs-comment">// 处理后台服务超时消息</span><br>            mServices.serviceTimeout((ProcessRecord)msg.obj);<br>        &#125; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SERVICE_FOREGROUND_TIMEOUT_MSG: &#123;<br>            <span class="hljs-comment">// 处理前台服务超时消息</span><br>            mServices.serviceForegroundTimeout((ServiceRecord)msg.obj);<br>        &#125; <span class="hljs-keyword">break</span>;<br>         <br>        ···<br>          <br>&#125;<br></code></pre></td></tr></table></figure><p>mServices为ActiveServices对象，可以看到这里又交回给ActiveServices来处理。</p><h4 id="ActiveServices-serviceTimeout"><a href="#ActiveServices-serviceTimeout" class="headerlink" title="ActiveServices#serviceTimeout"></a>ActiveServices#serviceTimeout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serviceTimeout</span><span class="hljs-params">(ProcessRecord proc)</span> </span>&#123;<br>    String anrMessage = <span class="hljs-keyword">null</span>;<br>    <br>    ···<br>    <br>    <span class="hljs-comment">// 如果Service还在执行且已经超时，并且其所在进程还在执行中，anrMessage不为null</span><br>    <span class="hljs-keyword">if</span> (anrMessage != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 消费ANR</span><br>        proc.appNotResponding(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, anrMessage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在这里调用了ProcessRecord的<code>appNotResponding</code>方法来消费ANR事件，执行后续的弹框、dump堆栈等操作，这部分将会在后文分析。</p><p>到这里就完成了ANR消息的产生与消费的流程，不过还有一点没有分析，就是消息在何时被移除。</p><p>我们可以通过全局搜索的方式来寻找此条消息类型的remove是在何时调用的：</p><p><img src="/img//image-20210819173001359.png" alt="消息移除搜索"></p><p>可以看到是在ActiveServices中的<code>serviceDoneExecutingLocked</code>进行消息的移除。</p><p>继续利用全局搜索我们可以知道最早的调用时机是在Service的<strong>Create</strong>生命周期中，具体是在ActivityThread的<code>handleCreateService</code>方法中，接着来看这个方法。</p><h4 id="ActivityThread-handleCreateService"><a href="#ActivityThread-handleCreateService" class="headerlink" title="ActivityThread#handleCreateService"></a>ActivityThread#handleCreateService</h4><blockquote><p>frameworks/base/core/java/android/app/ActivityThread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCreateService</span><span class="hljs-params">(CreateServiceData data)</span> </span>&#123;<br>    ···<br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 移除超时消息</span><br>            ActivityManager.getService().serviceDoneExecuting(<br>                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Unable to create service &quot;</span> + data.info.name<br>                + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>handleCreateService</code>中通过RPC的方式来通知AMS移除对应的消息。</p><p>另外在Service的其他生命周期中也有调用<code>serviceDoneExecuting</code>方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg">微信Android客户端的ANR监控方案</a></li><li><a href="https://juejin.cn/post/6973564044351373326">卡顿、ANR、死锁，线上如何监控？</a></li><li><a href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
      <tag>ANR</tag>
      
      <tag>Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（五）——Activity生命周期分析</title>
    <link href="/2021/07/15/e90b373e/"/>
    <url>/2021/07/15/e90b373e/</url>
    
    <content type="html"><![CDATA[<p>在系列<a href="/2021/05/22/4cb0a496/#ActivityThread-performLaunchActivity">第二篇文章</a>中我们知道了Activity的整个启动流程，知道Activity是在App接收到启动Activity请求时通过反射的方式创建，在创建之后紧接着就会回调其生命周期。</p><p>本篇文章将会从Activity#attach开始，分析Activity在各个生命周期阶段的主要工作。</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>通过<a href="/2021/05/22/4cb0a496/#ActivityThread-performLaunchActivity">之前的文章</a>，Activity的创建由ActivityThread的performLaunchActivity来完成，在创建完成后首先会调用其attach方法将一些数据与Activity进行绑定，来看看attach方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,</span></span><br><span class="hljs-function"><span class="hljs-params">        Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,</span></span><br><span class="hljs-function"><span class="hljs-params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="hljs-function"><span class="hljs-params">        CharSequence title, Activity parent, String id,</span></span><br><span class="hljs-function"><span class="hljs-params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;<br>    attachBaseContext(context);<br><br>    <span class="hljs-comment">// 为FragmentManager绑定Controller</span><br>    mFragments.attachHost(<span class="hljs-keyword">null</span> <span class="hljs-comment">/*parent*/</span>);<br><br>    <span class="hljs-comment">// 创建Window，并初始化</span><br>    mWindow = <span class="hljs-keyword">new</span> PhoneWindow(<span class="hljs-keyword">this</span>, window, activityConfigCallback);<br>    mWindow.setWindowControllerCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.setCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.setOnWindowDismissedCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;<br>        mWindow.setSoftInputMode(info.softInputMode);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (info.uiOptions != <span class="hljs-number">0</span>) &#123;<br>        mWindow.setUiOptions(info.uiOptions);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 初始化一些变量</span><br>    mUiThread = Thread.currentThread();<br>    mMainThread = aThread;<br>    mInstrumentation = instr;<br>    mToken = token;<br>    mAssistToken = assistToken;<br>    mIdent = ident;<br>    mApplication = application;<br>    mIntent = intent;<br>    mReferrer = referrer;<br>    mComponent = intent.getComponent();<br>    mActivityInfo = info;<br>    mTitle = title;<br>    mParent = parent;<br>    mEmbeddedID = id;<br>    mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 为Window绑定WindowManager</span><br>    mWindow.setWindowManager(<br>            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),<br>            mToken, mComponent.flattenToString(),<br>            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>);<br>  <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>attach方法为Activity注入外部环境的一些对象，其中为Activity创建了Window。</p><h2 id="Create阶段"><a href="#Create阶段" class="headerlink" title="Create阶段"></a>Create阶段</h2><p>执行完attach方法后，ActivityThread将会调用Instrumentation中的callActivityOnCreate方法来开启Activity的Create阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mInstrumentation.callActivityOnCreate(activity, r.state);<br></code></pre></td></tr></table></figure><p>这里会分为三个步骤：</p><ul><li>prePerformCreate：执行在Activity#onCreate之前，完成一些预处理</li><li>performCreate：回调Activity#onCreate方法</li><li>postPerformCreate：执行在Activity#onCreate之后，完成一些收尾工作</li></ul><h3 id="Instrumentation-prePerformCreate"><a href="#Instrumentation-prePerformCreate" class="headerlink" title="Instrumentation#prePerformCreate"></a>Instrumentation#prePerformCreate</h3><p>此方法用于将同步启动的Activity从列表mWaitingActivities中移除。</p><p>同步启动是指使用<code>Instrumentation#startActivitySync</code>方法启动的Activity，使用此方法启动Activity会同步执行到Activity成功运行才会返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prePerformCreate</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mWaitingActivities != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mWaitingActivities.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                <span class="hljs-keyword">final</span> ActivityWaiter aw = mWaitingActivities.get(i);<br>                <span class="hljs-keyword">final</span> Intent intent = aw.intent;<br>                <span class="hljs-keyword">if</span> (intent.filterEquals(activity.getIntent())) &#123;<br>                    aw.activity = activity;<br>                    mMessageQueue.addIdleHandler(<span class="hljs-keyword">new</span> ActivityGoing(aw));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，所谓的“Activity成功运行”其实就是在create阶段中，不过这里并不会确保在prePerformCreate执行后就立即解除阻塞状态，因为这里用的是IdleHandler。</p><h3 id="Activity-performCreate"><a href="#Activity-performCreate" class="headerlink" title="Activity#performCreate"></a>Activity#performCreate</h3><p>此部分将会真正回调Activity的onCreate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle)</span> </span>&#123;<br>    performCreate(icicle, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;<br>    <span class="hljs-comment">// 分发preCreated事件</span><br>    dispatchActivityPreCreated(icicle);<br>    mCanEnterPictureInPicture = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 恢复权限相关标志变量</span><br>    restoreHasCurrentPermissionRequest(icicle);<br>    <span class="hljs-comment">// 回调onCreate</span><br>    <span class="hljs-keyword">if</span> (persistentState != <span class="hljs-keyword">null</span>) &#123;<br>        onCreate(icicle, persistentState);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        onCreate(icicle);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 恢复转场动画相关</span><br>    mActivityTransitionState.readState(icicle);<br><br>    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(<br>            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="hljs-keyword">false</span>);<br>  <br>    <span class="hljs-comment">// 通知fragment分发create事件</span><br>    mFragments.dispatchActivityCreated();<br>    mActivityTransitionState.setEnterActivityOptions(<span class="hljs-keyword">this</span>, getActivityOptions());<br>    <span class="hljs-comment">// 分发postCreated事件</span><br>    dispatchActivityPostCreated(icicle);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里除了回调Activity的onCreate生命周期回调外，还会通知FragmentManager分发onActivityCreated事件，以及调用ActivityLifecycleCallback中的切面方法。</p><h4 id="Activity-onCreate"><a href="#Activity-onCreate" class="headerlink" title="Activity#onCreate"></a>Activity#onCreate</h4><p>onCreate方法中主要是对于异常重启的Activity恢复一些数据，然后调用dispatchActivityCreated来回调所有ActivityLifecycleCallback。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mLastNonConfigurationInstances != <span class="hljs-keyword">null</span>) &#123;<br>        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActivityInfo.parentActivityName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mActionBar == <span class="hljs-keyword">null</span>) &#123;<br>            mEnableDefaultActionBarUp = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mActionBar.setDefaultDisplayHomeAsUpEnabled(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, <span class="hljs-keyword">false</span>);<br>        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,<br>                View.LAST_APP_AUTOFILL_ID);<br><br>        <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>            getAutofillManager().onCreate(savedInstanceState);<br>        &#125;<br><br>        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<br>        mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="hljs-keyword">null</span><br>                ? mLastNonConfigurationInstances.fragments : <span class="hljs-keyword">null</span>);<br>    &#125;<br>    mFragments.dispatchCreate();<br>    dispatchActivityCreated(savedInstanceState);<br>    <span class="hljs-keyword">if</span> (mVoiceInteractor != <span class="hljs-keyword">null</span>) &#123;<br>        mVoiceInteractor.attachActivity(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    mRestoredFromBundle = savedInstanceState != <span class="hljs-keyword">null</span>;<br>    mCalled = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Instrumentation-postPerformCreate"><a href="#Instrumentation-postPerformCreate" class="headerlink" title="Instrumentation#postPerformCreate"></a>Instrumentation#postPerformCreate</h3><p>此方法是<code>Instrumentation.postPerformCreate</code>所做工作是一致的，主要是保证Activity从列表mWaitingActivities中移除。</p><h2 id="Start阶段"><a href="#Start阶段" class="headerlink" title="Start阶段"></a>Start阶段</h2><p>执行完ActivityThread中的performLaunchActivity方法之后，Activity就已经被成功启动，不过此时Activity还处于<code>ON_CREATE</code>状态，而我们是希望此Activity的目标状态（Target State）是<code>ON_RESUME</code>，那么我们还需要顺序的执行Activity的生命周期回调onStart和onResume。</p><p>执行完LaunchActivity这个事务后，TransactionExecutor会帮我们平滑的将Activity的生命周期执行到Target State。主要是在cycleToPath方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleToPath</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">boolean</span> excludeLastState,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前生命周期，ON_CREATE</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = r.getLifecycleState();<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) &#123;<br>        Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Cycle activity: &quot;</span><br>                + getShortActivityName(r.token, mTransactionHandler)<br>                + <span class="hljs-string">&quot; from: &quot;</span> + getStateName(start) + <span class="hljs-string">&quot; to: &quot;</span> + getStateName(finish)<br>                + <span class="hljs-string">&quot; excludeLastState: &quot;</span> + excludeLastState);<br>    &#125;<br>  <br>    <span class="hljs-comment">// finish表示Target State，本次流程为ON_RESUME</span><br>    <span class="hljs-keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);<br>    performLifecycleSequence(r, path, transaction);<br>&#125;<br></code></pre></td></tr></table></figure><p>cycleToPath计算了我们的起始阶段和终止阶段，并且调用了TransactionExecutorHelper中的getLifecyclePath得到了一个IntArray path，并将path传递给了performLifecycleSequence方法，此IntArray中存储了需要顺序执行的生命周期。</p><p>performLifecycleSequence方法负责根据path来调用ClientTransactionHandler中的具体方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLifecycleSequence</span><span class="hljs-params">(ActivityClientRecord r, IntArray path,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = path.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, state; i &lt; size; i++) &#123;<br>        state = path.get(i);<br>        <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) &#123;<br>            Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Transitioning activity: &quot;</span><br>                    + getShortActivityName(r.token, mTransactionHandler)<br>                    + <span class="hljs-string">&quot; to state: &quot;</span> + getStateName(state));<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>            <span class="hljs-keyword">case</span> ON_CREATE:<br>                mTransactionHandler.handleLaunchActivity(r, mPendingActions,<br>                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_START:<br>                mTransactionHandler.handleStartActivity(r, mPendingActions);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESUME:<br>                mTransactionHandler.handleResumeActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        r.isForward, <span class="hljs-string">&quot;LIFECYCLER_RESUME_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_PAUSE:<br>                mTransactionHandler.handlePauseActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finished */</span>,<br>                        <span class="hljs-keyword">false</span> <span class="hljs-comment">/* userLeaving */</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, mPendingActions,<br>                        <span class="hljs-string">&quot;LIFECYCLER_PAUSE_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_STOP:<br>                mTransactionHandler.handleStopActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* show */</span>,<br>                        <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, mPendingActions, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        <span class="hljs-string">&quot;LIFECYCLER_STOP_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_DESTROY:<br>                mTransactionHandler.handleDestroyActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finishing */</span>,<br>                        <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* getNonConfigInstance */</span>,<br>                        <span class="hljs-string">&quot;performLifecycleSequence. cycling to:&quot;</span> + path.get(size - <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESTART:<br>                mTransactionHandler.performRestartActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* start */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unexpected lifecycle state: &quot;</span> + state);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，就是根据path中的值来调用ClientTransactionHandler中的对应方法。</p><p>本次流程中，目前Activity的状态是<code>ON_START</code>，那么将会调用ClientTransactionHandler中的handleStartActivity方法。</p><p>前面文章已经说过，ClientTransactionHandler的实现类就是ActivityThread，我们来看方法的源码。</p><h3 id="ActivityThread-handleStartActivity"><a href="#ActivityThread-handleStartActivity" class="headerlink" title="ActivityThread#handleStartActivity"></a>ActivityThread#handleStartActivity</h3><p>与handleLaunchActivity方法类似，handleStartActivity用于处理Activity的<code>ON_START</code>生命周期，其中就会回调Activity的onStart方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStartActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Activity activity = r.activity;<br>    <span class="hljs-keyword">if</span> (r.activity == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Can&#x27;t start activity that is not stopped.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r.activity.mFinished) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// activity的start生命周期工作</span><br>    activity.performStart(<span class="hljs-string">&quot;handleStartActivity&quot;</span>);<br>    r.setState(ON_START);<br><br>    <span class="hljs-keyword">if</span> (pendingActions == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理Activity的重启恢复数据</span><br>    <span class="hljs-comment">// 调用onRestoreInstanceState恢复数据</span><br>    <span class="hljs-keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;<br>        <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>            <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span> || r.persistentState != <span class="hljs-keyword">null</span>) &#123;<br>                <br>                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,<br>                        r.persistentState);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用Activity.onPostCreate()方法</span><br>    <span class="hljs-keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;<br>        activity.mCalled = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>            mInstrumentation.callActivityOnPostCreate(activity, r.state,<br>                    r.persistentState);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mInstrumentation.callActivityOnPostCreate(activity, r.state);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!activity.mCalled) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>                    <span class="hljs-string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot; did not call through to super.onPostCreate()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到此阶段除了要执行Activity的performStart方法处理<code>ON_START</code>状态之外，还会考虑是否要调用onRestoreInstanceState来恢复数据，之后会调用Activity的onPostCreate方法，此方法我们通常不会去重写它，主要是通知系统相关类来完成初始化。</p><h3 id="Activity-performStart"><a href="#Activity-performStart" class="headerlink" title="Activity#performStart"></a>Activity#performStart</h3><p>performStart方法与performCreate方法类似，主要是分发preStart事件、调用onStart、分发postStart事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStart</span><span class="hljs-params">(String reason)</span> </span>&#123;<br>    dispatchActivityPreStarted();<br>    mActivityTransitionState.setEnterActivityOptions(<span class="hljs-keyword">this</span>, getActivityOptions());<br>    mFragments.noteStateNotSaved();<br>    mCalled = <span class="hljs-keyword">false</span>;<br>    mFragments.execPendingActions();<br>    <span class="hljs-comment">// 调用onStart回调</span><br>    mInstrumentation.callActivityOnStart(<span class="hljs-keyword">this</span>);<br>    writeEventLog(LOG_AM_ON_START_CALLED, reason);<br><br>    <span class="hljs-keyword">if</span> (!mCalled) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>            <span class="hljs-string">&quot;Activity &quot;</span> + mComponent.toShortString() +<br>            <span class="hljs-string">&quot; did not call through to super.onStart()&quot;</span>);<br>    &#125;<br>    mFragments.dispatchStart();<br>    mFragments.reportLoaderStart();<br><br>    <span class="hljs-keyword">boolean</span> isAppDebuggable =<br>            (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// This property is set for all non-user builds except final release</span><br>    <span class="hljs-keyword">boolean</span> isDlwarningEnabled = SystemProperties.getInt(<span class="hljs-string">&quot;ro.bionic.ld.warning&quot;</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-comment">// 对于Debug包会弹出一个Debuggable的提示</span><br>    <span class="hljs-keyword">if</span> (isAppDebuggable || isDlwarningEnabled) &#123;<br>        String dlwarning = getDlWarning();<br>        <span class="hljs-keyword">if</span> (dlwarning != <span class="hljs-keyword">null</span>) &#123;<br>            String appName = getApplicationInfo().loadLabel(getPackageManager())<br>                    .toString();<br>            String warning = <span class="hljs-string">&quot;Detected problems with app native libraries\n&quot;</span> +<br>                             <span class="hljs-string">&quot;(please consult log for detail):\n&quot;</span> + dlwarning;<br>            <span class="hljs-keyword">if</span> (isAppDebuggable) &#123;<br>                  <span class="hljs-keyword">new</span> AlertDialog.Builder(<span class="hljs-keyword">this</span>).<br>                      setTitle(appName).<br>                      setMessage(warning).<br>                      setPositiveButton(android.R.string.ok, <span class="hljs-keyword">null</span>).<br>                      setCancelable(<span class="hljs-keyword">false</span>).<br>                      show();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Toast.makeText(<span class="hljs-keyword">this</span>, appName + <span class="hljs-string">&quot;\n&quot;</span> + warning, Toast.LENGTH_LONG).show();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(<span class="hljs-keyword">this</span>);<br><br>    mActivityTransitionState.enterReady(<span class="hljs-keyword">this</span>);<br>    dispatchActivityPostStarted();<br>&#125;<br></code></pre></td></tr></table></figure><p>Activity的onStart回调通过Instrumentation来执行，来看看onStart源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;onStart &quot;</span> + <span class="hljs-keyword">this</span>);<br>    mCalled = <span class="hljs-keyword">true</span>;<br>  <br>    <span class="hljs-comment">// 执行Loader的start方法</span><br>    mFragments.doLoaderStart();<br><br>    <span class="hljs-comment">// 分发start事件</span><br>    dispatchActivityStarted();<br><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        getAutofillManager().onVisibleForAutofill();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Resume阶段"><a href="#Resume阶段" class="headerlink" title="Resume阶段"></a>Resume阶段</h2><p>由于我们的Activity目标状态为<code>ON_RESUME</code>，因此执行完handleStartActivity方法后，将会继续执行handleResumeActivity方法。</p><h3 id="ActivityThread-handleResumeActivity"><a href="#ActivityThread-handleResumeActivity" class="headerlink" title="ActivityThread#handleResumeActivity"></a>ActivityThread#handleResumeActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span><br><span class="hljs-function"><span class="hljs-params">        String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// 在后台时可能发送了gcIdler，这里取消掉</span><br>    unscheduleGcIdler();<br>  <br>    <span class="hljs-comment">// 这个值在之前gcWatch里面有用到，为true时会才会考虑回收Activity</span><br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 处理生命周期到onResume</span><br>    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActivitiesToBeDestroyed.containsKey(token)) &#123;<br>        <span class="hljs-comment">// 对于马上要destroy的Activity，后续操作已经无意义</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Activity a = r.activity;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> forwardBit = isForward<br>            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 在调用startActivity后mStartedActivity会置为true</span><br>    <span class="hljs-comment">// 当我们在resume之前调用了startActivity，那么此Activity不应该显示</span><br>    <span class="hljs-comment">// 而是应该显示最新启动的Activity</span><br>    <span class="hljs-keyword">boolean</span> willBeVisible = !a.mStartedActivity;<br>    <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 跟ATMS再确认一次</span><br>            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(<br>                    a.getActivityToken());<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// window还未被添加到WindowManager同时Activity是需要显示的</span><br>    <span class="hljs-keyword">if</span> (r.window == <span class="hljs-keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;<br>        r.window = r.activity.getWindow();<br>        View decor = r.window.getDecorView();<br>        decor.setVisibility(View.INVISIBLE);<br>        ViewManager wm = a.getWindowManager();<br>        WindowManager.LayoutParams l = r.window.getAttributes();<br>        a.mDecor = decor;<br>        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;<br>        l.softInputMode |= forwardBit;<br>        <span class="hljs-keyword">if</span> (r.mPreserveWindow) &#123;<br>            a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>            r.mPreserveWindow = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 对于复用decorView，通知ViewRoot</span><br>            ViewRootImpl impl = decor.getViewRootImpl();<br>            <span class="hljs-keyword">if</span> (impl != <span class="hljs-keyword">null</span>) &#123;<br>                impl.notifyChildRebuilt();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;<br>            <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<br>                a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 将decorView添加到WindowManager</span><br>                wm.addView(decor, l);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a.onWindowAttributesChanged(l);<br>            &#125;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Launch &quot;</span> + r + <span class="hljs-string">&quot; mStartedActivity set&quot;</span>);<br>        r.hideForNow = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Get rid of anything left hanging around.</span><br>    cleanUpPendingRemoveWindows(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* force */</span>);<br><br>    <span class="hljs-comment">// 当前window确定是要显示的</span><br>    <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="hljs-keyword">null</span> &amp;&amp; !r.hideForNow) &#123;<br>        <span class="hljs-keyword">if</span> (r.newConfig != <span class="hljs-keyword">null</span>) &#123;<br>          <br>            <span class="hljs-comment">// onConfigurationChanged方法在此处被调用</span><br>            performConfigurationChangedForActivity(r, r.newConfig);<br>            r.newConfig = <span class="hljs-keyword">null</span>;<br>        &#125;<br>   <br>        WindowManager.LayoutParams l = r.window.getAttributes();<br>        <span class="hljs-keyword">if</span> ((l.softInputMode<br>                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)<br>                != forwardBit) &#123;<br>            l.softInputMode = (l.softInputMode<br>                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))<br>                    | forwardBit;<br>            <span class="hljs-keyword">if</span> (r.activity.mVisibleFromClient) &#123;<br>                ViewManager wm = a.getWindowManager();<br>                View decor = r.window.getDecorView();<br>                <br>                <span class="hljs-comment">// 更新DecorView的LayoutParams</span><br>                wm.updateViewLayout(decor, l);<br>            &#125;<br>        &#125;<br>      <br>      ···<br>&#125;<br></code></pre></td></tr></table></figure><p>handleResumeActivity方法会判断此Activity的Window是否已经添加到WindowManager中，以及是否是真正需要显示的。如果是要显示的并且还未添加，那么将会调用WindowManager的addView方法来讲将decor添加到WindowManager中，这是Resume阶段的关键方法，来看一下。</p><h4 id="WindowManagerImpl-addView"><a href="#WindowManagerImpl-addView" class="headerlink" title="WindowManagerImpl#addView"></a>WindowManagerImpl#addView</h4><p>WindowManager是一个接口，其实现类为WindowManagerImpl，来看看addView方法源码。</p><blockquote><p>frameworks/base/core/java/android/view/WindowManagerImpl.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;<br>    applyDefaultToken(params);<br>    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);<br>&#125;<br></code></pre></td></tr></table></figure><p>此处调用了两个方法，applyDefaultToken方法中会检测传入的LayoutParams必须为WindowManager.LayoutParams，否则会直接抛异常。另外如果当前Window没有父Window，这意味这它的token有可能为null，此时会将其赋值为默认的token。</p><p>接下来调用了WindowManagerGlobal中的addView方法。</p><h4 id="WindowManagerGlobal-addView"><a href="#WindowManagerGlobal-addView" class="headerlink" title="WindowManagerGlobal#addView"></a>WindowManagerGlobal#addView</h4><p>WindowManagerGlobal是一个全局的单例对象，其代理了WindowManagerImpl中的一些与上下文Context无关的方法，负责具体的WindowManager操作。</p><p>WindowManagerGlobal内部维护了此WindowManager管理的所有View、ViewRoot和它们的LayoutParams，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="hljs-keyword">new</span> ArrayList&lt;View&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="hljs-keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =<br>        <span class="hljs-keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();<br></code></pre></td></tr></table></figure><p>简单的介绍了WindowManagerGlobal之后，继续来看addView的源码：</p><blockquote><p>frameworks/base/core/java/android/view/WindowManagerGlobal.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="hljs-function"><span class="hljs-params">        Display display, Window parentWindow)</span> </span>&#123;<br>  <br>    ···<br><br>    ViewRootImpl root;<br>    View panelParentView = <span class="hljs-keyword">null</span>;<br>  <br>    ···<br><br>        <span class="hljs-comment">// 对于一个PanelWindow，需要找到它的父Window对应的View</span><br>        <span class="hljs-keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;<br>                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mViews.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                <span class="hljs-keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;<br>                    panelParentView = mViews.get(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>  <br>        <span class="hljs-comment">// 对于每一个Window 都有一个ViewRoomtImpl与之对应</span><br>        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);<br><br>        view.setLayoutParams(wparams);<br><br>        mViews.add(view);<br>        mRoots.add(root);<br>        mParams.add(wparams);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            root.setView(view, wparams, panelParentView);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            <span class="hljs-comment">// 有可能会抛出熟知的BadTokenException异常</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                removeViewLocked(index, <span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法中创建了一个ViewRoomImpl，并且调用了ViewRoomImpl中的setView方法将当前view设置进去。</p><h4 id="ViewRootImpl-setView"><a href="#ViewRootImpl-setView" class="headerlink" title="ViewRootImpl#setView"></a>ViewRootImpl#setView</h4><p>ViewRootImpl的setView方法代码比较多，我们只需要关注关键信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mView == <span class="hljs-keyword">null</span>) &#123;<br>            mView = view;<br>            <br>            ···<br>              <br>            <span class="hljs-keyword">int</span> res; <span class="hljs-comment">/* = WindowManagerImpl.ADD_OKAY; */</span><br><br>            requestLayout();<br>          <br>            mForceDecorViewVisibility = (mWindowAttributes.privateFlags<br>                    &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mOrigWindowType = mWindowAttributes.type;<br>                mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;<br>                collectViewAttributes();<br>              <br>                <span class="hljs-comment">// 将Window与WindowManagerService绑定</span><br>                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                        getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,<br>                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,<br>                        mTempInsets);<br>                setFrame(mTmpFrame);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                mAdded = <span class="hljs-keyword">false</span>;<br>                mView = <span class="hljs-keyword">null</span>;<br>                mAttachInfo.mRootView = <span class="hljs-keyword">null</span>;<br>                mInputChannel = <span class="hljs-keyword">null</span>;<br>                mFallbackEventHandler.setView(<span class="hljs-keyword">null</span>);<br>                unscheduleTraversals();<br>                setAccessibilityFocus(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Adding window failed&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (restore) &#123;<br>                    attrs.restore();<br>                &#125;<br>            &#125;<br>          <br>            ···<br>              <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到方法中调用了requestLayout方法，而我们知道requestLayout方法最终会调用scheduleTraversals方法来发起整个View树的测量、布局与绘制工作。</p><p>View的绘制流程不是本文的重点，但这里我们获得了一个关键信息，就是Activity的Window显示过程，包括View树的绘制过程都是在Activity的<code>ON_RESUME</code>阶段来完成。</p><p>另外，调用了WindowSession中的addToDisplay方法，将Window与<strong>WindowManagerService</strong>绑定。</p><p>这就是为什么我们在onCreate、onStart和onResume中都无法同步到获取View的宽高。</p><h2 id="Pause阶段"><a href="#Pause阶段" class="headerlink" title="Pause阶段"></a>Pause阶段</h2><p>继续来看Pause阶段，根据经验我们直接来到ActivityThread中的handlePauseActivity方法。</p><h3 id="ActivityThread-handlePauseActivity"><a href="#ActivityThread-handlePauseActivity" class="headerlink" title="ActivityThread#handlePauseActivity"></a>ActivityThread#handlePauseActivity</h3><p>handlePauseActivity方法表示自此Pause事件是由于用户导致，例如按下back键、home键、点击跳转Activity等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlePauseActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finished, <span class="hljs-keyword">boolean</span> userLeaving,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (userLeaving) &#123;<br>            performUserLeavingActivity(r);<br>        &#125;<br><br>        r.activity.mConfigChangeFlags |= configChanges;<br>        performPauseActivity(r, finished, reason, pendingActions);<br><br>        <span class="hljs-comment">// Make sure any pending writes are now committed.</span><br>        <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;<br>            QueuedWork.waitToFinish();<br>        &#125;<br>        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>performUserLeavingActivity中将会调用Activity中的<strong>onUserInteraction</strong>和<strong>onUserLeaveHint</strong>方法。</p><h3 id="ActivityThread-performPauseActivity"><a href="#ActivityThread-performPauseActivity" class="headerlink" title="ActivityThread#performPauseActivity"></a>ActivityThread#performPauseActivity</h3><p>performPauseActivity方法中是会调用Activity的生命周期回调onPause方法，除了onPause方法，还有一些关键的方法也会在这里调用，例如onSaveInstanceState方法，来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Bundle <span class="hljs-title">performPauseActivity</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> finished, String reason,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// targetSDK &lt; 11的App在pause前就会调用onSaveInstanceState</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();<br>    <span class="hljs-keyword">if</span> (shouldSaveState) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br><br>  <span class="hljs-comment">// 回调生命周期方法 onPause</span><br>    performPauseActivityIfNeeded(r, reason);<br><br>    ···<br>      <br>    <span class="hljs-keyword">return</span> shouldSaveState ? r.state : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ActivityThread-performPauseActivityIfNeeded"><a href="#ActivityThread-performPauseActivityIfNeeded" class="headerlink" title="ActivityThread#performPauseActivityIfNeeded"></a>ActivityThread#performPauseActivityIfNeeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performPauseActivityIfNeeded</span><span class="hljs-params">(ActivityClientRecord r, String reason)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">try</span> &#123;<br>        r.activity.mCalled = <span class="hljs-keyword">false</span>;<br>      <br>      <span class="hljs-comment">// 回调onPause</span><br>        mInstrumentation.callActivityOnPause(r.activity);<br>        <br>        ···<br>    &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to pause activity &quot;</span><br>                    + safeToComponentShortString(r.intent) + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置Lifecycle</span><br>    r.setState(ON_PAUSE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Activity-performPause"><a href="#Activity-performPause" class="headerlink" title="Activity#performPause"></a>Activity#performPause</h3><p>此方法与之前生命周期的工作类似，主要就是分发prePause、onPause和postPause事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分发prePause</span><br>    dispatchActivityPrePaused();<br>    mDoReportFullyDrawn = <span class="hljs-keyword">false</span>;<br>    mFragments.dispatchPause();<br>    mCalled = <span class="hljs-keyword">false</span>;<br>  <br>    <span class="hljs-comment">// 回调生命周期方法</span><br>    onPause();<br>  <br>    mResumed = <span class="hljs-keyword">false</span>;<br><br>  ···<br>     <br>    <span class="hljs-comment">// 分发postPause</span><br>    dispatchActivityPostPaused();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Activity-onPause"><a href="#Activity-onPause" class="headerlink" title="Activity#onPause"></a>Activity#onPause</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分发pause</span><br>    dispatchActivityPaused();<br>  <br>    <span class="hljs-comment">// 是否需要自动填充</span><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        <span class="hljs-keyword">if</span> (!mAutoFillIgnoreFirstResumePause) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;autofill notifyViewExited &quot;</span> + <span class="hljs-keyword">this</span>);<br>            View focus = getCurrentFocus();<br>            <span class="hljs-keyword">if</span> (focus != <span class="hljs-keyword">null</span> &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;<br>                getAutofillManager().notifyViewExited(focus);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// reset after first pause()</span><br>            <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;autofill got first pause &quot;</span> + <span class="hljs-keyword">this</span>);<br>            mAutoFillIgnoreFirstResumePause = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE);<br>    mCalled = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stop阶段"><a href="#Stop阶段" class="headerlink" title="Stop阶段"></a>Stop阶段</h2><p>同样的，Stop阶段与前面的生命周期方法调用链是类似的。</p><h3 id="ActivityThread-handleStopActivity"><a href="#ActivityThread-handleStopActivity" class="headerlink" title="ActivityThread#handleStopActivity"></a>ActivityThread#handleStopActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStopActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ActivityClientRecord r = mActivities.get(token);<br>    r.activity.mConfigChangeFlags |= configChanges;<br><br>    <span class="hljs-keyword">final</span> StopInfo stopInfo = <span class="hljs-keyword">new</span> StopInfo();<br>    performStopActivityInner(r, stopInfo, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, finalStateRequest,<br>            reason);<br><br>    <span class="hljs-comment">// 更新Activity的显隐状态</span><br>    updateVisibility(r, <span class="hljs-keyword">false</span>);<br><br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p><code>handleStopActivity</code>方法调用了<code>performStopActivityInner</code>来处理Activity的Stop状态，并且在Stop之后隐藏了Activity的DecorView的显示。</p><h3 id="ActivityThread-performStopActivityInner"><a href="#ActivityThread-performStopActivityInner" class="headerlink" title="ActivityThread#performStopActivityInner"></a>ActivityThread#performStopActivityInner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStopActivityInner</span><span class="hljs-params">(ActivityClientRecord r, StopInfo info, <span class="hljs-keyword">boolean</span> keepShown,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> saveState, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>  <br>    ···<br><br>        <span class="hljs-comment">// 保证Activity是处于Pause状态</span><br>        performPauseActivityIfNeeded(r, reason);<br><br>        ···<br><br>        <span class="hljs-keyword">if</span> (!keepShown) &#123;<br>            <span class="hljs-comment">// 回调Activiy的onStop方法</span><br>            callActivityOnStop(r, saveState, reason);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>performPauseActivityIfNeeded</code>中上一节已经有调用过，是为了确保Activity调用了onPause，如果已经处于pause状态将会直接返回。</p><p>来看一下<code>callActivityOnStop</code>方法。</p><h3 id="ActivityThread-callActivityOnStop"><a href="#ActivityThread-callActivityOnStop" class="headerlink" title="ActivityThread#callActivityOnStop"></a>ActivityThread#callActivityOnStop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnStop</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> saveState, String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// 在Android Honeycomb（11）之前，onSaveInstanceState都是在onPause之前执行</span><br>    <span class="hljs-comment">// 在Android P（28）之前，onSaveInstanceState在onStop方法执行之前执行</span><br>    <span class="hljs-comment">// 在Android P之后（包含），onSaveInstanceState在onStop方法执行之后执行 </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="hljs-keyword">null</span><br>            &amp;&amp; !r.isPreHoneycomb();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPreP = r.isPreP();<br>    <span class="hljs-keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用onStop</span><br>        r.activity.performStop(r.mPreserveWindow, reason);<br>    &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">&quot;Unable to stop activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    r.setState(ON_STOP);<br><br>    <span class="hljs-keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个关键信息，就是<code>onSaveInstanceState</code>方法的调用时机。</p><p>之前在分析Pause阶段时，我们知道在<strong>Android</strong> <strong>Honeycomb</strong>以前<code>onSaveInstanceState</code>会在onPause方法调用之前回调，而在<code>callActivityOnStop</code>中进一步对<code>onSaveInstanceState</code>的调用时机做出了解释，总结如下：</p><ol><li>在Android Honeycomb之前，onSaveInstanceState在onPause调用之前被调用</li><li>在Android Honeycomb之后，Android P之前，onSaveInstanceState在onStop调用之前被调用</li><li>在Android P之后，onSaveInstanceState在onStop调用之后被调用</li></ol><p>performStop方法中会回调生命周期onStop方法，来看看。</p><h3 id="Activity-performStop"><a href="#Activity-performStop" class="headerlink" title="Activity#performStop"></a>Activity#performStop</h3><p>此方法中同样会进行preStop、stop和postStop的事件分发，并且使用Instrumentation来回调onStop方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStop</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> preserveWindow, String reason)</span> </span>&#123;<br>    <br>  ···<br>  <br>    <span class="hljs-keyword">if</span> (!mStopped) &#123;<br>        <br>        ···<br>          <br>        dispatchActivityPreStopped();<br>        <span class="hljs-keyword">if</span> (mWindow != <span class="hljs-keyword">null</span>) &#123;<br>            mWindow.closeAllPanels();<br>        &#125;<br>      <br>        ···<br>          <br>        mFragments.dispatchStop();<br><br>        mCalled = <span class="hljs-keyword">false</span>;<br>        mInstrumentation.callActivityOnStop(<span class="hljs-keyword">this</span>);<br><br>        ···<br>        <br>        mStopped = <span class="hljs-keyword">true</span>;<br>        dispatchActivityPostStopped();<br>    &#125;<br>    mResumed = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Activity-onStop"><a href="#Activity-onStop" class="headerlink" title="Activity#onStop"></a>Activity#onStop</h3><p>onStop方法中需要停止UI的刷新，停止运行中的动画，以及隐藏自动填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mActionBar != <span class="hljs-keyword">null</span>) mActionBar.setShowHideAnimationEnabled(<span class="hljs-keyword">false</span>);<br>    mActivityTransitionState.onStop();<br>    dispatchActivityStopped();<br>    mTranslucentCallback = <span class="hljs-keyword">null</span>;<br>    mCalled = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        getAutofillManager().onInvisibleForAutofill();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isFinishing()) &#123;<br>        <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>            getAutofillManager().onActivityFinishing();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mIntent != <span class="hljs-keyword">null</span><br>                &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123;<br>            getAutofillManager().onPendingSaveUi(AutofillManager.PENDING_UI_OPERATION_CANCEL,<br>                    mIntent.getIBinderExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN));<br>        &#125;<br>    &#125;<br>    mEnterAnimationComplete = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Destroy阶段"><a href="#Destroy阶段" class="headerlink" title="Destroy阶段"></a>Destroy阶段</h2><p>Destroy阶段App除了要完成Activity本身的销毁逻辑外，还需要通知System Server来处理Activity栈相关的逻辑。</p><p>按照经验，我们来到ActivityThread的handleDestroyActivity方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>  <br>    <span class="hljs-comment">// 销毁Activity</span><br>    ActivityClientRecord r = performDestroyActivity(token, finishing,<br>            configChanges, getNonConfigInstance, reason);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 处理Window相关</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通知ATMS此Activity已经被销毁</span><br>            ActivityTaskManager.getService().activityDestroyed(token);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>            <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法首先调用了<code>performDestroyActivity</code>执行了本地的销毁逻辑，然后通知ATMS更新系统服务。</p><h3 id="ActivityThread-performDestroyActivity"><a href="#ActivityThread-performDestroyActivity" class="headerlink" title="ActivityThread#performDestroyActivity"></a>ActivityThread#performDestroyActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    Class&lt;? extends Activity&gt; activityClass = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Performing finish of &quot;</span> + r);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        activityClass = r.activity.getClass();<br>        r.activity.mConfigChangeFlags |= configChanges;<br>        <span class="hljs-keyword">if</span> (finishing) &#123;<br>            r.activity.mFinished = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 保证Activity调用了onPause</span><br>        performPauseActivityIfNeeded(r, <span class="hljs-string">&quot;destroy&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>            <span class="hljs-comment">// 保证Activity调用了onStop</span><br>            callActivityOnStop(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* saveState */</span>, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        &#125;<br>      <br>        ···<br>          <br>        <span class="hljs-keyword">try</span> &#123;<br>            r.activity.mCalled = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 调用onDestroy生命周期方法</span><br>            mInstrumentation.callActivityOnDestroy(r.activity);<br><br>            <span class="hljs-comment">// 关闭所有window</span><br>            <span class="hljs-keyword">if</span> (r.window != <span class="hljs-keyword">null</span>) &#123;<br>                r.window.closeAllPanels();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ···<br>            &#125;<br>        &#125;<br>        r.setState(ON_DESTROY);<br>    &#125;<br>    schedulePurgeIdler();<br><br>    <span class="hljs-comment">// 删除本地Activity对应数据结构</span><br>    <span class="hljs-keyword">synchronized</span> (mResourcesManager) &#123;<br>        mActivities.remove(token);<br>    &#125;<br>    StrictMode.decrementExpectedActivityCount(activityClass);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>Instrumentation.callActivityOnDestroy回调用Activity的performDestroy方法，与之前的生命周期类似，performDestroy方法主要是分发preDestroy、destroy和postDestroy事件，并且会调用onDestroy生命周期回调。</p><p>主要来看看onDestroy方法做了什么。</p><h3 id="Activity-onDestroy"><a href="#Activity-onDestroy" class="headerlink" title="Activity#onDestroy"></a>Activity#onDestroy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    mCalled = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 关闭所有的dialog</span><br>    <span class="hljs-comment">// 使用Activity.showDialog显示的Dialog都会存入到mManagedDialogs中</span><br>    <span class="hljs-keyword">if</span> (mManagedDialogs != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numDialogs = mManagedDialogs.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numDialogs; i++) &#123;<br>            <span class="hljs-keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);<br>            <span class="hljs-keyword">if</span> (md.mDialog.isShowing()) &#123;<br>                md.mDialog.dismiss();<br>            &#125;<br>        &#125;<br>        mManagedDialogs = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有的游标</span><br>    <span class="hljs-comment">// 使用startManagingCursor可以让Activity自动管理此游标避免泄漏</span><br>    <span class="hljs-keyword">synchronized</span> (mManagedCursors) &#123;<br>        <span class="hljs-keyword">int</span> numCursors = mManagedCursors.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCursors; i++) &#123;<br>            ManagedCursor c = mManagedCursors.get(i);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>                c.mCursor.close();<br>            &#125;<br>        &#125;<br>        mManagedCursors.clear();<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有的SearchDialog</span><br>    <span class="hljs-keyword">if</span> (mSearchManager != <span class="hljs-keyword">null</span>) &#123;<br>        mSearchManager.stopSearch();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mActionBar != <span class="hljs-keyword">null</span>) &#123;<br>        mActionBar.onDestroy();<br>    &#125;<br><br>    <span class="hljs-comment">// 分发Destroy事件</span><br>    dispatchActivityDestroyed();<br><br>    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);<br>&#125;<br></code></pre></td></tr></table></figure><p>onDestroy方法中主要是保证Activity销毁时已经关闭了所有的由此Activity管理的Dialog、Cursor和SearchDialog，可以避免一些内存泄漏。</p><h2 id="非生命周期关键方法分析"><a href="#非生命周期关键方法分析" class="headerlink" title="非生命周期关键方法分析"></a>非生命周期关键方法分析</h2><p>上面分析完了Activity的生命周期的相关源码， 我们平时开发中除了与Activity生命周期回调方法打交道之外，通常还会涉及到少数非生命周期方法，例如<strong>onSaveInstanceState/onRestoreInstanceState</strong>、<strong>onRetainNonConfigurationInstance</strong>等，下面就来分析一下这几个函数的原理。</p><h3 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h3><p>saveInstanceState中文翻译叫<strong>保存实例状态</strong>，它允许我们在Activity暂停或不可见时保存一些数据，然后通过onRestoreInstanceState来恢复这些数据，<strong>并且即使App被杀死，我们依然可以在onCreate方法中获取到保存的数据</strong>，这是如何做到的呢？</p><p>在上文的Stop阶段已经提到了<code>onSaveInstanceState</code>方法在<code>callActivityOnSaveInstanceState</code>中调用，并且对于不同的API版本调用时机是有区别的：</p><ol><li>在Android Honeycomb（11）之前，callActivityOnSaveInstanceState在<strong>onPause</strong>调用<strong>之前</strong>被调用</li><li>在Android Honeycomb（11）之后，Android P之前，callActivityOnSaveInstanceState在<strong>onStop</strong>调用<strong>之前</strong>被调用</li><li>在Android P之后，callActivityOnSaveInstanceState在<strong>onStop</strong>调用<strong>之后</strong>被调用</li></ol><p>下面来跟踪一下在Android Q中<code>callActivityOnSaveInstanceState</code>的调用流程。</p><h4 id="ActivityThread-callActivityOnSaveInstanceState"><a href="#ActivityThread-callActivityOnSaveInstanceState" class="headerlink" title="ActivityThread#callActivityOnSaveInstanceState"></a>ActivityThread#callActivityOnSaveInstanceState</h4><p><code>callActivityOnSaveInstanceState</code>方法定义在ActivityThread里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnSaveInstanceState</span><span class="hljs-params">(ActivityClientRecord r)</span> </span>&#123;<br>    r.state = <span class="hljs-keyword">new</span> Bundle();<br>    r.state.setAllowFds(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">// 是否设置了persistableMode为ActivityInfo.PERSIST_ACROSS_REBOOTS</span><br>    <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>        r.persistentState = <span class="hljs-keyword">new</span> PersistableBundle();<br>        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,<br>                r.persistentState);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里新建了一个Bundle对象，并且赋值给了<strong>ActivityClientRecord</strong>的state属性，接着调用了Instrumentation中的<code>callActivityOnSaveInstanceState</code>方法。</p><p><code>Instrumentation.callActivityOnSaveInstanceState</code>将会直接调用activity的<code>performSaveInstanceState</code>方法，我们直接来到Activity中。</p><h4 id="Activity-performSaveInstanceState"><a href="#Activity-performSaveInstanceState" class="headerlink" title="Activity#performSaveInstanceState"></a>Activity#performSaveInstanceState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState)</span> </span>&#123;<br>    dispatchActivityPreSaveInstanceState(outState);<br>    onSaveInstanceState(outState);<br>    <span class="hljs-comment">// 调用此Activity管理的Dialog的onSaveInstanceState方法</span><br>    saveManagedDialogs(outState);<br>    mActivityTransitionState.saveState(outState);<br>    storeHasCurrentPermissionRequest(outState);<br>    <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;onSaveInstanceState &quot;</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;: &quot;</span> + outState);<br>    dispatchActivityPostSaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>onSaveInstanceState</code>是在这里被调用的，重点也是这个方法。除此之外这里调用了<code>saveManagedDialogs</code>来调用此Activity管理的所有Dialog的<code>onSaveInstanceState</code>来保存数据。</p><p>继续来看<code>onSaveInstanceState</code>方法。</p><h4 id="Activity-onSaveInstanceState"><a href="#Activity-onSaveInstanceState" class="headerlink" title="Activity#onSaveInstanceState"></a>Activity#onSaveInstanceState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState)</span> </span>&#123;<br>    <span class="hljs-comment">// 存储视图状态</span><br>    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());<br><br>    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);<br>    <span class="hljs-comment">// 存储Fragment信息</span><br>    Parcelable p = mFragments.saveAllState();<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>        outState.putParcelable(FRAGMENTS_TAG, p);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="hljs-keyword">true</span>);<br>        getAutofillManager().onSaveInstanceState(outState);<br>    &#125;<br>    dispatchActivitySaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法中调用了Window中的<code>saveHierarchyState</code>来保存所有视图的状态，另外调用了FragmentController的<code>saveAllState</code>方法来保存所有活动的Fragment信息。</p><p>分析一下这两个方法。</p><h4 id="PhoneWindow-saveHierarchyState"><a href="#PhoneWindow-saveHierarchyState" class="headerlink" title="PhoneWindow#saveHierarchyState"></a>PhoneWindow#saveHierarchyState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Bundle <span class="hljs-title">saveHierarchyState</span><span class="hljs-params">()</span> </span>&#123;<br>    Bundle outState = <span class="hljs-keyword">new</span> Bundle();<br>  <br>    <span class="hljs-comment">// 如果没有调用setContentView，无需保存状态</span><br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> outState;<br>    &#125;<br><br>    SparseArray&lt;Parcelable&gt; states = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>    <span class="hljs-comment">// 调用ContentView的saveHierarchyState方法</span><br>    <span class="hljs-comment">// 会将onSaveInstanceState的调用分发给所有View</span><br>    mContentParent.saveHierarchyState(states);<br>    outState.putSparseParcelableArray(VIEWS_TAG, states);<br><br>    <span class="hljs-comment">// 保存当前FocusView的ID</span><br>    <span class="hljs-keyword">final</span> View focusedView = mContentParent.findFocus();<br>    <span class="hljs-keyword">if</span> (focusedView != <span class="hljs-keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;<br>        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());<br>    &#125;<br><br>    <span class="hljs-comment">// 保存所有Panel的状态</span><br>    SparseArray&lt;Parcelable&gt; panelStates = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>    savePanelState(panelStates);<br>    <span class="hljs-keyword">if</span> (panelStates.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        outState.putSparseParcelableArray(PANELS_TAG, panelStates);<br>    &#125;<br><br>    <span class="hljs-comment">// 保存ActionBar的状态</span><br>    <span class="hljs-keyword">if</span> (mDecorContentParent != <span class="hljs-keyword">null</span>) &#123;<br>        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);<br>        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> outState;<br>&#125;<br></code></pre></td></tr></table></figure><p> 此方法中会保存所有此Activity中的视图信息，包括actionBar。另外View的onSaveInstanceState也会在这里被递归的调用。</p><h4 id="FragmentController-saveAllState"><a href="#FragmentController-saveAllState" class="headerlink" title="FragmentController#saveAllState"></a>FragmentController#saveAllState</h4><p>此方法将saveState事件传递给FragmentManager。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Parcelable <span class="hljs-title">saveAllState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mHost.mFragmentManager.saveAllState();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="FragmentManager-saveAllState"><a href="#FragmentManager-saveAllState" class="headerlink" title="FragmentManager#saveAllState"></a>FragmentManager#saveAllState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Parcelable <span class="hljs-title">saveAllState</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 收集所有当前处于活动状态的Fragment的FragmentState</span><br>    <span class="hljs-comment">// 会调用Fragment的onSaveInstanceState方法</span><br>    <span class="hljs-comment">// 同时也会保存绑定的View的视图信息</span><br>    ArrayList&lt;FragmentState&gt; active = mFragmentStore.saveActiveFragments();<br><br>    <span class="hljs-keyword">if</span> (active.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class="hljs-string">&quot;saveAllState: no fragments!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 收集所有添加过的Fragment的FragmentState</span><br>    <span class="hljs-comment">// 会调用Fragment的onSaveInstanceState方法</span><br>    <span class="hljs-comment">// 同时也会保存绑定的View的视图信息</span><br>    ArrayList&lt;String&gt; added = mFragmentStore.saveAddedFragments();<br><br>    <span class="hljs-comment">// 收集回退栈信息</span><br>    BackStackState[] backStack = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (mBackStack != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> size = mBackStack.size();<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            backStack = <span class="hljs-keyword">new</span> BackStackState[size];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                backStack[i] = <span class="hljs-keyword">new</span> BackStackState(mBackStack.get(i));<br>                <span class="hljs-keyword">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;<br>                    Log.v(TAG, <span class="hljs-string">&quot;saveAllState: adding back stack #&quot;</span> + i<br>                            + <span class="hljs-string">&quot;: &quot;</span> + mBackStack.get(i));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将收集到的信息封装成FragmentManagerState对象，它是个Parcelable</span><br>    FragmentManagerState fms = <span class="hljs-keyword">new</span> FragmentManagerState();<br>    fms.mActive = active;<br>    fms.mAdded = added;<br>    fms.mBackStack = backStack;<br>    fms.mBackStackIndex = mBackStackIndex.get();<br>    <span class="hljs-keyword">if</span> (mPrimaryNav != <span class="hljs-keyword">null</span>) &#123;<br>        fms.mPrimaryNavActiveWho = mPrimaryNav.mWho;<br>    &#125;<br>    fms.mResultKeys.addAll(mResults.keySet());<br>    fms.mResults.addAll(mResults.values());<br>    fms.mLaunchedFragments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(mLaunchedFragments);<br>    <span class="hljs-keyword">return</span> fms;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到此方法主要做三件事：</p><ol><li>收集所有当前处于活动状态的FragmentState</li><li>收集所有添加过的FragmentState</li><li>收集当前回退栈信息</li><li>将所有信息封装成FragmentManagerState对象并返回</li></ol><p>到这里整个<code>callActivityOnSaveInstanceState</code>过程是如何收集需要保存的数据的已经分析完毕了。</p><p>前面说了，保存的数据会放到<strong>ActivityClientRecord</strong>的state对象里，根据前面的文章我们知道ActivityClientRecord仅仅是本地App中表示Activity的数据结构，而SaveInstanceState可以做到App被杀死后也能恢复数据，这说明数据并不单单是存储在本地App进程中，否则无法做到这一点。</p><p>不过在整个<code>callActivityOnSaveInstanceState</code>的调用过程中我们无法找到有<strong>持久化</strong>或者<strong>IPC调用</strong>任何操作，因此需要在<code>callActivityOnSaveInstanceState</code>调用后的代码中寻找。</p><p>最终在<strong>ActivityThread#performStopActivityInner</strong>找到关联的代码。</p><h4 id="ActivityThread-performStopActivityInner-1"><a href="#ActivityThread-performStopActivityInner-1" class="headerlink" title="ActivityThread#performStopActivityInner"></a>ActivityThread#performStopActivityInner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStopActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">final</span> StopInfo stopInfo = <span class="hljs-keyword">new</span> StopInfo();<br>    performStopActivityInner(r, stopInfo, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, finalStateRequest,<br>            reason);<br>  <br>    ··· <br>    <br>    stopInfo.setActivity(r);<br>    <span class="hljs-comment">// 将保存的数据设置到了StopInfo中</span><br>    stopInfo.setState(r.state);<br>    stopInfo.setPersistentState(r.persistentState);<br>    pendingActions.setStopInfo(stopInfo);<br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<strong>StopInfo</strong>它是一个Runnable，而我们收集到的数据state将会传递给它，然后将它设置给了<strong>PendingTransactionActions</strong>。既然是一个Runnable，那么它一定会在某个时间被调用，我们只需要关注其<code>run</code>方法即可。</p><h4 id="StopInfo-run"><a href="#StopInfo-run" class="headerlink" title="StopInfo#run"></a>StopInfo#run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通知ATMS此Activity已经Stopped</span><br>    ···<br>    ActivityTaskManager.getService().activityStopped(<br>                mActivity.token, mState, mPersistentState, mDescription);<br>    ···<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法中通过调用<strong>ATMS</strong>的<code>activityStopped</code>方法来通知ATMS此Activity已经Stopped，并将mState属性传递给了方法。</p><p>由于篇幅限制，这里不再深入到ATMS中，实际上最终mState将会赋值给<strong>ActivityRecord</strong>的<strong>icicle</strong>属性中，它也是一个Bundle对象。</p><p>到这里我们已经可以得出结论：<strong>由<code>onSaveInstanceState</code>方法保存的数据将会通过IPC传递到SystemServer的ATMS中</strong>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上述分析，我们知道了一下几点：</p><ul><li>onSaveInstanceState方法将会在每次Activity onStop之前或者之后回调（不考虑Android 3.0以下的情况），在Android 9之前是onStop之前，Android 9之后是onStop之后。也就是说，只要Activity不可见了，就会回调onSaveInstanceState方法。</li><li>在调用onSaveInstanceState时，会保存由当前绑定的Window来完成整个View树的状态保存，由FragmentManager来完成对Activity绑定的所有Fragment的状态保存。</li><li>所有状态信息将会被存放到Bundle对象中，并且最终通过IPC传递给ATMS管理的ActivityRecord对象的icicle属性，因此是属于远端存储，这也是onSaveInstance只支持序列化数据的原因。</li></ul><h3 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h3><p>缓存的数据会在Create阶段传入，另外Activity Start时候也会调用<code>onRestoreInstanceState</code>方法来恢复数据。</p><h3 id="retainNonConfigurationInstances"><a href="#retainNonConfigurationInstances" class="headerlink" title="retainNonConfigurationInstances"></a>retainNonConfigurationInstances</h3><p>如果读者用过ViewModel，会发现在Activity发生了Configuration改变导致的重建时，我们在Activity中（以此Activity为<strong>ViewModelStoreOwner</strong>）创建的ViewModel对象并不会发生改变。</p><p>如果查找过它的源码的话，实际上它是利用的Activity的<code>retainNonConfigurationInstances</code>方法来保存了一些<strong>非配置实例</strong>，其中包括由此Activity构建的ViewModel的存储类<strong>ViewModelStore</strong>。</p><p>该方法声明在Activity.java类中，来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">NonConfigurationInstances <span class="hljs-title">retainNonConfigurationInstances</span><span class="hljs-params">()</span> </span>&#123;<br>    Object activity = onRetainNonConfigurationInstance();<br>    HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances();<br>    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();<br>  <br>    ····<br><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.activity = activity;<br>    nci.children = children;<br>    nci.fragments = fragments;<br>    nci.loaders = loaders;<br>    <span class="hljs-keyword">if</span> (mVoiceInteractor != <span class="hljs-keyword">null</span>) &#123;<br>        mVoiceInteractor.retainInstance();<br>        nci.voiceInteractor = mVoiceInteractor;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nci;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到此方法中调用了三个关键方法来获取所有需要保存的非配置实例，并且封装成NonConfigurationInstances对象，三个方法分辨是：</p><ol><li><strong>onRetainNonConfigurationInstance</strong>：获取此Activity需要保存的非配置实例</li><li><strong>onRetainNonConfigurationChildInstances</strong>：获取子Activity需要保存的非配置实例</li><li><strong>FragmentController#retainNestedNonConfig</strong>：获取此Activity管理的所有Fragment需要保存的非配置实例</li></ol><p>其中Fragment的非配置实例保存已经被废弃了，由于ComponentActivity在配置变更时会保存ViewModel实例，所以Fragment也采用了ViewModel来保存它的非配置实例，由于篇幅有限这里不再深入。</p><p>我们重点来看<code>onRetainNonConfigurationInstance</code>方法，在Activity中是空实现，来看ComponentActivity的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">onRetainNonConfigurationInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 此方法被final修饰了，所以额外提供一个onRetainCustomNonConfigurationInstance方法给开发者使用</span><br>    Object custom = onRetainCustomNonConfigurationInstance();<br><br>    ViewModelStore viewModelStore = mViewModelStore;<br>  <br>    <span class="hljs-comment">// getViewModelStore未被调用</span><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 此时要考虑我们的ViewModel是不是是在上个NonConfigurationInstances对象中取出来的</span><br>        NonConfigurationInstances nc =<br>                (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span>) &#123;<br>            viewModelStore = nc.viewModelStore;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-keyword">null</span> &amp;&amp; custom == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.custom = custom;<br>    nci.viewModelStore = viewModelStore;<br>    <span class="hljs-keyword">return</span> nci;<br></code></pre></td></tr></table></figure><p>此方法将创建的<strong>ViewModelStore</strong>对象保存到了<strong>NonConfigurationInstances</strong>实例中，可以看到ComponentActivity并不是直接保存所有的ViewModel，而是保存ViewModelStore，这样一次性就保存了所有从此ViewModelStoreOwner创建出来的ViewModel对象。</p><p>系统不希望我们继承这个方法，所以这里使用了final来修饰此方法，额外提供了一个<code>onRetainCustomNonConfigurationInstance</code>来允许开发者保存自己的非配置实例数据。</p><p>不过在有了ViewModel之后就不再需要利用此方法了，数据完全可以丢到ViewModel里。</p><p>到这里我们已经清楚了ViewModel对象是如何保存的，但是<code>retainNonConfigurationInstances</code>时机我们还不清楚。全局搜索一下，发现<code>retainNonConfigurationInstances</code>只有一次调用点，就是在ActivityThread的<code>performDestroyActivity</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>  <br>    ···<br>      <br>        <span class="hljs-comment">// 在relaunch时，getNonConfigInstance为true</span><br>        <span class="hljs-keyword">if</span> (getNonConfigInstance) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                r.lastNonConfigurationInstances<br>                        = r.activity.retainNonConfigurationInstances();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                            <span class="hljs-string">&quot;Unable to retain activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>    ···<br>      <br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>performDestroyActivity</code>我们已经有印象了，是在Activity的Destroy阶段会被调用，不过正常的Destroy流程中传入的<strong>getNonConfigInstance</strong>标志位为false，只有Activity Relaunch时才会为true。</p><p>方法中调用了Activity的<code>retainNonConfigurationInstances</code>方法并将结果赋值给了ActivityClientRecord中<strong>lastNonConfigurationInstances</strong>属性，与onSaveInstanceState不同的是，<code>retainNonConfigurationInstances</code>存储的数据允许为Object类型，因为它并不需要IPC，仅仅只存储到本地App进程。</p><p>因此我们可以得出结论：<strong>当App退出或者被系统杀死时，ViewModel是无法还原数据的，其只适用于Activity由于Configuration的改变导致的重建情况。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
      <tag>Activity</tag>
      
      <tag>ViewModel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳实践 | 基于注解处理器实现视图绑定</title>
    <link href="/2021/07/05/7219b693/"/>
    <url>/2021/07/05/7219b693/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们详细介绍了注解处理器的相关功能，不过即使看完也完全不知道注解处理器到底要怎么写。</p><p>注解处理器本身是个实践性十分强的概念，本篇文章将会从0到1编写一个Kotlin注解处理器（KAPT）实现Android中的视图绑定功能，在这之前，先来介绍一些能够协助我们快速开发的开源库。</p><blockquote><p>注：源码链接放置在文末。</p></blockquote><h2 id="开源库推荐"><a href="#开源库推荐" class="headerlink" title="开源库推荐"></a>开源库推荐</h2><p>先推荐几个开源库：<strong>AutoService</strong>、<strong>JavaPoet</strong>、<strong>KotlinPoet</strong>。</p><h3 id="AutoService"><a href="#AutoService" class="headerlink" title="AutoService"></a>AutoService</h3><p>在上篇文章中讲到自定义的注解处理器要正常运作的话，需要对其进行注册，具体是需要在resources/META-INF/services下新建<code>javax.annotation.processing.Processor</code>文件并将注解处理器的全限定名写入文件中。</p><p><img src="/img/image-20210706142548844.png" alt="注册注解处理器"></p><p>这是Java中非常常见的<strong>ServiceLoader</strong>使用方式，需要我们创建的文件称为ServiceLoader的配置文件（configuration），这种方式在很多框架的源码中都有使用。</p><p>不过这种方式略微繁琐，考虑一个问题，既然是生成文件的话，我们的APT刚好就可以实现，那么是否可以由注解处理器来自动生成这个文件呢？</p><p>答案是可以的，而且已经有很多人这样在做了。谷歌就写了一个开源库叫<a href="https://github.com/google/auto">auto</a>，其中的<a href="https://github.com/google/auto/tree/master/service">AutoService</a>就可以帮助我们生成这个文件，源码非常精简，有兴趣可以看看。</p><p>有了AutoService之后，只需要一个注解就可以解决注解处理器的注册问题了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.compiler<br><br><span class="hljs-keyword">import</span> com.google.auto.service.AutoService<br><span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">annotation</span>.processing.Processor<br><br><span class="hljs-meta">@AutoService(Processor::class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewBindingProcessor</span> : <span class="hljs-type">AbstractProcessor</span></span>() &#123;<br>  <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点需要注意，就是在引入AutoService依赖时，如果我们编写的是KAPT的话，需要以同时以implementation和kapt的方式引入AutoService：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br>kapt <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc6&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="JavaPoet"><a href="#JavaPoet" class="headerlink" title="JavaPoet"></a>JavaPoet</h3><p>APT中我们可以使用Filer来创建生成Java源文件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">env.filer.createClassFile(<span class="hljs-string">&quot;...&quot;</span>).openWriter().write(<span class="hljs-string">&quot;xx.java&quot;</span>)<br></code></pre></td></tr></table></figure><p>然而这种方式我们只能通过字符串硬编码的方式来写入代码，对于程序员来说非常不友好，如果代码比较多很容易出现错误而找不到问题的情况。</p><p>因此Square开发了<a href="https://github.com/square/javapoet">JavaPoet</a>，JavaPoet提供了一套用于生成<code>.java</code>文件的API，其使用方法可以参照其Github页面的<a href="https://github.com/square/javapoet/blob/master/README.md">Readme</a>，使用它我们可以按照程序员的方式去编写源代码并输出到文件中。</p><p>比较有意思的是，AutoService正是使用了JavaPoet来生成System Loader的配置文件。</p><h3 id="KotlinPoet"><a href="#KotlinPoet" class="headerlink" title="KotlinPoet"></a>KotlinPoet</h3><p>与JavaPoet类似，<a href="https://github.com/square/kotlinpoet">KotlinPoet</a>用于生成<code>.kotlin</code>源码文件。</p><p>详细的使用方法参照官方文档：<a href="https://square.github.io/kotlinpoet/%E3%80%82">https://square.github.io/kotlinpoet/。</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先来搭建整个Demo的项目结构，一般情况下我们会创建两个Java/Kotlin Module，命名为annotations和processor，其中annotations存放所有的注解，processor则为注解处理器模块。</p><p>另外添加了一个名为runtime的Android Module，存放框架的所有对外开放类，整个源码目录如下。</p><p><img src="/img/image-20210710154732595.png" alt="Demo基础结构"></p><p>下面分别来介绍这些模块。</p><h3 id="annotations"><a href="#annotations" class="headerlink" title="annotations"></a>annotations</h3><p>annotations模块中定义了我们所需要处理的注解，此Demo中我们需要定义两个注解：</p><ul><li><p><strong>BindClass</strong>：使用此注解标注的类我们才会去收集需要注入的View并声称对应的管理类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Target(AnnotationTarget.CLASS)</span><br><span class="hljs-meta">@Retention(AnnotationRetention.BINARY)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindClass</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>BindView</strong>：使用此注解标注的View才会进行依赖注入。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Target(AnnotationTarget.FIELD)</span><br><span class="hljs-meta">@Retention(AnnotationRetention.BINARY)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindView</span></span>(<span class="hljs-keyword">val</span> redId: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h3><p>processor属于核心模块，注解处理器在这里定义。模块目录结构如下所示：</p><p><img src="/img/image-20210710160936091.png" alt="processor模块"></p><p>主要的逻辑在VIewBindingProcessor中，其它类都用于协助注解处理器。</p><p>VIewBindingProcessor要做的事情很简单，分为三步：</p><ol><li><p>收集所有标注了@BindClass的Activity/Fragment：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> activityType = elements.getTypeElement(ACTIVITY_JVM_CLASS_NAME).asType()<br><span class="hljs-keyword">val</span> fragmentType = elements.getTypeElement(FRAGMENT_JVM_CLASS_NAME).asType()<br>roundEnv.getElementsAnnotatedWith(BindClass::<span class="hljs-keyword">class</span>.java)<br>    .filter &#123; it.kind.isClass &#125;<br>    .forEach &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">when</span> &#123;<br>                it.asType().isSubType(activityType, types) -&gt; &#123;<br>                    bindingActivities[it] = BindingActivity(it <span class="hljs-keyword">as</span> TypeElement)<br>                &#125;<br>                it.asType().isSubType(fragmentType, types) -&gt; &#123;<br>                    bindingFragments[it] = BindingFragment(it <span class="hljs-keyword">as</span> TypeElement)<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    Logger.error(it, <span class="hljs-string">&quot;Unsupported typeElement:<span class="hljs-subst">$&#123;it.simpleName&#125;</span>&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            Logger.logParsingError(it, BindClass::<span class="hljs-keyword">class</span>.java, e)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>收集所有标注了@BindView的View：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> viewType = elements.getTypeElement(VIEW_JVM_CLASS_NAME).asType()<br>roundEnv.getElementsAnnotatedWith(BindView::<span class="hljs-keyword">class</span>.java)<br>    .filter &#123; it.kind.isField &#125;<br>    .forEach &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 必须是View的子类</span><br>            <span class="hljs-keyword">if</span> (it.isSubType(viewType, types)) &#123;<br>                <span class="hljs-keyword">if</span> (it.enclosingElement.isSubType(activityType, types)) &#123;<br>                    bindingActivities[it.enclosingElement]?.bindingViews?.add(BindingView(it <span class="hljs-keyword">as</span> Symbol.VarSymbol))<br>                        ?: Logger.error(it, <span class="hljs-string">&quot;BindingView <span class="hljs-variable">$it</span> annotated as @BindView while <span class="hljs-subst">$&#123;it.enclosingElement&#125;</span> not annotated.&quot;</span>)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (it.enclosingElement.isSubType(fragmentType, types)) &#123;<br>                    bindingFragments[it.enclosingElement]?.bindingViews?.add(BindingView(it <span class="hljs-keyword">as</span> Symbol.VarSymbol))<br>                        ?: Logger.error(it, <span class="hljs-string">&quot;BindingView <span class="hljs-variable">$it</span> annotated as @BindView while <span class="hljs-subst">$&#123;it.enclosingElement&#125;</span> not annotated.&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            Logger.logParsingError(it, BindView::<span class="hljs-keyword">class</span>.java, e)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>为Activity/Fragment生成对应ViewBinding类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">bindingActivities.values.forEach &#123;<br>    it.builder.build()<br>&#125;<br>bindingFragments.values.forEach &#123;<br>    it.builder.build()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>BindingActivityBuilder和BindingFragmentBuilder分别用于构造生成类的源码以及输出生成类，主要就是使用KotlinPoet构建整类的变量和方法，具体的代码参考文章底部的源码路径。</p><p>生成类演示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity_ViewBinding</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> activity: MainActivity?<br>) : UnBinder &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> decorView: View? = activity!!.window.decorView<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> button: AppCompatButton? = Utils.findRequiredViewAsType(decorView!!, <span class="hljs-number">2131230808</span>)<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>: UnBinder? &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> MainActivity) &#123;<br>      activity?.button = button!!<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unBind</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">this</span>.activity = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">this</span>.decorView = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">this</span>.button = <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编写注解处理器时，最好是先把要生成的代码写出来，然后对照这个代码使用KotlinPoet进行代码生成。</p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>runtime模块主要是提供一个门面类：ViewBinding。此类负责注册Activity和Fragment的LifecycleCallback，方便在Activity和Fragment销毁时自动进行视图解绑，防止出现内存泄露问题。</p><p>ViewBinding类的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewBinding</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> BINDINGS = LinkedHashMap&lt;String, UnBinder&gt;()<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> activityLifecycleCallback = BindingActivityLifecycleCallback()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallback = BindingFragmentLifecycleCallback()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(app: <span class="hljs-type">Application</span>)</span></span> &#123;<br>        app.registerActivityLifecycleCallbacks(activityLifecycleCallback)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进行视图绑定</span><br><span class="hljs-comment">     * 需要在Activity setContentView之后</span><br><span class="hljs-comment">     * 以及Fragment onCreatedView之后调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(source: <span class="hljs-type">Any</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (source !<span class="hljs-keyword">is</span> Activity &amp;&amp; source !<span class="hljs-keyword">is</span> Fragment) <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">val</span> sourceClass = source::<span class="hljs-keyword">class</span>.java<br>        <span class="hljs-keyword">val</span> bindingClassName = source.javaClass.name + BINDING_CLASS_POSTFIX<br>        <span class="hljs-keyword">var</span> unBinder = BINDINGS[bindingClassName]<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (unBinder == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">val</span> bindingClass = Class.forName(sourceClass.name)?.classLoader?.loadClass(bindingClassName) ?: <span class="hljs-keyword">return</span><br>                unBinder = bindingClass.getConstructor(sourceClass).newInstance(source) <span class="hljs-keyword">as</span> UnBinder<br>                BINDINGS[bindingClassName] = unBinder<br>            &#125;<br>            unBinder.bind()<br>        &#125; <span class="hljs-keyword">catch</span> (e: ClassNotFoundException) &#123;<br>            e.printStackTrace()<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">is</span> Fragment) &#123;<br>            source.parentFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallback, <span class="hljs-literal">false</span>)<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑</span><br><span class="hljs-comment">     * 由LifecycleCallback自动调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unBind</span><span class="hljs-params">(source: <span class="hljs-type">Any</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (source !<span class="hljs-keyword">is</span> Activity &amp;&amp; source !<span class="hljs-keyword">is</span> Fragment) <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">val</span> bindingClassName = source.javaClass.name + BINDING_CLASS_POSTFIX<br><br>        <span class="hljs-keyword">val</span> unBinder = BINDINGS[bindingClassName] ?: <span class="hljs-keyword">return</span><br>        unBinder.unBind()<br><br>        BINDINGS.remove(bindingClassName)<br><br>        <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">is</span> Fragment) &#123;<br>            source.parentFragmentManager.unregisterFragmentLifecycleCallbacks(fragmentLifecycleCallback)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BINDING_CLASS_POSTFIX = <span class="hljs-string">&quot;_ViewBinding&quot;</span><br><br>        <span class="hljs-keyword">val</span> INSTANCE: ViewBinding <span class="hljs-keyword">by</span> lazy &#123; ViewBinding() &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中init方法需要在Application创建时调用，因此这里使用了ContentProvider来初始化ViewBinding类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by sukaidev on 2021/07/03.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 用于初始化Runtime.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> sukaidev</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeProvider</span> : <span class="hljs-type">ContentProvider</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        ViewBinding.INSTANCE.<span class="hljs-keyword">init</span>(context.applicationContext <span class="hljs-keyword">as</span> Application)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">query</span><span class="hljs-params">(uri: <span class="hljs-type">Uri</span>?, projection: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?, selection: <span class="hljs-type">String</span>?, selectionArgs: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?, sortOrder: <span class="hljs-type">String</span>?)</span></span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getType</span><span class="hljs-params">(uri: <span class="hljs-type">Uri</span>?)</span></span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insert</span><span class="hljs-params">(uri: <span class="hljs-type">Uri</span>?, values: <span class="hljs-type">ContentValues</span>?)</span></span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delete</span><span class="hljs-params">(uri: <span class="hljs-type">Uri</span>?, selection: <span class="hljs-type">String</span>?, selectionArgs: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?)</span></span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">update</span><span class="hljs-params">(uri: <span class="hljs-type">Uri</span>?, values: <span class="hljs-type">ContentValues</span>?, selection: <span class="hljs-type">String</span>?, selectionArgs: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?)</span></span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>Github地址，需科学：<a href="https://github.com/sukaidev/BestPractices/tree/main/ViewBindingAptDemo">源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Best Practices</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
      <tag>KAPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（七）——插件化注解处理器</title>
    <link href="/2021/06/25/19e6281/"/>
    <url>/2021/06/25/19e6281/</url>
    
    <content type="html"><![CDATA[<p>Java 中的注解（Annotation）在JDK 1.5中第一次被引入，当时开发者只能在运行时通过反射机制获取。反射的效率不高，局限性大，因此在JDK 1.6的<a href="https://www.jcp.org/en/jsr/detail?id=269">JSR 269</a>规范中引入了编译期注解，即插件化注解处理器（<strong>Pluggable Annotation Processor</strong>），使得我们可以通过注解处理器在Javac的编译阶段修改抽象语法树的内部。</p><p>在了解插件化注解处理器之前，先来了解一下Javac的编译过程以及抽象语法树操作相关的API。</p><h2 id="Javac编译流程"><a href="#Javac编译流程" class="headerlink" title="Javac编译流程"></a>Javac编译流程</h2><p>Java中通过javac编译器将源码.java文件编译为.class文件，从编译原理的角度来说这一过程属于前端编译。</p><p>整个编译过程分为七个阶段，其中process过程将会使用注解处理器来处理源码中的注解，如下图所示。</p><p><img src="/img/image-20210704213727420.png" alt="javac编译流程"></p><p>编译原理并不是本文的重点，所以下面只是简单介绍这七个步骤，具体细节可以翻看javac源码，它本身也是由Java语言编写的。</p><ol><li><strong>parse</strong>阶段：读取.java文件并做词法分析和语法分析。</li><li><strong>enter</strong>阶段：解析和填充符号表。</li><li><strong>process</strong>阶段：处理编译时注解。</li><li><strong>attr</strong>阶段：检查语义合法性、常量折叠。</li><li><strong>flow</strong>阶段：处理数据流分析。</li><li><strong>desugar</strong>阶段：去除高版本JDK中的语法糖。</li><li><strong>generate</strong>：生成字节码并输出到.class文件。</li></ol><h2 id="抽象语法树操作API"><a href="#抽象语法树操作API" class="headerlink" title="抽象语法树操作API"></a>抽象语法树操作API</h2><p>抽象语法树操作的核心类是<strong>Names</strong>、<strong>JCTree</strong>和<strong>TreeMaker</strong>，其中Names类提供了访问标识符的方法，JCTree类是语法树元素的基类，TreeMaker类封装了创建语法树节点的办法。</p><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><p>Names类提供了访问标识符Name的方法，它最常用的方法是fromString，用来从一个字符串中获取Name对象，此方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Name <span class="hljs-title">fromString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> table.fromString(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JCTree"><a href="#JCTree" class="headerlink" title="JCTree"></a>JCTree</h3><p>JCTree是语法树元素的基类，包含一个重要的字段pos，该字段用于指明当前语法树节点（JCTree）在语法树中的位置，因此我们不能直接用new关键字来创建语法树节点，即使创建了也没有意义。此外，结合访问者模式，将数据结构与数据的处理进行解耦，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JCTree</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tree</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">DiagnosticPosition</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(JCTree.Visitor visitor)</span></span>;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到JCTree是一个抽象类，这里重点介绍几个JCTree的子类：</p><ol><li>JCStatement：声明语法树节点，常见的子类如下<ul><li>JCBlock：<strong>语句块</strong>语法树节点</li><li>JCReturn：<strong>return语句</strong>语法树节点</li><li>JCClassDecl：<strong>类定义</strong>语法树节点</li><li>JCVariableDecl：<strong>字段/变量定义</strong>语法树节点</li></ul></li><li>JCMethodDecl：<strong>方法定义</strong>语法树节点</li><li>JCModifiers：<strong>访问标志</strong>语法树节点</li><li>JCExpression：表达式语法树节点，常见的子类如下<ul><li>JCAssign：<strong>赋值语句</strong>语法树节点</li><li>JCIdent：<strong>标识符</strong>语法树节点，可以是变量，类型，关键字等等</li></ul></li></ol><h3 id="TreeMaker"><a href="#TreeMaker" class="headerlink" title="TreeMaker"></a>TreeMaker</h3><p>TreeMaker用于创建一系列的语法树节点，我们上面说了创建JCTree不能直接使用new关键字来创建，所以Java为我们提供了一个工具，就是TreeMaker，它会在创建时为我们创建的JCTree对象设置pos字段，所以必须使用上下文相关的TreeMaker对象来创建语法树节点。</p><p>具体的API介绍可以参照，<a href="https://www.oschina.net/action/GoToLink?url=http://www.docjar.com/docs/api/com/sun/tools/javac/tree/TreeMaker.html">TreeMakerAPI</a>，接下来着重介绍一下常用的几个方法。</p><h4 id="TreeMaker-Modifiers"><a href="#TreeMaker-Modifiers" class="headerlink" title="TreeMaker.Modifiers"></a>TreeMaker.Modifiers</h4><p>TreeMaker.Modifiers方法用于创建<strong>访问标志</strong>语法树节点（JCModifiers），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCModifiers <span class="hljs-title">Modifiers</span><span class="hljs-params">(<span class="hljs-keyword">long</span> flags)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Modifiers(flags, List.nil());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCModifiers <span class="hljs-title">Modifiers</span><span class="hljs-params">(<span class="hljs-keyword">long</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCAnnotation&gt; annotations)</span> </span>&#123;<br>        JCModifiers tree = <span class="hljs-keyword">new</span> JCModifiers(flags, annotations);<br>        <span class="hljs-keyword">boolean</span> noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == <span class="hljs-number">0</span>;<br>        tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中参数flag表示访问标志，annotations表示注解列表。</p><p>flag可以使用枚举类<code>com.sun.tools.javac.code.Flags</code>来表示，例如要表示<code>public static final</code>可以这样用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL);<br></code></pre></td></tr></table></figure><h4 id="TreeMaker-ClassDef"><a href="#TreeMaker-ClassDef" class="headerlink" title="TreeMaker.ClassDef"></a>TreeMaker.ClassDef</h4><p>TreeMaker.ClassDef用于创建<strong>类定义</strong>语法树节点（JCClassDecl）,源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCClassDecl <span class="hljs-title">ClassDef</span><span class="hljs-params">(JCModifiers mods,</span></span><br><span class="hljs-function"><span class="hljs-params">    Name name,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCTypeParameter&gt; typarams,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression extending,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCExpression&gt; implementing,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCTree&gt; defs)</span> </span>&#123;<br>        JCClassDecl tree = <span class="hljs-keyword">new</span> JCClassDecl(mods,<br>                                     name,<br>                                     typarams,<br>                                     extending,<br>                                     implementing,<br>                                     defs,<br>                                     <span class="hljs-keyword">null</span>);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>mods：访问标志，可以通过方法<code>TreeMaker.Modifiers</code>来创建</li><li>name：类名</li><li>typarams：泛型参数列表</li><li>extending：父类</li><li>implementing：实现的接口</li><li>defs：类定义的详细语句，包括字段、方法的定义等等</li></ol><h4 id="TreeMaker-MethodDef"><a href="#TreeMaker-MethodDef" class="headerlink" title="TreeMaker.MethodDef"></a>TreeMaker.MethodDef</h4><p>TreeMaker.MethodDef用于创建<strong>方法定义</strong>语法树节点（JCMethodDecl），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCMethodDecl <span class="hljs-title">MethodDef</span><span class="hljs-params">(JCModifiers mods,</span></span><br><span class="hljs-function"><span class="hljs-params">    Name name,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression restype,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCTypeParameter&gt; typarams,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCVariableDecl&gt; params,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCExpression&gt; thrown,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCBlock body,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression defaultValue)</span> </span>&#123;<br>        JCMethodDecl tree = <span class="hljs-keyword">new</span> JCMethodDecl(mods,<br>                                       name,<br>                                       restype,<br>                                       typarams,<br>                                       params,<br>                                       thrown,<br>                                       body,<br>                                       defaultValue,<br>                                       <span class="hljs-keyword">null</span>);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCMethodDecl <span class="hljs-title">MethodDef</span><span class="hljs-params">(MethodSymbol m,</span></span><br><span class="hljs-function"><span class="hljs-params">    Type mtype,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCBlock body)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (JCMethodDecl)<br>            <span class="hljs-keyword">new</span> JCMethodDecl(<br>                Modifiers(m.flags(), Annotations(m.getAnnotationMirrors())),<br>                m.name,<br>                Type(mtype.getReturnType()),<br>                TypeParams(mtype.getTypeArguments()),<br>                Params(mtype.getParameterTypes(), m),<br>                Types(mtype.getThrownTypes()),<br>                body,<br>                <span class="hljs-keyword">null</span>,<br>                m).setPos(pos).setType(mtype);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>mods：访问标志</li><li>name：方法名</li><li>restype：返回类型</li><li>typarams：泛型参数列表</li><li>params：参数列表</li><li>thrown：异常声明列表</li><li>body：方法体</li><li>defaultValue：默认方法（可能是interface中的哪个default）</li><li>m：方法符号</li><li>mtype：方法类型。包含多种类型，泛型参数类型、方法参数类型、异常参数类型、返回参数类型。</li></ol><p>其中返回类型restype填写null或者<code>treeMaker.TypeIdent(TypeTag.VOID)</code>都代表返回void类型。</p><h4 id="TreeMaker-VarDef"><a href="#TreeMaker-VarDef" class="headerlink" title="TreeMaker.VarDef"></a>TreeMaker.VarDef</h4><p>TreeMaker.VarDef用于创建<strong>字段/变量定义</strong>语法树节点（JCVariableDecl），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCVariableDecl <span class="hljs-title">VarDef</span><span class="hljs-params">(JCModifiers mods,</span></span><br><span class="hljs-function"><span class="hljs-params">    Name name,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression vartype,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression init)</span> </span>&#123;<br>        JCVariableDecl tree = <span class="hljs-keyword">new</span> JCVariableDecl(mods, name, vartype, init, <span class="hljs-keyword">null</span>);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCVariableDecl <span class="hljs-title">VarDef</span><span class="hljs-params">(VarSymbol v,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression init)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (JCVariableDecl)<br>            <span class="hljs-keyword">new</span> JCVariableDecl(<br>                Modifiers(v.flags(), Annotations(v.getAnnotationMirrors())),<br>                v.name,<br>                Type(v.type),<br>                init,<br>                v).setPos(pos).setType(v.type);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>mods：访问标志</li><li>name：参数名称</li><li>vartype：类型</li><li>init：初始化语句</li><li>v：变量符号</li></ol><h4 id="TreeMaker-Ident"><a href="#TreeMaker-Ident" class="headerlink" title="TreeMaker.Ident"></a>TreeMaker.Ident</h4><p>TreeMaker.Ident用于创建<strong>标识符</strong>语法树节点（JCIdent），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCIdent <span class="hljs-title">Ident</span><span class="hljs-params">(Name name)</span> </span>&#123;<br>        JCIdent tree = <span class="hljs-keyword">new</span> JCIdent(name, <span class="hljs-keyword">null</span>);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCIdent <span class="hljs-title">Ident</span><span class="hljs-params">(Symbol sym)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (JCIdent)<span class="hljs-keyword">new</span> JCIdent((sym.name != names.empty)<br>                                ? sym.name<br>                                : sym.flatName(), sym)<br>            .setPos(pos)<br>            .setType(sym.type);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCExpression <span class="hljs-title">Ident</span><span class="hljs-params">(JCVariableDecl param)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Ident(param.sym);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TreeMaker-Return"><a href="#TreeMaker-Return" class="headerlink" title="TreeMaker.Return"></a>TreeMaker.Return</h4><p>TreeMaker.Return用于创建<strong>return语句</strong>（JCReturn），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCReturn <span class="hljs-title">Return</span><span class="hljs-params">(JCExpression expr)</span> </span>&#123;<br>        JCReturn tree = <span class="hljs-keyword">new</span> JCReturn(expr);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TreeMaker-Select"><a href="#TreeMaker-Select" class="headerlink" title="TreeMaker.Select"></a>TreeMaker.Select</h4><p>TreeMaker.Select用于创建<strong>域访问/方法访问</strong>（这里的方法访问只是取到名字，方法的调用需要用TreeMaker.Apply）语法树节点（JCFieldAccess），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCFieldAccess <span class="hljs-title">Select</span><span class="hljs-params">(JCExpression selected,</span></span><br><span class="hljs-function"><span class="hljs-params">    Name selector)</span> </span><br><span class="hljs-function"></span>&#123;<br>        JCFieldAccess tree = <span class="hljs-keyword">new</span> JCFieldAccess(selected, selector, <span class="hljs-keyword">null</span>);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> JCExpression <span class="hljs-title">Select</span><span class="hljs-params">(JCExpression base,</span></span><br><span class="hljs-function"><span class="hljs-params">    Symbol sym)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>selected：<code>.</code>运算符左边的表达式</li><li>selector：<code>.</code>运算符右边的表达式</li></ol><p>举个例子，使用如下代码可以生成<code>this.name</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMaker.Select(treeMaker.Ident(names.fromString(<span class="hljs-string">&quot;this&quot;</span>)), names.fromString(<span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="TreeMaker-NewClass"><a href="#TreeMaker-NewClass" class="headerlink" title="TreeMaker.NewClass"></a>TreeMaker.NewClass</h4><p>TreeMaker.NewClass用于创建<strong>new语句</strong>语法树节点（JCNewClass）,源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCNewClass <span class="hljs-title">NewClass</span><span class="hljs-params">(JCExpression encl,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCExpression&gt; typeargs,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression clazz,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCExpression&gt; args,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCClassDecl def)</span> </span>&#123;<br>        JCNewClass tree = <span class="hljs-keyword">new</span> JCNewClass(encl, typeargs, clazz, args, def);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>encl：以表达式的方式创建，正常new传null即可</li><li>typeargs：参数类型列表</li><li>clazz：待创建对象的类型</li><li>args：参数列表</li><li>def：类定义</li></ol><h4 id="TreeMaker-Apply"><a href="#TreeMaker-Apply" class="headerlink" title="TreeMaker.Apply"></a>TreeMaker.Apply</h4><p>TreeMaker.Apply用于创建<strong>方法调用</strong>语法树节点（JCMethodInvocation），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCMethodInvocation <span class="hljs-title">Apply</span><span class="hljs-params">(List&lt;JCExpression&gt; typeargs,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression fn,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCExpression&gt; args)</span> </span>&#123;<br>        JCMethodInvocation tree = <span class="hljs-keyword">new</span> JCMethodInvocation(typeargs, fn, args);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>typeargs：参数类型列表</li><li>fn：调用语句</li><li>args：参数列表</li></ol><h4 id="TreeMaker-Assign"><a href="#TreeMaker-Assign" class="headerlink" title="TreeMaker.Assign"></a>TreeMaker.Assign</h4><p>TreeMaker.Assign用户创建<strong>赋值语句</strong>语法树节点（JCAssign），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCAssign <span class="hljs-title">Assign</span><span class="hljs-params">(JCExpression lhs,</span></span><br><span class="hljs-function"><span class="hljs-params">    JCExpression rhs)</span> </span>&#123;<br>        JCAssign tree = <span class="hljs-keyword">new</span> JCAssign(lhs, rhs);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>lhs：赋值语句左边表达式</li><li>rhs：赋值语句右边表达式</li></ol><h4 id="TreeMaker-Exec"><a href="#TreeMaker-Exec" class="headerlink" title="TreeMaker.Exec"></a>TreeMaker.Exec</h4><p>TreeMaker.Exec用于创建<strong>可执行语句</strong>语法树节点（JCExpressionStatement），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCExpressionStatement <span class="hljs-title">Exec</span><span class="hljs-params">(JCExpression expr)</span> </span>&#123;<br>        JCExpressionStatement tree = <span class="hljs-keyword">new</span> JCExpressionStatement(expr);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>TreeMaker.Apply以及TreeMaker.Assign需要外面包一层TreeMaker.Exec来获得一个JCExpressionStatement。</p><h4 id="TreeMaker-Block"><a href="#TreeMaker-Block" class="headerlink" title="TreeMaker.Block"></a>TreeMaker.Block</h4><p>TreeMaker.Block用于创建<strong>组合语句</strong>的语法树节点（JCBlock），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> JCBlock <span class="hljs-title">Block</span><span class="hljs-params">(<span class="hljs-keyword">long</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">    List&lt;JCStatement&gt; stats)</span> </span>&#123;<br>        JCBlock tree = <span class="hljs-keyword">new</span> JCBlock(flags, stats);<br>        tree.pos = pos;<br>        <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li>flags：访问标志</li><li>stats：语句列表</li></ol><h2 id="常用类介绍"><a href="#常用类介绍" class="headerlink" title="常用类介绍"></a>常用类介绍</h2><p>上节讨论了操作抽象语法树的核心API，这些API可以帮助我们在javac的编译阶段修改源码，但实际上大部分情况下我们实现注解处理器并不需要去修改源码，而是通过生成辅助类来优化开发效率。</p><p>因此大部分情况下我们仅需要使用一些注解处理器中常用的类就可以实现我们需要的功能，下面就来简单介绍这些类。</p><h3 id="AnnotationMirror"><a href="#AnnotationMirror" class="headerlink" title="AnnotationMirror"></a>AnnotationMirror</h3><p>AnnotationMirror用于表示一个注解，其中提供了两个方法分别用于获取注解类型和注解的值，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotationMirror</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此注解的ElementType</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">DeclaredType <span class="hljs-title">getAnnotationType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此注解的所有Element的值</span><br><span class="hljs-comment">     */</span><br>    Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; getElementValues();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>Element我们通常称为节点或者元素。例如HTML作为一种结构体语言，其中有很多规范的标签限定，每种标签标示一个Element，如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Sukai&#x27;s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于Java源文件来说，同样也是一种结构体语言，源代码的每一个部分都是一个特定类型的Element，也就是说Element代表源文件中的元素，例如包、类、字段、方法等。</p><p>Element类是一个接口，由Element衍生出来的扩展类共有五种，分别是：</p><ul><li>PackageElement：表示一个包程序元素，提供对有关包及成员的信息的访问。</li><li>TypeElement：表示一个类或者接口程序元素，提供对有关类型及其成员信息的访问。</li><li>TypeParameterElement：表示一个泛型元素。</li><li>VariableElement：表示一个字段、enum常量、方法或者构造方法的参数、局部变量或异常参数。</li><li>ExecuteableElement：表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）。</li></ul><p>Element类中定义了几个方法，我们来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">javax</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">model</span>.<span class="hljs-title">AnnotatedConstruct</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此元素的实际类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TypeMirror <span class="hljs-title">asType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此元素的元素类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ElementKind <span class="hljs-title">getKind</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此元素的修饰符，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Set&lt;Modifier&gt; <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取不带包名的simpleName</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Name <span class="hljs-title">getSimpleName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取直接父节点Element</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Element <span class="hljs-title">getEnclosingElement</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取直接子节点Element</span><br><span class="hljs-comment">     */</span><br>    List&lt;? extends Element&gt; getEnclosedElements();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此节点元素的注解，不会包含子节点的注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取特定的注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    &lt;A extends Annotation&gt; <span class="hljs-function">A <span class="hljs-title">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationType)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此节点上应用Visitor，可以修改元素节点树</span><br><span class="hljs-comment">     */</span><br>    &lt;R, P&gt; <span class="hljs-function">R <span class="hljs-title">accept</span><span class="hljs-params">(ElementVisitor&lt;R, P&gt; v, P p)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ElementKind"><a href="#ElementKind" class="headerlink" title="ElementKind"></a>ElementKind</h3><p>ElementKind是一个枚举类，其中包含了所有Element类型，下表为ElementKind枚举类中的所有常量，详细信息请查看官方文档。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>PACKAGE</td><td>包类型</td></tr><tr><td>ENUM</td><td>枚举类型</td></tr><tr><td>CLASS</td><td>普通类类型</td></tr><tr><td>ANNOTATION_TYPE</td><td>注解类型</td></tr><tr><td>INTERFACE</td><td>普通接口类型</td></tr><tr><td>ENUM_CONSTANT</td><td>枚举常量类型</td></tr><tr><td>FIELD</td><td>类中定义的字段类型</td></tr><tr><td>PARAMETER</td><td>方法或构造器中的参数类型</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量类型</td></tr><tr><td>EXCEPTION_PARAMETER</td><td>异常处理参数类型</td></tr><tr><td>METHOD</td><td>方法类型</td></tr><tr><td>CONSTRUCTOR</td><td>构造器类型</td></tr><tr><td>STATIC_INIT</td><td>静态代码块类型</td></tr><tr><td>INSTANCE_INIT</td><td>非静态代码块类型</td></tr><tr><td>TYPE_PARAMETER</td><td>泛型参数类型</td></tr><tr><td>RESOURCE_VARIABLE</td><td>资源变量类型</td></tr><tr><td>OTHER</td><td>其他类型</td></tr></tbody></table><p>如果我们要判断一个元素的类型，应该使用Element.getKind()方法配合ElementKind枚举类进行判断。</p><p>尽量<strong>避免使用instanceof进行判断</strong>，因为比如TypeElement既表示类又表示一个接口，这样判断的结果可能不是你想要的。例如我们判断一个元素是不是一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (element <span class="hljs-keyword">is</span> TypeElement)<br></code></pre></td></tr></table></figure><p>这种情况element有可能是class、interface或者是enum，所以我们应该使用ElementKind来判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (element.kind == ElementKind.CLASS)<br></code></pre></td></tr></table></figure><h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h3><p>Elements是JDK 1.6中加入的协助操作Element的工具类，通过<code>ProcessingEnvironment#getElementUtils</code>方法可以获取，其中定义了不少工具方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Elements</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过全限定包名获取唯一的PackageElement</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">PackageElement <span class="hljs-title">getPackageElement</span><span class="hljs-params">(CharSequence name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过规范名获取唯一的TypeElement</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TypeElement <span class="hljs-title">getTypeElement</span><span class="hljs-params">(CharSequence name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过AnnotationMirror获取其中所有Element的值，</span><br><span class="hljs-comment">     */</span><br>    Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt;<br>            getElementValuesWithDefaults(AnnotationMirror a);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此Element的Java doc信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getDocComment</span><span class="hljs-params">(Element e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDeprecated</span><span class="hljs-params">(Element e)</span></span>;<br><br>    <span class="hljs-function">Name <span class="hljs-title">getBinaryName</span><span class="hljs-params">(TypeElement type)</span></span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取此Element的包Element</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">PackageElement <span class="hljs-title">getPackageOf</span><span class="hljs-params">(Element type)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取所有成员Element</span><br><span class="hljs-comment">     */</span><br>    List&lt;? extends Element&gt; getAllMembers(TypeElement type);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取所有注解信息</span><br><span class="hljs-comment">     */</span><br>    List&lt;? extends AnnotationMirror&gt; getAllAnnotationMirrors(Element e);<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hides</span><span class="hljs-params">(Element hider, Element hidden)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">overrides</span><span class="hljs-params">(ExecutableElement overrider, ExecutableElement overridden,</span></span><br><span class="hljs-function"><span class="hljs-params">                      TypeElement type)</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">getConstantExpression</span><span class="hljs-params">(Object value)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printElements</span><span class="hljs-params">(java.io.Writer w, Element... elements)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将字符序列转换为Name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Name <span class="hljs-title">getName</span><span class="hljs-params">(CharSequence cs)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否JDK 1.8新增的<span class="hljs-doctag">@FunctionalInterface</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isFunctionalInterface</span><span class="hljs-params">(TypeElement type)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a>TypeMirror</h3><p>TypeMirror是一个接口，表示 Java 编程语言中的类型。类名为什么不直接用Type呢？猜测是为了与反射包中的Type作区分。</p><p>TypeMirror表示的类型包括基本类型、声明类型、数组类型、类型变量和null类型，还可以表示通配符类型参数、executable 的签名和返回类型，以及对应于包和关键字 void 的伪类型。</p><p>TypeMirror有许多子接口，其类图如下所示。</p><p><img src="/img/TypeMirror.png" alt="TypeMirror类图"></p><p>这里简单介绍一下这些子接口。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>ExecutableType</td><td>表示一个可执行类型，包括方法、构造器、构造块</td></tr><tr><td>IntersectionType</td><td>表示一个交集类型，出现在泛型的上下边界中</td></tr><tr><td>ReferenceType</td><td>表示一个引用类型，包括类和接口类型、数组类型、类型变量和 null 类型</td></tr><tr><td>ArrayType</td><td>表示一个数组类型</td></tr><tr><td>DeclaredType</td><td>表示一个声明类型，包括类和接口</td></tr><tr><td>TypeVariable</td><td>表示一个类型变量，即泛型类型</td></tr><tr><td>NullType</td><td>表示一个空类型，对应Java中的null</td></tr><tr><td>NoType</td><td>表示无类型，VOID、PACKAGE和NONE都是NoType</td></tr><tr><td>PrimitiveType</td><td>表示一个基本类型，包括boolean、byte、short、int、long、char、float和double</td></tr><tr><td>WildcardType</td><td>表示带通配符的泛型类型</td></tr></tbody></table><h3 id="TypeKind"><a href="#TypeKind" class="headerlink" title="TypeKind"></a>TypeKind</h3><p>与ElementKind类似，判断TypeMirror类型时我们也应该使用TypeKind来进行。</p><p>TypeKind的枚举类型有点多，这里简单介绍部分常量，详细信息请查看官方文档。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>BOOLEAN</td><td>基本类型 boolean</td></tr><tr><td>INT</td><td>基本类型 int</td></tr><tr><td>LONG</td><td>基本类型 long</td></tr><tr><td>FLOAT</td><td>基本类型 float</td></tr><tr><td>DOUBLE</td><td>基本类型 double</td></tr><tr><td>VOID</td><td>对应于关键字 void 的伪类型</td></tr><tr><td>NULL</td><td>null 类型</td></tr><tr><td>ARRAY</td><td>数组类型</td></tr><tr><td>PACKAGE</td><td>对应于包元素的伪类型</td></tr><tr><td>EXECUTABLE</td><td>方法、构造方法或初始化程序</td></tr></tbody></table><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>与Elements类似，Types是JDK中提供的辅助操作TypeMiror的工具类，使用<code>ProcessingEnvironment#getTypeUtils</code>方法来获取，方法介绍如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Types</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回TypeMirror对应的Element</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Element <span class="hljs-title">asElement</span><span class="hljs-params">(TypeMirror t)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameType</span><span class="hljs-params">(TypeMirror t1, TypeMirror t2)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * t1是否是t2的子Type</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubtype</span><span class="hljs-params">(TypeMirror t1, TypeMirror t2)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * t1是否是t2的父Type</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAssignable</span><span class="hljs-params">(TypeMirror t1, TypeMirror t2)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(TypeMirror t1, TypeMirror t2)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * m1的方法签名是否是m2的子签名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsignature</span><span class="hljs-params">(ExecutableType m1, ExecutableType m2)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回t的直接父Type</span><br><span class="hljs-comment">     */</span><br>    List&lt;? extends TypeMirror&gt; directSupertypes(TypeMirror t);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回t泛型擦除后的TypeMirror</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TypeMirror <span class="hljs-title">erasure</span><span class="hljs-params">(TypeMirror t)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回基本类型装箱后的TypeElement</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TypeElement <span class="hljs-title">boxedClass</span><span class="hljs-params">(PrimitiveType p)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回拆箱后的基本类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">PrimitiveType <span class="hljs-title">unboxedType</span><span class="hljs-params">(TypeMirror t)</span></span>;<br><br>    <span class="hljs-function">TypeMirror <span class="hljs-title">capture</span><span class="hljs-params">(TypeMirror t)</span></span>;<br><br>    <span class="hljs-function">PrimitiveType <span class="hljs-title">getPrimitiveType</span><span class="hljs-params">(TypeKind kind)</span></span>;<br><br>    <span class="hljs-function">NullType <span class="hljs-title">getNullType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">NoType <span class="hljs-title">getNoType</span><span class="hljs-params">(TypeKind kind)</span></span>;<br><br>    <span class="hljs-function">ArrayType <span class="hljs-title">getArrayType</span><span class="hljs-params">(TypeMirror componentType)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过上下边界获取通配符类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">WildcardType <span class="hljs-title">getWildcardType</span><span class="hljs-params">(TypeMirror extendsBound,</span></span><br><span class="hljs-function"><span class="hljs-params">                                 TypeMirror superBound)</span></span>;<br><br>    <span class="hljs-function">DeclaredType <span class="hljs-title">getDeclaredType</span><span class="hljs-params">(TypeElement typeElem, TypeMirror... typeArgs)</span></span>;<br><br>    <span class="hljs-function">DeclaredType <span class="hljs-title">getDeclaredType</span><span class="hljs-params">(DeclaredType containing,</span></span><br><span class="hljs-function"><span class="hljs-params">                                 TypeElement typeElem, TypeMirror... typeArgs)</span></span>;<br><br>    <span class="hljs-function">TypeMirror <span class="hljs-title">asMemberOf</span><span class="hljs-params">(DeclaredType containing, Element element)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Filer"><a href="#Filer" class="headerlink" title="Filer"></a>Filer</h3><p>Filer类似于Java IO库中的File，用于协助注解处理器创建新文件，这个文件包括源文件、类文件和辅助资源文件。</p><h4 id="创建源文件"><a href="#创建源文件" class="headerlink" title="创建源文件"></a>创建源文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">JavaFileObject <span class="hljs-title">createSourceFile</span><span class="hljs-params">(CharSequence name,</span></span><br><span class="hljs-function"><span class="hljs-params">                    Element... originatingElements)</span></span><br><span class="hljs-function">                    <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></td></tr></table></figure><p>创建一个新的源文件，并返回一个对象以允许写入它。文件的名称和路径（相对于源文件的根目录输出位置）基于该文件中声明的类型。如果声明的类型不止一个，则应该使用主要顶层类型的名称（例如，声明为 public 的那个）。</p><p>还可以创建源文件来保存有关某个包的信息，包括包注解。要为指定包创建源文件，可以用 name 作为包名称，后跟 “.package-info”；要为未指定的包创建源文件，可以使用 “package-info”。</p><h4 id="创建类文件"><a href="#创建类文件" class="headerlink" title="创建类文件"></a>创建类文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">JavaFileObject <span class="hljs-title">createClassFile</span><span class="hljs-params">(CharSequence name,</span></span><br><span class="hljs-function"><span class="hljs-params">                       Element... originatingElements)</span></span><br><span class="hljs-function">                       <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></td></tr></table></figure><p>创建一个新的类文件，并返回一个对象以允许写入它。文件的名称和路径（相对于类文件的根目录输出位置）基于将写入的类型名称。还可以创建类文件来保存有关某个包的信息，包括包注解。要为指定包创建类文件，可以用 name 作为包名称，后跟 “.package-info”；为未指定的包创建类文件不受支持。</p><h4 id="创建辅助资源文件"><a href="#创建辅助资源文件" class="headerlink" title="创建辅助资源文件"></a>创建辅助资源文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">FileObject <span class="hljs-title">createResource</span><span class="hljs-params">(JavaFileManager.Location location,</span></span><br><span class="hljs-function"><span class="hljs-params">                  CharSequence pkg,</span></span><br><span class="hljs-function"><span class="hljs-params">                  CharSequence relativeName,</span></span><br><span class="hljs-function"><span class="hljs-params">                  Element... originatingElements)</span></span><br><span class="hljs-function">                  <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></td></tr></table></figure><p>创建一个用于写入操作的新辅助资源文件，并为它返回一个文件对象。该文件可以与新创建的源文件、新创建的二进制文件或者其他受支持的位置一起被查找。位置 CLASS_OUTPUT 和 SOURCE_OUTPUT 必须受支持。资源可以是相对于某个包（该包是源文件和类文件）指定的，并通过相对路径名从中取出。从不太严格的角度说，新文件的完全路径名将是 location、 pkg 和 relativeName 的串联。</p><h3 id="Messager"><a href="#Messager" class="headerlink" title="Messager"></a>Messager</h3><p>Messager类似于Android中的Log，用于协助注解处理器报告调试、警告和错误等信息。</p><p>一般来说我们在实现注解处理器时需要做好异常处理，因为可能存在不当的使用行为而我们没有考虑到，出现异常时通过Messager来提醒开发者这里有问题。</p><p>我们可以通过下列方法来打印信息。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void printMessage(Diagnostic.Kind kind, CharSequence msg)</td><td>打印指定种类的消息。</td></tr><tr><td>void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e)</td><td>在元素的位置上打印指定种类的消息。</td></tr><tr><td>void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a)</td><td>在已注解元素的注解镜像位置上打印指定种类的消息。</td></tr><tr><td>void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a, AnnotationValue v)</td><td>在已注解元素的注解镜像内部注解值的位置上打印指定种类的消息。</td></tr></tbody></table><h2 id="基本实现方法"><a href="#基本实现方法" class="headerlink" title="基本实现方法"></a>基本实现方法</h2><p>上面说了这么多，我们还是不知道如何去实现一个注解处理器，这里给出实现的步骤，具体的案例将在后一篇文章《最佳实践|注解处理器实现视图绑定》中详细的介绍。</p><h3 id="实现Processor接口"><a href="#实现Processor接口" class="headerlink" title="实现Processor接口"></a>实现Processor接口</h3><p>通过实现Processor接口可以自定义注解处理器，这里我们采用更简单的方法通过继承AbstractProcessor类实现自定义注解处理器。实现抽象方法process处理我们想要的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理注解</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，我们还需要指定支持的注解类型以及支持的Java版本通过重写getSupportedAnnotationTypes方法和getSupportedSourceVersion方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">class BuilderProcessor : AbstractProcessor() &#123;<br><br>    <span class="hljs-keyword">private</span> val supportedAnnotations =<br>        setOf(Builder::class.java, Required::class.java, Optional::class.java)<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>= SourceVersion.RELEASE_7<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>=<br>        supportedAnnotations.mapTo(HashSet&lt;String&gt;(), Class&lt;*&gt;::getName)<br><br>    <span class="hljs-function">override fun <span class="hljs-title">init</span><span class="hljs-params">(p0: ProcessingEnvironment)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(p0)<br>        <span class="hljs-comment">// 初始化一些工具类</span><br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">process</span><span class="hljs-params">(annotations: MutableSet&lt;out TypeElement&gt;, env: RoundEnvironment)</span>: Boolean </span>&#123;<br>        <span class="hljs-comment">// 处理注解</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册注解处理器"><a href="#注册注解处理器" class="headerlink" title="注册注解处理器"></a>注册注解处理器</h3><p>最后我们还需要将我们自定义的注解处理器进行注册。新建resources文件夹，目录下新建META-INF文件夹，目录下新建services文件夹，目录下新建<code>javax.annotation.processing.Processor</code>文件，然后将我们自定义注解处理器的全限定名写到此文件，例如我这里：</p><p><img src="/img/image-20210706142548844.png" alt="注册注解处理器"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.sukaidev</span><span class="hljs-selector-class">.viewbinding</span><span class="hljs-selector-class">.compiler</span><span class="hljs-selector-class">.BuilderProcessor</span><br></code></pre></td></tr></table></figure><p>到这里我们的注解处理器就能够正常使用了。</p><p>具体的案例请参考《最佳实践|注解处理器实现视图绑定》。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jcp.org/en/jsr/detail?id=269">JSR 269</a></li><li><a href="(https://book.douban.com/subject/35079283/)">《深入理解JVM字节码》</a></li><li><a href="https://juejin.cn/post/6963873016220663844">Android注解处理器APT技术探究</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650824004&idx=1&sn=a986f76389231290bdf4ef46d8341896&chksm=80b789dab7c000cc89d8ad9e47a58e9547049469659dc70936a95b45f992236d606e66e7a521&scene=38#wechat_redirect">详尽的Android编译时注解处理器教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（四）——ActivityManagerService</title>
    <link href="/2021/06/16/8695f279/"/>
    <url>/2021/06/16/8695f279/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意（WARNING）：本文所贴源码全部来自 Android API 29 Platform，即 Android 10.0。</p></blockquote><p> 在前面的几篇文章中，<strong>AMS</strong>或者<strong>ATMS</strong>绝对是出现频率最高的缩写之一。关于ActivityManagerService（下文简称AMS），我们或多或少都知道它的一点职责，例如四大组件的启动和管理、管理ANR状态、发起应用程序进程启动请求等。</p><p>AMS可以说是Android系统服务中最核心的一个服务，仅ActivityManagerService.java类中就有2万5千行代码，Android 10中对此类进行了拆解，其中Activity生命周期管理相关的代码都放到了一个新类ActivityTaskManager（下文简称ATMS）中。即便如此，Android 10中的AMS.java类依旧有1.9万行代码，可见AMS的重要性。</p><p>本文主要涉及AMS启动、获取、以及Activity栈管理。</p><h2 id="AMS启动过程"><a href="#AMS启动过程" class="headerlink" title="AMS启动过程"></a>AMS启动过程</h2><p>在<a href="/2021/05/14/7ca6484e/#SystemServer-main">Framework系列的第一篇文章</a>中，我们知道Android系统服务在<strong>SystemServer</strong>进程创建后，通过其run()方法来启动各类服务：</p><blockquote><p>frameworks/base/services/java/com/android/server/SystemServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    ···<br>      <br>    mSystemServiceManager = <span class="hljs-keyword">new</span> SystemServiceManager(mSystemContext);<br>    mSystemServiceManager.setStartInfo(mRuntimeRestart,<br>            mRuntimeStartElapsedTime, mRuntimeStartUptime);<br>    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<br>      <br>    <span class="hljs-keyword">try</span> &#123;<br>        t.traceBegin(<span class="hljs-string">&quot;StartServices&quot;</span>);<br>        <span class="hljs-comment">// 启动引导服务</span><br>        startBootstrapServices(t);<br>        <span class="hljs-comment">// 启动核心服务</span><br>        startCoreServices(t);<br>        <span class="hljs-comment">// 启动其他服务</span><br>        startOtherServices(t);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;******************************************&quot;</span>);<br>        Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;************ Failure starting system services&quot;</span>, ex);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        t.traceEnd(); <span class="hljs-comment">// StartServices</span><br>    &#125;<br>  <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>并且在文章中以ATMS为例介绍了服务的启动过程，本文将不会赘述ATMS服务的启动过程，下面来看看AMS是如何启动的。</p><h3 id="SystemServer-startBootstrapServices"><a href="#SystemServer-startBootstrapServices" class="headerlink" title="SystemServer#startBootstrapServices"></a>SystemServer#startBootstrapServices</h3><p>与ATMS服务类似，AMS服务同样在SystemServer中的<strong>startBootstrapServices</strong>方法中启动。</p><blockquote><p>frameworks/base/services/java/com/android/server/SystemServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBootstrapServices</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    ···<br>      <br>    Installer installer = mSystemServiceManager.startService(Installer.class);<br>      <br>    mActivityManagerService = ActivityManagerService.Lifecycle.startService(<br>            mSystemServiceManager, atm);<br>    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);<br>    mActivityManagerService.setInstaller(installer);<br>  <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ActivityManagerService-Lifecycle-startService"><a href="#ActivityManagerService-Lifecycle-startService" class="headerlink" title="ActivityManagerService#Lifecycle#startService"></a>ActivityManagerService#Lifecycle#startService</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p></blockquote><p>ActivityManagerService.Lifecycle.startService实际上也是通过SystemServiceManager来启动服务，这点与启动ATMS是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ActivityManagerService <span class="hljs-title">startService</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        SystemServiceManager ssm, ActivityTaskManagerService atm)</span> </span>&#123;<br>    sAtm = atm;<br>    <span class="hljs-keyword">return</span> ssm.startService(ActivityManagerService.Lifecycle.class).getService();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SystemServiceManager-startService"><a href="#SystemServiceManager-startService" class="headerlink" title="SystemServiceManager#startService"></a>SystemServiceManager#startService</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> SystemService service)</span> </span>&#123;<br>    <span class="hljs-comment">// Register it.</span><br>    mServices.add(service);<br>    <span class="hljs-comment">// Start it.</span><br>    <span class="hljs-keyword">long</span> time = SystemClock.elapsedRealtime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        service.onStart();<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failed to start service &quot;</span> + service.getClass().getName()<br>                + <span class="hljs-string">&quot;: onStart threw an exception&quot;</span>, ex);<br>    &#125;<br>    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, <span class="hljs-string">&quot;onStart&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SystemServiceManager的startService接收SystemService对象作为参数，由于AMS本身是继承自AIDL中生成类Stub的，无法继承SystemService，因此其提供一个内部类Lifecycle来继承SystemService。</p><p>可以看到与ATMS启动过程是一致的，都是调用SystemServiceManager中同一个startService重载方法来启动服务，最终都是会回调Service类中Lifecycle的onStart方法。</p><p>这个过程中将通过反射来创建Lifecycle对象，那么AMS的对象又是什么时候创建的呢？</p><p>在AMS.Lifecycle类的构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Lifecycle</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(context);<br>    mService = <span class="hljs-keyword">new</span> ActivityManagerService(context, sAtm);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到构造Lifecycle的同时创建了AMS的对象，下面关注下AMS的初始化都干了什么。</p><h3 id="ActivityManagerService的初始化"><a href="#ActivityManagerService的初始化" class="headerlink" title="ActivityManagerService的初始化"></a>ActivityManagerService的初始化</h3><p>AMS的构造方法代码量比较多，这里删减了一部分。</p><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ActivityManagerService</span><span class="hljs-params">(Context systemContext, ActivityTaskManagerService atm)</span> </span>&#123;<br>    LockGuard.installLock(<span class="hljs-keyword">this</span>, LockGuard.INDEX_ACTIVITY);<br>    mInjector = <span class="hljs-keyword">new</span> Injector();<br>  <br>    <span class="hljs-comment">// 系统上下文</span><br>    mContext = systemContext;<br><br>    mFactoryTest = FactoryTest.getMode();<br>  <br>    <span class="hljs-comment">// 标记当前进程的ActivityThread，当前进程也为AMS需要管理的一部分</span><br>    mSystemThread = ActivityThread.currentActivityThread();<br>    mUiContext = mSystemThread.getSystemUiContext();<br><br>    Slog.i(TAG, <span class="hljs-string">&quot;Memory class: &quot;</span> + ActivityManager.staticGetMemoryClass());<br><br>    <span class="hljs-comment">// 创建名为”ActivityManager“的线程，并指定优先级为前台</span><br>    <span class="hljs-comment">// 这条线程是AMS主要工作线程</span><br>    mHandlerThread = <span class="hljs-keyword">new</span> ServiceThread(TAG,<br>            THREAD_PRIORITY_FOREGROUND, <span class="hljs-keyword">false</span> <span class="hljs-comment">/*allowIo*/</span>);<br>    mHandlerThread.start();<br>    mHandler = <span class="hljs-keyword">new</span> MainHandler(mHandlerThread.getLooper());<br>    mUiHandler = mInjector.getUiHandler(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 创建名为”ActivityManager:procStart“的线程，并指定优先级为前台</span><br>    <span class="hljs-comment">// 这条线程处理进程启动相关</span><br>    mProcStartHandlerThread = <span class="hljs-keyword">new</span> ServiceThread(TAG + <span class="hljs-string">&quot;:procStart&quot;</span>,<br>            THREAD_PRIORITY_FOREGROUND, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* allowIo */</span>);<br>    mProcStartHandlerThread.start();<br>    mProcStartHandler = <span class="hljs-keyword">new</span> Handler(mProcStartHandlerThread.getLooper());<br><br>    <span class="hljs-comment">// 初始化一些常量</span><br>    mConstants = <span class="hljs-keyword">new</span> ActivityManagerConstants(mContext, <span class="hljs-keyword">this</span>, mHandler);<br>    <span class="hljs-keyword">final</span> ActiveUids activeUids = <span class="hljs-keyword">new</span> ActiveUids(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* postChangesToAtm */</span>);<br>  <br>    <span class="hljs-comment">// mProcessList为ProcessList对象，之前文章有说过是管理进程相关的</span><br>    mProcessList.init(<span class="hljs-keyword">this</span>, activeUids);<br>  <br>    <span class="hljs-comment">// 低内存检测，内部通过一个线程接收内核PSI机制epoll过来的低内存通知</span><br>    mLowMemDetector = <span class="hljs-keyword">new</span> LowMemDetector(<span class="hljs-keyword">this</span>);<br>  <br>    <span class="hljs-comment">// 进程优先级（oom_adj）相关的类</span><br>    mOomAdjuster = <span class="hljs-keyword">new</span> OomAdjuster(<span class="hljs-keyword">this</span>, mProcessList, activeUids);<br><br>    <span class="hljs-comment">// 广播政策相关的参数</span><br>    <span class="hljs-keyword">final</span> BroadcastConstants foreConstants = <span class="hljs-keyword">new</span> BroadcastConstants(<br>            Settings.Global.BROADCAST_FG_CONSTANTS);<br>  <br>    <span class="hljs-comment">// 前台广播  10秒</span><br>    foreConstants.TIMEOUT = BROADCAST_FG_TIMEOUT;<br><br>    <span class="hljs-keyword">final</span> BroadcastConstants backConstants = <span class="hljs-keyword">new</span> BroadcastConstants(<br>            Settings.Global.BROADCAST_BG_CONSTANTS);<br>  <br>    <span class="hljs-comment">// 后台广播  60秒</span><br>    backConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;<br><br>    <span class="hljs-keyword">final</span> BroadcastConstants offloadConstants = <span class="hljs-keyword">new</span> BroadcastConstants(<br>            Settings.Global.BROADCAST_OFFLOAD_CONSTANTS);<br>  <br>    <span class="hljs-comment">// 延时广播 60秒</span><br>    offloadConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;<br>    <span class="hljs-comment">// by default, no &quot;slow&quot; policy in this queue</span><br>    offloadConstants.SLOW_TIME = Integer.MAX_VALUE;<br><br>    mEnableOffloadQueue = SystemProperties.getBoolean(<br>            <span class="hljs-string">&quot;persist.device_config.activity_manager_native_boot.offload_queue_enabled&quot;</span>, <span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-comment">// 为三种广播创建对应的队列</span><br>    mFgBroadcastQueue = <span class="hljs-keyword">new</span> BroadcastQueue(<span class="hljs-keyword">this</span>, mHandler,<br>            <span class="hljs-string">&quot;foreground&quot;</span>, foreConstants, <span class="hljs-keyword">false</span>);<br>    mBgBroadcastQueue = <span class="hljs-keyword">new</span> BroadcastQueue(<span class="hljs-keyword">this</span>, mHandler,<br>            <span class="hljs-string">&quot;background&quot;</span>, backConstants, <span class="hljs-keyword">true</span>);<br>    mOffloadBroadcastQueue = <span class="hljs-keyword">new</span> BroadcastQueue(<span class="hljs-keyword">this</span>, mHandler,<br>            <span class="hljs-string">&quot;offload&quot;</span>, offloadConstants, <span class="hljs-keyword">true</span>);<br>    mBroadcastQueues[<span class="hljs-number">0</span>] = mFgBroadcastQueue;<br>    mBroadcastQueues[<span class="hljs-number">1</span>] = mBgBroadcastQueue;<br>    mBroadcastQueues[<span class="hljs-number">2</span>] = mOffloadBroadcastQueue;<br><br>    <span class="hljs-comment">// 管理Service组件</span><br>    mServices = <span class="hljs-keyword">new</span> ActiveServices(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 管理ContentProvider组件</span><br>    mProviderMap = <span class="hljs-keyword">new</span> ProviderMap(<span class="hljs-keyword">this</span>);<br>    mPackageWatchdog = PackageWatchdog.getInstance(mUiContext);<br>    mAppErrors = <span class="hljs-keyword">new</span> AppErrors(mUiContext, <span class="hljs-keyword">this</span>, mPackageWatchdog);<br><br>    <span class="hljs-comment">// 创建/data/system 目录</span><br>    <span class="hljs-keyword">final</span> File systemDir = SystemServiceManager.ensureSystemDir();<br><br>    <span class="hljs-comment">// 电池状态统计服务的初始化</span><br>    mBatteryStatsService = <span class="hljs-keyword">new</span> BatteryStatsService(systemContext, systemDir,<br>            BackgroundThread.get().getHandler());<br>    mBatteryStatsService.getActiveStatistics().readLocked();<br>    mBatteryStatsService.scheduleWriteToDisk();<br>    mOnBattery = DEBUG_POWER ? <span class="hljs-keyword">true</span><br>            : mBatteryStatsService.getActiveStatistics().getIsOnBattery();<br>    mBatteryStatsService.getActiveStatistics().setCallback(<span class="hljs-keyword">this</span>);<br>    mOomAdjProfiler.batteryPowerChanged(mOnBattery);<br><br>    <span class="hljs-comment">// 进程状态统计服务初始化</span><br>    mProcessStats = <span class="hljs-keyword">new</span> ProcessStatsService(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> File(systemDir, <span class="hljs-string">&quot;procstats&quot;</span>));<br><br>    ···<br>    <br>    <span class="hljs-comment">// 初始化ATMS</span><br>    mActivityTaskManager = atm;<br>    mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController,<br>            DisplayThread.get().getLooper());<br>    mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);<br><br>    ···<br>      <br>    <span class="hljs-comment">// HiddenApi黑名单列表</span><br>    mHiddenApiBlacklist = <span class="hljs-keyword">new</span> HiddenApiSettings(mHandler, mContext);<br>  <br>    <span class="hljs-comment">// 监听AMS和其工作线程的状态，例如阻塞、死锁等</span><br>    Watchdog.getInstance().addMonitor(<span class="hljs-keyword">this</span>);<br>    Watchdog.getInstance().addThread(mHandler);<br><br>    <span class="hljs-comment">// 调整优先级</span><br>    updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE);<br>  <br>    ···<br>      <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到AMS首先创建了两条线程，其中一条作为自己的主要工作线程，接着围绕四大组件的管理做初始化工作。</p><p>对于<strong>Activity</strong>，Android 10中对于它的管理工作全部转移到了<strong>ATMS</strong>中，因此这里调用了ATMS的initialize方法初始化ATMS。</p><p>对于<strong>Service</strong>，创建了ActiveServices类来管理。在ActiveServices中我们可以看到Service在System Server中对应的实体类为<strong>Service Record</strong>，并且可以看到Service的超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通服务超时时间  20秒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_TIMEOUT = <span class="hljs-number">20</span>*<span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// 后台服务超时时间  200秒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 前台服务超时时间  10秒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_START_FOREGROUND_TIMEOUT = <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>对于<strong>ContentProvider</strong>，创建了ProviderMap类来管理，在System Server中对应数据结构为<strong>ContentProviderRecord</strong>。</p><p>对于广播<strong>Broadcast</strong>，创建了三个广播队列来分别管理三种广播类型。</p><p>除了四大组件，初始中还涉及一些性能相关，例如：</p><ul><li>初始化ProcessList</li><li>创建LowMemDetector用于检测低内存</li><li>创建OomAdjuster用于调整进程的优先级等级</li><li>创建BatteryStatsService和ProcessStatsService用于管理电量状态和进程状态</li><li>创建HiddenApiSettings用于管理一些需要对开发者隐藏的HiddenApi</li></ul><p>到这里AMS已经初始化完毕，接下来我们继续来看AMS的启动。</p><p>AMS.Lifecycle类的onStart方法仅仅是调用了ActivityManagerService#start方法，我们来看看AMS的start方法做了什么。</p><h3 id="ActivityManagerService-start"><a href="#ActivityManagerService-start" class="headerlink" title="ActivityManagerService#start"></a>ActivityManagerService#start</h3><p>AMS的start方法被调用标志着服务已经启动。</p><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    ··· <br>      <br>    <span class="hljs-comment">// 将LocalService添加到本地服务列表</span><br>    LocalServices.addService(ActivityManagerInternal.class, <span class="hljs-keyword">new</span> LocalService());<br>    <span class="hljs-comment">// 通知ATMS，AMS已经启动，可以获取到AMS</span><br>    mActivityTaskManager.onActivityManagerInternalAdded();<br>    <span class="hljs-comment">// 通知UGM，AMS已经启动，可以获取到AMS</span><br>    mUgmInternal.onActivityManagerInternalAdded();<br>    <span class="hljs-comment">// 通知PendingIntentController，AMS已经启动，可以获取到AMS</span><br>    mPendingIntentController.onActivityManagerInternalAdded();<br>    <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法首先将AMS的LocalService对象添加到本地服务列表中，然后通知其他需要第一时间获取AMS的服务已经可以获取到AMS。</p><h2 id="获取AMS服务"><a href="#获取AMS服务" class="headerlink" title="获取AMS服务"></a>获取AMS服务</h2><p>上节我们讲述了AMS服务的启动过程，那么如何获取AMS服务呢？</p><p>实际上在<a href="/2021/05/22/4cb0a496/#Instrumentation-execStartActivity">Activity启动流程</a>一文中，我们已经知道了如何去获取ATMS服务。</p><p>而获取AMS服务跟ATMS是类似的，在日常开发中，我们通过context中定义好的方法来获取ActivityManager对象，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> am = context.getSystemService(Context.ACTIVITY_SERVICE) <span class="hljs-keyword">as</span> ActivityManager<br></code></pre></td></tr></table></figure><p>ActivityManager是一个和AMS相关联的类，它主要对运行中的Activity进行管理，这些管理工作并不是由ActivityManager来处理的，而是交由AMS来处理。</p><p>其内部封装了获取AMS的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();<br>&#125;<br><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =<br>        <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);<br>                <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);<br>                <span class="hljs-keyword">return</span> am;<br>            &#125;<br>        &#125;;<br></code></pre></td></tr></table></figure><p>可以看到虽然getService方法是public的，但是用@hide标记了，所以我们是无法直接调用到的，不过这不妨碍我们看源码。</p><p>重点关注这一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);<br></code></pre></td></tr></table></figure><p>Android 10中所有系统服务都通过AIDL接口来获取，通过Stub类的asInterface根据进程的不同获取本地对象或者远程服务的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((obj == <span class="hljs-keyword">null</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>  android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);<br>  <span class="hljs-keyword">if</span> (((iin != <span class="hljs-keyword">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> IActivityManager))) &#123;<br>    <span class="hljs-keyword">return</span> ((IActivityManager) iin);<br>  &#125;<br>  <span class="hljs-comment">// 在Android10以前是ActivityManagerProxy</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IActivityManager.Stub.Proxy(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里采用了静态代理模式将远程服务AMS包装成了Proxy类，所有操作就通过这个Proxy类来完成。</p><blockquote><p>注意：在Android10以前获取服务不是通过直接通过AIDL接口的，而是通过ActivityManagerNative来转发，本质还是通过AIDL生成类Stub来获取。</p></blockquote><h2 id="AMS中重要的数据结构"><a href="#AMS中重要的数据结构" class="headerlink" title="AMS中重要的数据结构"></a>AMS中重要的数据结构</h2><p>在<a href="https://sukaidev.github.io/2021/05/22/4cb0a496/">Activity启动</a>的一文中简单介绍了关于Activity的几个重要的数据结构，包括<strong>ActivityRecord</strong>、<strong>TaskRecord</strong>、<strong>ActivityStack</strong>等，这一节我们来重点了解一下这几个数据结构。</p><h3 id="解析ActivityRecord"><a href="#解析ActivityRecord" class="headerlink" title="解析ActivityRecord"></a>解析ActivityRecord</h3><p>我们之前提到ActivityRecord是SystemServer中用来描述Activity的数据类型，其中存储了Activity的所有信息。</p><p>ActivityRecord对象在ActivityStarter中创建：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="hljs-function"><span class="hljs-params">         String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">         IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">         IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">         String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">         SafeActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span></span><br><span class="hljs-function"><span class="hljs-params">         TaskRecord inTask, <span class="hljs-keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="hljs-function"><span class="hljs-params">         PendingIntentRecord originatingPendingIntent, <span class="hljs-keyword">boolean</span> allowBackgroundActivityStart)</span> </span>&#123;<br>     ···<br>     <span class="hljs-comment">// 此处创建了一个ActivityRecord对象</span><br>     ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,<br>             callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),<br>             resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,<br>             mSupervisor, checkedOptions, sourceRecord);<br>     ···<br> &#125;<br></code></pre></td></tr></table></figure><p>可以看到构造方法中传入的参数很多，其中有一些比较重要，列举在下面表格中。</p><table><thead><tr><th align="center">名    称</th><th align="center">类    型</th><th align="center">说    明</th></tr></thead><tbody><tr><td align="center">mAtmService</td><td align="center">ActivityTaskManagerService</td><td align="center">ATMS的引用</td></tr><tr><td align="center">appToken</td><td align="center">Token（IBinder）</td><td align="center">IBinder对象，用于WMS关联Window与Activity</td></tr><tr><td align="center">launchedFromPackage</td><td align="center">String</td><td align="center">启动Activity的包名</td></tr><tr><td align="center">taskAffinity</td><td align="center">String</td><td align="center">Activity希望归属的栈</td></tr><tr><td align="center">intent</td><td align="center">Intent</td><td align="center">当前启动Activity的Intent对象</td></tr><tr><td align="center">aInfo</td><td align="center">ActivityInfo</td><td align="center">由AndroidManifest解析出来的Activity信息，包括launchMode、icon、theme、taskAffinity等</td></tr><tr><td align="center">task</td><td align="center">TaskRecord</td><td align="center">当前所属TaskRecord对象</td></tr><tr><td align="center">appInfo</td><td align="center">ApplicationInfo</td><td align="center">当前所属Application信息</td></tr><tr><td align="center">state</td><td align="center">ActivityState</td><td align="center">当前 Activity 的状态</td></tr><tr><td align="center">supervisor</td><td align="center">ActivityStackSupervisor</td><td align="center">Android中管理Display与ActivityStack的类</td></tr><tr><td align="center">icon</td><td align="center">int</td><td align="center">Activity的图标资源标识符，随ActivityInfo传入</td></tr><tr><td align="center">theme</td><td align="center">int</td><td align="center">Activity的主题资源标识符，随ActivityInfo传入</td></tr></tbody></table><p>从上表我们可以看出ActivityRecord内部存储了由AndroidManifest.xml文件解析出来的Activity配置信息，同时持有了ATMS的引用、Activity当前状态、所属Task等信息。</p><p>刚创建时ActivityRecord对象并没有与TaskRecord、ActivityStackSupervisor关联，因为此时并不能确定此Activity所属的任务栈，后续启动Activity的过程中需要确定Activity所属的任务栈，并讲其ActivityRecord对象与TaskRecord相关联。</p><h3 id="解析TaskRecord"><a href="#解析TaskRecord" class="headerlink" title="解析TaskRecord"></a>解析TaskRecord</h3><p>TaskRecord用来描述一个Activity任务栈，内部也有很多成员变量，同样的挑一部分变量来展示，如下表所示。</p><table><thead><tr><th align="center">名    称</th><th align="center">类    型</th><th align="center">说    明</th></tr></thead><tbody><tr><td align="center">userId</td><td align="center">int</td><td align="center">当前进程uid</td></tr><tr><td align="center">taskId</td><td align="center">int</td><td align="center">此任务栈唯一的标识</td></tr><tr><td align="center">affinity</td><td align="center">String</td><td align="center">此任务栈的TaskAffinity</td></tr><tr><td align="center">intent</td><td align="center">Intent</td><td align="center">启动此Task的Intent</td></tr><tr><td align="center">mActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">位于此Task中的所有Activity的ActivityRecord对象</td></tr><tr><td align="center">mStack</td><td align="center">ActivityStack</td><td align="center">当前所处的Stack</td></tr><tr><td align="center">mService</td><td align="center">ActivityTaskManagerService</td><td align="center">ATMS的引用</td></tr></tbody></table><p>可以看到，TaskRecord内部存储了任务栈的所有信息，包括任务栈的唯一标识符、任务栈的倾向性、任务栈中的ActivityRecord、ActivityStack和ATMS引用等。</p><p>从mActivities集合我们知道TaskRecord与ActivityRecord是包含与被包含的关系，这里TaskRecord又持有一个ActivityStack的引用。</p><p>通常我们在开发App中必然会用到启动模式和Flag，其中<strong>singlelnstance</strong>启动模式或者<strong>FLAG_ACTIVITY_NEW_TASK</strong>都可以在启动Activity时创建一个新的任务栈。而一个任务栈就对应着一个TaskRecord对象，那么存在一个问题就是如何管理这么多TaskRecord？ActivityStack就是TaskRecord的管理者，下面我们来看看ActivityStack。</p><h3 id="解析ActivityStack"><a href="#解析ActivityStack" class="headerlink" title="解析ActivityStack"></a>解析ActivityStack</h3><p>ActivityStack从名字上看我们会认为它就是管理Activity的任务栈，实际上通过上节我们知道TaskRecord才是任务栈，而TaskRecord持有ActivityStack，这是否意味着任务栈之上还有一个“活动栈”？我们来看看源码。</p><p>ActivityStack中有几个重要的属性：</p><table><thead><tr><th align="center">名  称</th><th align="center">类  型</th><th align="center">说  明</th></tr></thead><tbody><tr><td align="center">mStackId</td><td align="center">int</td><td align="center">当前Stack唯一Id</td></tr><tr><td align="center">mDisplayId</td><td align="center">int</td><td align="center">当前绑定的Display唯一Id</td></tr><tr><td align="center">mService</td><td align="center">ActivityTaskManagerService</td><td align="center">ATMS的引用</td></tr><tr><td align="center">mWindowManager</td><td align="center">WindowManagerService</td><td align="center">WMS的引用</td></tr><tr><td align="center">STACK_VISIBILITY_VISIBLE</td><td align="center">int</td><td align="center">当前Stack位于栈顶且可见</td></tr><tr><td align="center">STACK_VISIBILITY_VISIBLE-_BEHIND_TRANSLUCENT</td><td align="center">int</td><td align="center">当前Stack可见但上面还有其他的透明Stack</td></tr><tr><td align="center">STACK_VISIBILITY_INVISIBLE</td><td align="center">int</td><td align="center">当前Stack完全不可见</td></tr><tr><td align="center">mTaskHistory</td><td align="center">ArrayList&lt;TaskRecord&gt;</td><td align="center">当前Stack管理的所有任务栈</td></tr><tr><td align="center">mLRUActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">当前Stack内的所有Activity</td></tr><tr><td align="center">mPausingActivity</td><td align="center">ActivityRecord</td><td align="center">当前Stack中正在暂停的Activity</td></tr><tr><td align="center">mLastPausedActivity</td><td align="center">ActivityRecord</td><td align="center">最近暂停的Activity</td></tr><tr><td align="center">mLastNoHistoryActivity</td><td align="center">ActivityRecord</td><td align="center">最近不添加到任务栈中的Activity</td></tr><tr><td align="center">mResumedActivity</td><td align="center">ActivityRecord</td><td align="center">当前栈顶可见的Activity</td></tr><tr><td align="center">mStackSupervisor</td><td align="center">ActivityStackSupervisor</td><td align="center">ActivityStackSupervisor引用</td></tr><tr><td align="center">mRootActivityContainer</td><td align="center">RootActivityContainer</td><td align="center">RootActivityContainer的引</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>可以看到ActivityStack实际上是作为Activity的管理类存在，其内部维护了Activity 的所有状态、特殊状态的Activity以及和Activity相关的列表等数据。</p><p>ActivityStack中还定义了一个内部类<strong>ActivityState</strong>，其中定义了Activity所处的所有状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ActivityState</span> </span>&#123;<br>    INITIALIZING,<br>    RESUMED,<br>    PAUSING,<br>    PAUSED,<br>    STOPPING,<br>    STOPPED,<br>    FINISHING,<br>    DESTROYING,<br>    DESTROYED,<br>    RESTARTING_PROCESS<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityStack是由ActivityStackSupervisor来进行管理的，可以看到ActivityStack持有ActivityStackSupervisor的引用。ActivityStackSupervisor引用在ActivityStack的构造器中注入，经过代码搜索，发现ActivityStackSupervisor在<strong>ATMS</strong>中的initialize方法中创建：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(IntentFirewall intentFirewall, PendingIntentController intentController,</span></span><br><span class="hljs-function"><span class="hljs-params">        Looper looper)</span> </span>&#123;<br>  <br>    ···<br>      <br>    mStackSupervisor = createStackSupervisor();<br>  <br>    ···<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> ActivityStackSupervisor <span class="hljs-title">createStackSupervisor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ActivityStackSupervisor supervisor = <span class="hljs-keyword">new</span> ActivityStackSupervisor(<span class="hljs-keyword">this</span>, mH.getLooper());<br>    supervisor.initialize();<br>    <span class="hljs-keyword">return</span> supervisor;<br>&#125;<br></code></pre></td></tr></table></figure><p>initialize方法在<strong>AMS</strong>的构造方法中被调用，也就是说AMS实例与ActivityStackSupervisor实例是一一对应的，而系统中只会有一个AMS实例，自然也只会存在于一个ActivityStackSupervisor实例。</p><h3 id="解析ActivityStackSupervisor"><a href="#解析ActivityStackSupervisor" class="headerlink" title="解析ActivityStackSupervisor"></a>解析ActivityStackSupervisor</h3><p><strong>ActivityStackSupervisor</strong>是Android系统中Activity的终极大管家，它本身不直接持有ActivityStack的引用，而是通过持有<strong>RootActivityContainer</strong>间接持有<strong>ActivityDisplay</strong>引用，进而间接管理<strong>ActivityStack</strong>。</p><p>这里涉及到的类比较多，简单介绍一下：</p><ul><li><strong>RootActivityContainer</strong>：Activity容器的根节点，其内部持有mActivityDisplays集合表示系统中所有的ActivityDisplay，Launcher应用的解析、启动都由RootActivityContainer来完成，在<a href="https://sukaidev.github.io/2021/05/22/4cb0a496/">Activity启动</a>一文中我们知道通过它可以获取当前持有焦点的ActivityStack和当前栈顶的ActivityRecord对象。</li><li><strong>Display</strong>：Android屏幕的抽象，大部分情况下我们的手机只会有一个屏幕，因而只会有一个Display对象。</li><li><strong>ActivityDisplay</strong>：内部持有mStacks集合，负责管理当前屏幕内所有的ActivityStack。它由Display对象创建，且它们是一一对应关系，所以我们可以认为ActivityDisplay相当于一个屏幕。</li></ul><p>这里同样的列出ActivityStackSupervisor中的重要属性，如下表所示：</p><table><thead><tr><th align="center">名  称</th><th align="center">类  型</th><th align="center">说  明</th></tr></thead><tbody><tr><td align="center">mService</td><td align="center">ActivityTaskManagerService</td><td align="center">ATMS的引用</td></tr><tr><td align="center">mRootActivityContainer</td><td align="center">RootActivityContainer</td><td align="center">RootActivityContainer的引用</td></tr><tr><td align="center">mRecentTasks</td><td align="center">RecentTasks</td><td align="center">最近任务列表</td></tr><tr><td align="center">mRunningTasks</td><td align="center">RunningTasks</td><td align="center">当前运行任务的抽象，可以协助处理运行中的任务</td></tr><tr><td align="center">mWindowManager</td><td align="center">WindowManagerService</td><td align="center">WMS的引用</td></tr><tr><td align="center">mWaitingForActivityVisible</td><td align="center">ArrayList&lt;WaitInfo&gt;</td><td align="center">等待Activity显示的进程列表</td></tr><tr><td align="center">mWaitingActivityLaunched</td><td align="center">ArrayList&lt;WaitResult&gt;</td><td align="center">等待Activity启动的进程列表</td></tr><tr><td align="center">mStoppingActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">处于Stopping状态的Activity列表</td></tr><tr><td align="center">mFinishingActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">处于Finishing状态的Activity列表</td></tr><tr><td align="center">mGoingToSleepActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">准备休眠的Activity列表</td></tr><tr><td align="center">mMultiWindowMode-ChangedActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">多窗口模式中的Activity列表</td></tr><tr><td align="center">mPipModeChangedActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">画中画模式中的Activity列表</td></tr><tr><td align="center">mNoAnimActivities</td><td align="center">ArrayList&lt;ActivityRecord&gt;</td><td align="center">不考虑转场动画的 Activity列表</td></tr><tr><td align="center">mTopResumedActivity</td><td align="center">ActivityRecord</td><td align="center">系统中最顶部可见的Activity</td></tr></tbody></table><p>可以看到与ActivityStack维护栈内的特殊Activity类似，ActivityStackSupervisor负责维护整个系统中的所有特殊状态的Activity，同时”最近任务“功能也跟它有关。</p><p>下面我们再来看下ActivityDisplay。</p><h3 id="解析ActivityDisplay"><a href="#解析ActivityDisplay" class="headerlink" title="解析ActivityDisplay"></a>解析ActivityDisplay</h3><p>ActivityDisplay是Android系统中屏幕的抽象，对于手机来说，一般情况下系统中只会有一个ActivityDisplay的实例。</p><p>ActivityDisplay负责管理ActivityStack，其内部持有多个ActivityStack对象，其中包括一些特殊的ActivityStack例如Launcher对应的Stack、最近任务对应的Stack等。下面我们来看看其中的重要属性。</p><table><thead><tr><th align="center">名  称</th><th align="center">类  型</th><th align="center">说  明</th></tr></thead><tbody><tr><td align="center">mDisplayId</td><td align="center">int</td><td align="center">当前绑定的Display唯一ID</td></tr><tr><td align="center">mDisplay</td><td align="center">Display</td><td align="center">当前绑定的Display</td></tr><tr><td align="center">mStacks</td><td align="center">ArrayList&lt;ActivityStack&gt;</td><td align="center">当前Display中所有的ActivityStack</td></tr><tr><td align="center">mPreferredToFocusableStack</td><td align="center">ActivityStack</td><td align="center">当前聚集、可见、顶部的ActivityStack</td></tr><tr><td align="center">mLastFocusedStack</td><td align="center">ActivityStack</td><td align="center">最近聚焦的ActivityStack，如果栈顶的ActivityStack已经resume的话（mPreferredToFocusableStack不为空），与mPreferredToFocusableStack为同一。</td></tr><tr><td align="center">mHomeStack</td><td align="center">ActivityStack</td><td align="center">Launcher应用的ActivityStack</td></tr><tr><td align="center">mRecentsStack</td><td align="center">ActivityStack</td><td align="center">最近任务的ActivityStack</td></tr><tr><td align="center">mPinnedStack</td><td align="center">ActivityStack</td><td align="center">多窗口下的ActivityStack</td></tr><tr><td align="center">mSplitScreenPrimaryStack</td><td align="center">ActivityStack</td><td align="center">分屏模式下的主ActivityStack</td></tr><tr><td align="center">mService</td><td align="center">ActivityTaskManagerService</td><td align="center">ATMS的引用</td></tr><tr><td align="center">mRootActivityContainer</td><td align="center">RootActivityContainer</td><td align="center">RootActivityContainer的引用</td></tr></tbody></table><p>可以看到ActivityDisplay除了维护Launcher应用所处的ActivityStack之外，还维护了一系列特殊的ActivityStack。</p><h2 id="Activity栈管理"><a href="#Activity栈管理" class="headerlink" title="Activity栈管理"></a>Activity栈管理</h2><p>我们平时开发时经常有需求将某些Activity置于单独的任务栈中，例如手机的拨号界面，我们希望它只有一个实例并且处于单独的任务栈，因此会使用singleInstance的启动模式来启动它。</p><p>那么Android系统是如何管理这些任务栈的呢？下面我们就来理一理Activity的栈管理机制。</p><h3 id="Activity任务栈模型"><a href="#Activity任务栈模型" class="headerlink" title="Activity任务栈模型"></a>Activity任务栈模型</h3><p>Activity任务栈并不是凭空想象出来的，它是由多种数据结构共同组合而成。</p><p>上一节我们介绍了许多数据结构，其中ActivityRecord、TaskRecord和ActivityStack共同组成了下图的Activity任务栈模型。</p><p><img src="/img/image-20210624214422750.png" alt="Activity任务栈模型"></p><p>其中ActivityRecord用来记录一个Activity的所有信息，TaskRecord用来管理栈中的ActivityRecord，它就是我们常说的任务栈，其中包含了多个ActivityRecord，一个App中会有多个任务栈。ActivityStack又包含了一个或者多个TaskRecord，它是TaskRecord的管理者。</p><p>Activity栈管理是建立在Activity任务栈模型之上的，有了栈管理我们可以对Activity进行缓存复用，使得一个App可以有多个任务栈而不至于返回栈混乱，必要的时候我们还可以在启动其他Activity时将其任务栈置于当前App的顶部而达到跨进程的效果。</p><p>举个例子，我们可以在App中通过隐式Intent的方式调起拨号界面，如下图所示。</p><p><img src="/img/image-20210626091147254.png" alt="调起系统拨号"></p><p>系统的拨号App的launchMode通常是singleInstance，使用singleInstance启动的Activity会有一个单独的任务栈，并且任务栈中只有一个Activity。当我们通过隐式Intent启动拨号Activity时，拨号界面对应的Task将会覆盖到当前App任务栈的栈顶，这使得我们可以进行跨任务栈的操作。</p><p>为了更灵活的进行栈管理，Android系统中提供了很多配置，包括LaunchMode、Intent Flag、taskAffinity、allowTaskReparenting等，下面来重点了解一下这几个机制。</p><h3 id="Launch-Mode"><a href="#Launch-Mode" class="headerlink" title="Launch Mode"></a>Launch Mode</h3><p>Launch Mode大家都不陌生，用于设定Activity的启动模式，无论是哪种启动模式所启动的Activity都会位于当前Activity栈的栈顶，Android中有4种LaunchMode。</p><ul><li>standard：默认启动模式，每次启动Activity都会创建一个新的Activity实例。</li><li>singleTop：如果要启动的Activity已经存在栈顶，则不会重新创建此Activity实例，而是会回调其onNewIntent方法将新的Intent传递。如果不在栈顶则会重新创建Activity实例。</li><li>singleTask：如果要启动的Activity已经存在并且位于其taskAffinity对应的Task中，则不会重新创建此Activity，而是将此Task中位于此Activity上方的所有Activity出栈使得要启动的Activity重新回到栈顶，并且回调其onNewIntent方法。如果Activity设置的taskAffinity对应的Task中没有此Activity实例或者此Task不存在的话，会创建Activity实例。此种模式下启动的Activity为全局单例。</li><li>singleInstance：与singleTask类似，区别是singleInstance启动的Activity会独占一个任务栈，因为不会有清顶问题。此种模式下启动的Activity同样也是全局单例。</li></ul><p>关于启动模式这块其实都是老生常谈了，即时是刚入门的开发者也熟悉这些启动模式的特性，不过在本篇文章中我们希望能在Activity栈管理的角度来更加深入的了解启动模式。</p><h4 id="standard模式的多实例特性"><a href="#standard模式的多实例特性" class="headerlink" title="standard模式的多实例特性"></a>standard模式的多实例特性</h4><p>上面我们提到standard启动模式的特性是“每次启动Activity都会创建一个新的Activity实例”，对于这个启动模式，网络上大部分的文章都是局限于单一的任务栈来分析。实际上我们应该更着重于其在Task与Task之间的逻辑。</p><p>举个例子，当我们在短信App中点击一个电话号码的超链接，选择新建联系人时，就会以standard模式启动新建联系人的Activity，此Activity由通信录App提供。</p><p>由于我们是使用standard模式启动的Activity，因此会新建一个Activity实例，并添加到当前短信App栈顶的任务栈中，如下图所示。</p><p><img src="/img/image-20210627223003476.png" alt="standard模式"></p><p>这种情况下启动的新建联系人Activity将会直接加入到当前任务栈的栈顶，此时该Activity只与短信App的任务栈Task具有相关性，并不会影响到原有的通讯录App任务栈。</p><p>当我们点击返回按键时，新建联系人Activity出栈，回到短信详情页，我们依旧处于短信App任务栈中。</p><h4 id="singleTask任务栈切换"><a href="#singleTask任务栈切换" class="headerlink" title="singleTask任务栈切换"></a>singleTask任务栈切换</h4><p>不同于standard模式启动的Activity会直接加入到当前任务栈栈顶，singleTask模式启动的Activity只会存在于特定任务栈中，这个任务栈与其设置的taskAffinity有关。</p><p>对于没有指定taskAffinity的Activity，其taskAffinity等于当前包名，这意味着如果我们在以singleTask启动一个当前App内的未指定taskAffinity的Activity，将不会发生任务栈的切换。</p><p>这里我们主要讨论启动其它App中的，或者指定了taskAffinity的Activity，这种情况下启动的Activity没有办法入栈的话，如何让它显示在栈顶呢？</p><p>只需要把此Activity所在的任务栈整体移到前台即可。不过此任务栈的栈顶可能并不是我们启动的Activity，这种时候就会进行一次“清顶”操作，将要启动的Activity上方所有Activity出栈，并且不会重建当前Activity。</p><p><img src="/img/image-20210626231520598.png" alt="singleTask模式"></p><p>上图展示了一次singleTask模式启动Activity导致的任务栈切换，实际操作中会有较为明显的<strong>Task切换动画</strong>，而不是Activity切换动画。</p><p>图中展示的是目标Activity所属任务栈已经存在的情况，<strong>如果启动目标Activity时其归属的任务栈还未启动，那么会先创建对应的任务栈TaskRecord</strong>。</p><p>另外需要注意的是，目标Activity的回退栈可能还存在其它Activity，例如图中的“邮件首页”，此时会随着任务栈的切换一并移动到当前任务栈的上方，并且当我们按返回键时不会立刻回到App中而是先回到邮件首页。</p><p>使用singleInstance启动Activity时Task的表现与非本栈singleTask启动或singleTask+taskAffinity类似，区别在于是由于singleInstance的任务栈只会有其一个Activity，所以当我们返回时一定返回到原App Task中。</p><h3 id="Intent-Flag"><a href="#Intent-Flag" class="headerlink" title="Intent Flag"></a>Intent Flag</h3><p>在Intent中定义了很多Flag，其中有几个Flag直接影响了Activity栈的管理，需要注意的是如果Launch Mode与Intent Flag有冲突的话<strong>以Intent Flag为准</strong>。</p><p>下面介绍一些与栈管理有关的Flag。</p><table><thead><tr><th align="center">名   称</th><th align="center">效    果</th></tr></thead><tbody><tr><td align="center">FLAG_ACTIVITY_SINGLE_TOP</td><td align="center">与Launch Mode中singleTop效果一致</td></tr><tr><td align="center">FLAG_ACTIVITY_NEW_TASK</td><td align="center">以目标Activity为根Activity，为目标Activity启动一个新的任务栈，如果目标任务栈存在，则复用。Launch Mode中singleTask和singleInstance都会自动添加这个Flag</td></tr><tr><td align="center">FLAG_ACTIVITY_CLEAR_TOP</td><td align="center">类似于singleTop中的“清顶”效果，启动时将会清除回退栈上方的Activity，使其位于栈顶可见</td></tr><tr><td align="center">FLAG_ACTIVITY_NO_HISTORY</td><td align="center">此Activity不会加入到回退栈中，这意味着一旦从这个Activity切走，这个Activity就会被finish，因此它没有办法响应onActivityResult回调</td></tr><tr><td align="center">FLAG_ACTIVITY_MULTIPLE_TASK</td><td align="center">为Activity创建新的任务栈，<strong>并且不会搜寻现有的任务栈</strong>，需要与FLAG_ACTIVITY_NEW_TASK或者FLAG_ACTIVITY_NEW_DOCUMENT一起使用才有效果</td></tr><tr><td align="center">FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</td><td align="center">Activity不会加入到“最近启动的活动”列表中</td></tr><tr><td align="center">FLAG_ACTIVITY_BROUGHT_TO_FRONT</td><td align="center">当启动模式为singleTask时此Flag被系统设置，表示将Task转移到前台</td></tr><tr><td align="center">FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</td><td align="center">表示Activity由“最近任务”中启动而来</td></tr><tr><td align="center">FLAG_ACTIVITY_CLEAR_TASK</td><td align="center">清除目标Activity对应Task中其它所有Activity，需要与FLAG_ACTIVITY_NEW_TASK配合使用</td></tr></tbody></table><p>这些Flag在何时被解析呢？</p><p>同样的在Framework系列的第二篇<a href="https://sukaidev.github.io/2021/05/22/4cb0a496/#ActivityStarter-startActivityUnchecked">Activity启动流程</a>一文中，ActivityStarter的startActivityUnchecked()中调用了computeLaunchingTaskFlags()方法来计算Intent Flag：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置初始状态</span><br>        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,<br>                voiceInteractor);<br>                <br>        <span class="hljs-comment">// 计算LaunchFlags</span><br>        computeLaunchingTaskFlags();<br>  <br>        computeSourceStack();<br>  <br>        <span class="hljs-comment">// 设置最终Flag</span><br>        mIntent.setFlags(mLaunchFlags);<br>        <br>        ···<br>&#125;<br></code></pre></td></tr></table></figure><p>首先在setInitialState()方法中会初始化启动Activity的各种配置，包括启动的来源ActivityRecord、Intent、ActivityOptions、目标Activity需要入栈的TaskRecord和LaunchFlags等。</p><p>接着在computeLaunchingTaskFlags()方法会计算出Activity启动的LaunchFlags，计算后将其复制给成员变量mLaunchFlags，我们来重点关注这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeLaunchingTaskFlags</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果启动来源SourceActivityRecord为空并且目标Task不为null</span><br>    <span class="hljs-comment">// 表示这次请求启动不是来自一个Activity</span><br>    <span class="hljs-keyword">if</span> (mSourceRecord == <span class="hljs-keyword">null</span> &amp;&amp; mInTask != <span class="hljs-keyword">null</span> &amp;&amp; mInTask.getStack() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> Intent baseIntent = mInTask.getBaseIntent();<br>        <span class="hljs-keyword">final</span> ActivityRecord root = mInTask.getRootActivity();<br>        <span class="hljs-keyword">if</span> (baseIntent == <span class="hljs-keyword">null</span>) &#123;<br>            ActivityOptions.abort(mOptions);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Launching into task without base intent: &quot;</span><br>                    + mInTask);<br>        &#125;<br><br>        <span class="hljs-comment">// 对于singleInstance或singleTask模式启动的Activity</span><br>        <span class="hljs-keyword">if</span> (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;<br>            <span class="hljs-comment">// 只能在特定的栈中启动（包名或者taskAffinity）</span><br>            <span class="hljs-keyword">if</span> (!baseIntent.getComponent().equals(mStartActivity.intent.getComponent())) &#123;<br>                ActivityOptions.abort(mOptions);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Trying to launch singleInstance/Task &quot;</span><br>                        + mStartActivity + <span class="hljs-string">&quot; into different task &quot;</span> + mInTask);<br>            &#125;<br>            <span class="hljs-comment">// 目标Task不能有其它Activity</span><br>            <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                ActivityOptions.abort(mOptions);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Caller with mInTask &quot;</span> + mInTask<br>                        + <span class="hljs-string">&quot; has root &quot;</span> + root + <span class="hljs-string">&quot; but target is singleInstance/Task&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果目标任务栈为空，为其设置LaunchFlags</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flagsOfInterest = FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK<br>                    | FLAG_ACTIVITY_NEW_DOCUMENT | FLAG_ACTIVITY_RETAIN_IN_RECENTS;<br>            mLaunchFlags = (mLaunchFlags &amp; ~flagsOfInterest)<br>                    | (baseIntent.getFlags() &amp; flagsOfInterest);<br>            mIntent.setFlags(mLaunchFlags);<br>            mInTask.setIntent(mStartActivity);<br>            mAddingToTask = <span class="hljs-keyword">true</span>;<br><br>          <span class="hljs-comment">// 如果目标任务栈不为空，并且是设置了FLAG_ACTIVITY_NEW_TASK</span><br>          <span class="hljs-comment">// 这种情况表示Activity已经存在于其Task中，并不会重新启动该Activity</span><br>          <span class="hljs-comment">// 而是将目标任务栈转移到前台，并且回调目标Activity的onNewIntent</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="hljs-number">0</span>) &#123;<br>            mAddingToTask = <span class="hljs-keyword">false</span>;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mAddingToTask = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        mReuseTask = mInTask;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInTask = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// ResolverActivity是我们在启动过程中出现多个匹配的Activity的选择弹窗</span><br>        <span class="hljs-comment">// freeformWindowingMode表示多窗口编辑模式</span><br>        <span class="hljs-comment">// 这几种情况会在原有的Task中启动Activity</span><br>        <span class="hljs-keyword">if</span> ((mStartActivity.isResolverActivity() || mStartActivity.noDisplay) &amp;&amp; mSourceRecord != <span class="hljs-keyword">null</span><br>                &amp;&amp; mSourceRecord.inFreeformWindowingMode())  &#123;<br>            mAddingToTask = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 目标Task不存在</span><br>    <span class="hljs-keyword">if</span> (mInTask == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// SourceRecord为空</span><br>        <span class="hljs-comment">// 这种情况对应我们使用非Activity Context来启动一个Activity</span><br>        <span class="hljs-keyword">if</span> (mSourceRecord == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 没有设置FLAG_ACTIVITY_NEW_TASK  自动设置</span><br>            <span class="hljs-keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="hljs-number">0</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span>) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;startActivity called from non-Activity context; forcing &quot;</span> +<br>                        <span class="hljs-string">&quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot;</span> + mIntent);<br>                mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;<br>            <span class="hljs-comment">// Source Activity是singleInstance启动的</span><br>            <span class="hljs-comment">// 我们不能直接入任务栈而是要创建新栈</span><br>            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;<br>            <span class="hljs-comment">// 目标Activity是singleInstance或者singleTask启动模式</span><br>            <span class="hljs-comment">// 也要创建新栈</span><br>            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注释已经相当详细了，我们主要关注mInTask为null的情况。</p><p>当 mInTask == null 为true时，有三种情况：</p><ol><li><p>mSourceRecord为空。</p><p>当mSourceRecord为空时，说明我们并不是由Activity的Context发起的startActivity请求，此时如果Intent中没有添加 FLAG_ACTIVITY_NEW_TASK 的话将会自动添加，在旧版Android中会直接报错。</p></li><li><p>mSourceRecord不为空，且Source Activity的启动模式为singleInstance。</p><p>这种情况表示我们从一个singleTask的Activity启动另一个Activity，不能直接加入到Source Activity的Task中，而是要创建新的任务栈（或者复用另外的任务栈），那么会添加FLAG_ACTIVITY_NEW_TASK。</p></li><li><p>mSourceRecord不为空，且目标Activity的启动模式为singleTask或者singleInstance。</p><p>这种情况也是不能直接添加到当前任务栈，需要创建新栈或者复用另外的栈，那么会添加FLAG_ACTIVITY_NEW_TASK。</p></li></ol><h3 id="taskAffinity和allowTaskReparenting"><a href="#taskAffinity和allowTaskReparenting" class="headerlink" title="taskAffinity和allowTaskReparenting"></a>taskAffinity和allowTaskReparenting</h3><p>我们可以在 AndroidManifest.xml 中设置 android:taskAffinity，用来指定Activity希望归属的栈，在默认情况下，同一个应用程序的所有的Activity都有着相同的taskAffinity，值为App的包名。</p><p>在之前介绍相关数据结构时，我们可以看到TaskRecord中有一个affinity属性，它就是这个Task的taskAffinity属性。Task中的affinity属性会在其创建的时候被赋值，创建的时候其实就是它的Root Activity启动的时候，也就是说Task的affinity属性就是其栈中根Activity的taskAffinity属性。</p><p>taskAffinity属性在下面两种情况时会生效：</p><ol><li><p>taskAffinity与singleTask或者FLAG_ACTIVITY_NEW_TASK配合。</p><p>使用singleTask模式启动或者设置了FLAG_ACTIVITY_NEW_TASK标志的Activity启动时将会通过其taskAffinity寻找其目标任务栈，如果此栈存在将会入栈，如果不存在则新建Task。</p></li><li><p>taskAffinity与allowTaskReparenting配合。</p><p>我们可以在AndroidManifest.xml为Activity配置android:allowTaskReparenting属性，表示允许此Activity更换其从属的任务栈。设置此属性的Activity一但当前Task切换到了后台，就会回到它“倾向”的任务栈中。如何理解这句话呢？我们依旧以新建联系人为例，如下图所示。</p></li></ol><p><img src="/img/image-20210627224141969.png" alt="allowTaskReparenting的Activity转移任务栈"></p><p>可以看到当我们启动了设置了allowTaskReparenting为true的Activity时，如果我们按下最近任务键，此Activity将会回到与其taskAffinity更相近的通讯录App的Task中，重新回到短信App时栈顶的Activity已经变成了短信详情页，而此时打开通讯录App会发现原先在首页的App已经在新建联系人页了。</p><p>下面我们来看看源码中taskAffinity是如何应用的。</p><p>同样的，在ActivityStarter的startActivityUnchecked方法中：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;<br>  <br>        ···<br><br>        <span class="hljs-comment">// 寻找是否有可以复用的ActivityRecord</span><br>        ActivityRecord reusedActivity = getReusableIntentActivity();<br>        <br>        ···<br><br>        <span class="hljs-keyword">return</span> START_SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure><p>调用了本类中的getReusableIntentActivity方法来寻找是否有可以复用的Activity。此方法会调用RootActivityContainer的findTask来寻找对应的Task，经过层层调用最终会调用到Task的管理者ActivityStack的findTaskLocked中，我们来看看相关源码：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findTaskLocked</span><span class="hljs-params">(ActivityRecord target, FindTaskResult result)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> taskNdx = mTaskHistory.size() - <span class="hljs-number">1</span>; taskNdx &gt;= <span class="hljs-number">0</span>; --taskNdx) &#123;<br>        <span class="hljs-keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);<br>      <br>        ···<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument<br>                &amp;&amp; result.mRecord == <span class="hljs-keyword">null</span> &amp;&amp; task.rootAffinity != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) &#123;<br>                result.mRecord = r;<br>                result.mIdealMatch = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DEBUG_TASKS) Slog.d(TAG_TASKS, <span class="hljs-string">&quot;Not a match: &quot;</span> + task);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法源码比较长，这里只截取了关键的部分，可以看到ActivityStack遍历了其管理的现存所有TaskRecord，如果task的rootAffinity属性与目标Activity的taskAffinity相同，那么将栈顶的Activity保存的结果中，表示我们已经找到了匹配的任务栈。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章以Android 应用开发工程师的角度简单的介绍了Activity Manager Service服务，以及其相关的数据结构、Activity栈管理等。</p><p>由于AMS家族相关的源码相当浩瀚，要想一窥全貌是相当困难的，更好的选择是当我们需要去了解某部分功能时再去源码中寻找会比较有方向。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:">Android API 29 Platform</a></li><li><a href="https://book.douban.com/subject/30358046/">《Android进阶解密》</a></li><li><a href="https://www.bilibili.com/video/BV1CA41177Se">Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？</a></li><li><a href="https://www.cnblogs.com/muouren/p/11706314.html">任务栈和Activity启动模式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
      <tag>AMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（三）——应用程序进程启动流程</title>
    <link href="/2021/06/03/31b8eb1c/"/>
    <url>/2021/06/03/31b8eb1c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意（WARNING）：本文含有大量AOSP源码，阅读过程中如出现头晕、目眩、恶心、犯困等症状属正常情况，作者本人亦无法避免症状产生，故不承担任何法律责任。</p><p>本文所贴源码全部来自 Android API 29 Platform，即 Android 10.0。</p><p>阅读本文需要有一定的C/C++基础。</p></blockquote><p>要想启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动。</p><p>在上两篇文章中我们分别讨论了系统关键进程的启动和Activity的启动流程，已经清楚了两个事实：</p><ol><li>应用程序进程由Zygote通过fork自身来创建。</li><li>Activity启动时将会优先检查应用程序对应进程是否已经存在并且正在运行。</li></ol><p>也就是说整个过程至少有SystemServer、Zygote和目标App进程三个进程参与。</p><p>下面将会分为三个部分来介绍，分别是<strong>AMS发送创建App进程请求</strong>、<strong>Zygote接收请求并创建App进程</strong>、<strong>App进程初始化</strong>。</p><h2 id="AMS发送创建App进程请求"><a href="#AMS发送创建App进程请求" class="headerlink" title="AMS发送创建App进程请求"></a>AMS发送创建App进程请求</h2><p>在<a href="/2021/05/22/4cb0a496/#ActivityStackSupervisor-startSpecificActivityLocked">上篇文章</a>中，ActivityStackSupervisor在执行startSpecificActivityLocked方法时，将会检查App进程是否正在执行，我们从这里继续。</p><h3 id="ActivityStackSupervisor-startSpecificActivityLocked"><a href="#ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="ActivityStackSupervisor#startSpecificActivityLocked"></a>ActivityStackSupervisor#startSpecificActivityLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过ATMS获取目标进程的WindowProcessController对象</span><br>    <span class="hljs-comment">// WindowProcessController用于ActivityManager与WindowManager同步进程状态</span><br>    <span class="hljs-comment">// 如果wpc为空，则表示对应进程不存在或者未启动</span><br>    <span class="hljs-keyword">final</span> WindowProcessController wpc =<br>            mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>        <span class="hljs-comment">// 如果对应App进程还未启动</span><br>        <span class="hljs-comment">// 通过handler发送消息启动进程</span><br>        <span class="hljs-keyword">final</span> Message msg = PooledLambda.obtainMessage(<br>                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,<br>                r.info.applicationInfo, knownToBeDead, <span class="hljs-string">&quot;activity&quot;</span>, r.intent.getComponent());<br>        mService.mH.sendMessage(msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处的mService为ActivityTaskManagerService对象，调用它的getProcessController返回一个WindowProcessController对象，当目标进程未启动时为null。</p><p>如果wpc为null，那么就会使用PooledLambda#obtainMessage来获得一个Message，使用主线程Handler将这条消息发送到主线程中。</p><p>PooledLambda这个类采用了池化技术，用于构造可回收复用的匿名函数。其acquire函数将会尝试在对象池中</p><p>会Kotlin的同学对于双冒号获取函数引用的语法比较熟悉，在Java中这个特性是在JDK 1.8才出现，ActivityManagerInternal::startProcess这行代码实际上返回的是一个Comsumer对象。</p><p>PooledLambda#obtainMessage的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 参数解释：</span><br><span class="hljs-comment">  * function：需要封装的方法引用，为Consumer类型</span><br><span class="hljs-comment">  * arg1：执行此方法的对象，这里为ActivityManagerService$LocalService对象</span><br><span class="hljs-comment">  * arg2-6：方法执行所需参数</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> &lt;A, B, C, D, E, F&gt; <span class="hljs-function">Message <span class="hljs-title">obtainMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">         HexConsumer&lt;? <span class="hljs-keyword">super</span> A, ? <span class="hljs-keyword">super</span> B, ? <span class="hljs-keyword">super</span> C, ? <span class="hljs-keyword">super</span> D, ? <span class="hljs-keyword">super</span> E, ? <span class="hljs-keyword">super</span> F&gt; function,</span></span><br><span class="hljs-function"><span class="hljs-params">         A arg1, B arg2, C arg3, D arg4, E arg5, F arg6)</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span> (Message.sPoolSync) &#123;<br>         PooledRunnable callback = acquire(PooledLambdaImpl.sMessageCallbacksPool,<br>                 function, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, ReturnType.VOID, arg1, arg2, arg3, arg4, arg5, arg6, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>,<br>                 <span class="hljs-keyword">null</span>);<br>         <span class="hljs-keyword">return</span> Message.obtain().setCallback(callback.recycleOnUse());<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>这段代码实际上就是把ActivityManagerInternal#startProcess方法封装成Callback然后设置到Message中。</p><p>由于Handler的callback不为空，那么在分发消息时将会直接执行此Callback，在此例中将会执行PooledLambdaImpl#run方法，继而执行到HexConsumer#invoke方法，从而执行了我们传递过去的方法引用。</p><p>下面我们继续分析ActivityManagerInternal#startProcess方法。</p><h3 id="ActivityManagerInternal-startProcess"><a href="#ActivityManagerInternal-startProcess" class="headerlink" title="ActivityManagerInternal#startProcess"></a>ActivityManagerInternal#startProcess</h3><p>ActivityManagerInternal类是一个抽象类，startProcess也是一个抽象方法，实际由其子类ActivityManagerService$LocalService来实现。</p><p>LocalService是ActivityManagerService的一个内部类，来看看其startProcess方法：</p><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService$LocalService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startProcess</span><span class="hljs-params">(String processName, ApplicationInfo info,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> knownToBeDead, String hostingType, ComponentName hostingName)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (ActivityManagerService.<span class="hljs-keyword">this</span>) &#123;<br>            startProcessLocked(processName, info, knownToBeDead, <span class="hljs-number">0</span> <span class="hljs-comment">/* intentFlags */</span>,<br>                    <span class="hljs-keyword">new</span> HostingRecord(hostingType, hostingName),<br>                    <span class="hljs-keyword">false</span> <span class="hljs-comment">/* allowWhileBooting */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* isolated */</span>,<br>                    <span class="hljs-keyword">true</span> <span class="hljs-comment">/* keepIfLarge */</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法中主要是对后续操作加锁，并将hostingType和hostingName封装到HostingRecord对象中。</p><p>HostingRecord类用于描述进程的启动信息，这里的hostingType可以是activity、service、broadcast、content provider，这里为“activity”，hostingName是对应的组件名ComponentName。</p><p>接着调用了ActivityManagerService中的startProcessLocked方法。</p><h3 id="ActivityManagerService-startProcessLocked"><a href="#ActivityManagerService-startProcessLocked" class="headerlink" title="ActivityManagerService#startProcessLocked"></a>ActivityManagerService#startProcessLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName,</span></span><br><span class="hljs-function"><span class="hljs-params">        ApplicationInfo info, <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">        HostingRecord hostingRecord, <span class="hljs-keyword">boolean</span> allowWhileBooting,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">boolean</span> keepIfLarge)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,<br>            hostingRecord, allowWhileBooting, isolated, <span class="hljs-number">0</span> <span class="hljs-comment">/* isolatedUid */</span>, keepIfLarge,<br>            <span class="hljs-keyword">null</span> <span class="hljs-comment">/* ABI override */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPoint */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPointArgs */</span>,<br>            <span class="hljs-keyword">null</span> <span class="hljs-comment">/* crashHandler */</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将启动进程任务转发给了mProcessList，mProcessList是一个ProcessList对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Process management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> ProcessList mProcessList = <span class="hljs-keyword">new</span> ProcessList();<br></code></pre></td></tr></table></figure><p>ProcessList是ActivityManager中用于管理进程的类，这个类对于我们理解Android的<strong>进程优先级ADJ算法</strong>有着重要作用，而理解ADJ可以帮助我们提升应用的存活时间（<del>耍流氓</del>），这部分将会在后面单独出文章讨论。</p><p>下面继续跟踪App进程启动。</p><h3 id="ProcessList-startProcessLocked"><a href="#ProcessList-startProcessLocked" class="headerlink" title="ProcessList#startProcessLocked"></a>ProcessList#startProcessLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ProcessList.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName, ApplicationInfo info,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags, HostingRecord hostingRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> allowWhileBooting, <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid, <span class="hljs-keyword">boolean</span> keepIfLarge,</span></span><br><span class="hljs-function"><span class="hljs-params">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> startTime = SystemClock.elapsedRealtime();<br>    ProcessRecord app;<br>    <span class="hljs-comment">// 如果进程是孤立进程</span><br>    <span class="hljs-comment">// 此次流程isolated为false</span><br>    <span class="hljs-keyword">if</span> (!isolated) &#123;<br>        <span class="hljs-comment">// 通过进程名和uid获取对应ProcessRecord对象</span><br>        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);<br>        <span class="hljs-comment">// 如果请求来自后台进程</span><br>        <span class="hljs-keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 目标进程是否是一个“坏进程”</span><br>            <span class="hljs-comment">// 坏进程是指短时间内连续崩溃两次以上的进程</span><br>            <span class="hljs-comment">// 坏进程从后台启动进程将会直接失败</span><br>            <span class="hljs-keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果请求不是来自后台进程，那么就来自用户了</span><br>            <span class="hljs-comment">// 这时候需要清除目标进程的崩溃计数，让它成为一个“好进程”</span><br>            mService.mAppErrors.resetProcessCrashTimeLocked(info);<br>            <span class="hljs-keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;<br>                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,<br>                        UserHandle.getUserId(info.uid), info.uid,<br>                        info.processName);<br>                mService.mAppErrors.clearBadProcessLocked(info);<br>                <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span>) &#123;<br>                    app.bad = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 对于孤立进程，无法再利用已存在的进程</span><br>        app = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果满足三种条件时，我们可以复用这个进程：</span><br>    <span class="hljs-comment">// 1、已经存在了对应的ProcessRecord对象，并且pid大于0</span><br>    <span class="hljs-comment">// 2、AMS认为它没有死亡，并且进程没有被杀掉</span><br>    <span class="hljs-comment">// 3、或者进程还没有绑定binder线程（IApplicationThread）</span><br>    <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span> &amp;&amp; app.pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="hljs-keyword">null</span>) &#123;<br>            app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);<br>            <span class="hljs-keyword">return</span> app;<br>        &#125;<br><br>        <span class="hljs-comment">// 不满足上面的三种条件，说明ProgressRecord绑定在之前的进程，杀死并清理这个进程</span><br>        ProcessList.killProcessGroup(app.uid, app.pid);<br>        mService.handleAppDiedLocked(app, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果app为null，说明目标App进程一定不在运行</span><br>    <span class="hljs-comment">// 新建进程之前先创建好ProgressRecord对象</span><br>    <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) &#123;<br>        app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord);<br>        <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        app.crashHandler = crashHandler;<br>        app.isolatedEntryPoint = entryPoint;<br>        app.isolatedEntryPointArgs = entryPointArgs;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里对应ProgressRecord绑定在之前的进程的情况</span><br>        <span class="hljs-comment">// 清理之后重新绑定新的包信息</span><br>        app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);<br>    &#125;<br><br>    <span class="hljs-comment">// 到这里我们已经确保有了App进程的ProcessRecord对象了</span><br>    <span class="hljs-comment">// 如果系统还没准备好就先添加到等待队列中</span><br>    <span class="hljs-comment">// 当进程为persistent，则isAllowedWhileBooting为true，这次流程为false</span><br>    <span class="hljs-keyword">if</span> (!mService.mProcessesReady<br>            &amp;&amp; !mService.isAllowedWhileBooting(info)<br>            &amp;&amp; !allowWhileBooting) &#123;<br>        <span class="hljs-keyword">if</span> (!mService.mProcessesOnHold.contains(app)) &#123;<br>            mService.mProcessesOnHold.add(app);<br>        &#125;<br>        <span class="hljs-keyword">return</span> app;<br>    &#125;<br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> success = startProcessLocked(app, hostingRecord, abiOverride);<br>    <span class="hljs-keyword">return</span> success ? app : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法主要是处理目标进程对应的ProcessRecord对象，ProcessRecord是AMS中用来保存进程信息的类，类似于我们上篇文章中的ActivityRecord。</p><p>接着又调用了本类中的startProcessLocked方法。</p><h3 id="ProcessList-startProcessLocked-1"><a href="#ProcessList-startProcessLocked-1" class="headerlink" title="ProcessList#startProcessLocked"></a>ProcessList#startProcessLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ProcessList.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        String abiOverride)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> startProcessLocked(app, hostingRecord,<br>            <span class="hljs-keyword">false</span> <span class="hljs-comment">/* disableHiddenApiChecks */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* mountExtStorageFull */</span>, abiOverride);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法主要是配置了默认参数，继续跟进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> disableHiddenApiChecks, <span class="hljs-keyword">boolean</span> mountExtStorageFull,</span></span><br><span class="hljs-function"><span class="hljs-params">        String abiOverride)</span> </span>&#123;<br>  <br>    ···<br>    <br>    <span class="hljs-comment">// 从等待启动的队列中移除</span><br>    mService.mProcessesOnHold.remove(app);<br><br>    <span class="hljs-comment">// 设置一大堆调试Flag</span><br>    ···<br>      <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId = UserHandle.getUserId(app.uid);<br>            <span class="hljs-comment">// 检查当前包是否可启动</span><br>            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowAsRuntimeException();<br>        &#125;<br>      <br>        ···<br>      <br>        <span class="hljs-comment">// 设置进程的入口类</span><br>        <span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br><br>        <span class="hljs-comment">// 启动进程</span><br>        <span class="hljs-keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,<br>                runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,<br>                startTime);<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),<br>                <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, app.userId, <span class="hljs-string">&quot;start failure&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法源码比较长，这里进行了大量删减，它的主要工作是设置App进程挂载外部空间的模式、设置进程的GID，计算RuntimeFlags等。</p><p>这里有一行关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这里设置了进程的入口函数所在类文件。继续跟进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(HostingRecord hostingRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        String entryPoint,</span></span><br><span class="hljs-function"><span class="hljs-params">        ProcessRecord app, <span class="hljs-keyword">int</span> uid, <span class="hljs-keyword">int</span>[] gids, <span class="hljs-keyword">int</span> runtimeFlags, <span class="hljs-keyword">int</span> mountExternal,</span></span><br><span class="hljs-function"><span class="hljs-params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">long</span> startTime)</span> </span>&#123;<br>    app.pendingStart = <span class="hljs-keyword">true</span>;<br>    app.killedByAm = <span class="hljs-keyword">false</span>;<br>    app.removed = <span class="hljs-keyword">false</span>;<br>    app.killed = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (app.startSeq != <span class="hljs-number">0</span>) &#123;<br>        Slog.wtf(TAG, <span class="hljs-string">&quot;startProcessLocked processName:&quot;</span> + app.processName<br>                + <span class="hljs-string">&quot; with non-zero startSeq:&quot;</span> + app.startSeq);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (app.pid != <span class="hljs-number">0</span>) &#123;<br>        Slog.wtf(TAG, <span class="hljs-string">&quot;startProcessLocked processName:&quot;</span> + app.processName<br>                + <span class="hljs-string">&quot; with non-zero pid:&quot;</span> + app.pid);<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startSeq = app.startSeq = ++mProcStartSeqCounter;<br>    app.setStartParams(uid, hostingRecord, seInfo, startTime);<br>    app.setUsingWrapper(invokeWith != <span class="hljs-keyword">null</span><br>            || SystemProperties.get(<span class="hljs-string">&quot;wrap.&quot;</span> + app.processName) != <span class="hljs-keyword">null</span>);<br>    mPendingStarts.put(startSeq, app);<br>  <br>    <span class="hljs-comment">// AMS设置了异步启动进程</span><br>    <span class="hljs-keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;<br>        mService.mProcStartHandler.post(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> Process.ProcessStartResult startResult = startProcess(app.hostingRecord,<br>                        entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal,<br>                        app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime);<br>                <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>                    handleProcessStartedLocked(app, startResult, startSeq);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>                    mPendingStarts.remove(startSeq);<br>                    app.pendingStart = <span class="hljs-keyword">false</span>;<br>                    mService.forceStopPackageLocked(app.info.packageName,<br>                            UserHandle.getAppId(app.uid),<br>                            <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, app.userId, <span class="hljs-string">&quot;start failure&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,<br>                    entryPoint, app,<br>                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,<br>                    invokeWith, startTime);<br>            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,<br>                    startSeq, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            app.pendingStart = <span class="hljs-keyword">false</span>;<br>            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),<br>                    <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, app.userId, <span class="hljs-string">&quot;start failure&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> app.pid &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里针对AMS采用同步或者异步的启动方式做了一些工作，最终都会调用startProcess方法。</p><h3 id="ProcessList-startProcess"><a href="#ProcessList-startProcess" class="headerlink" title="ProcessList#startProcess"></a>ProcessList#startProcess</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/am/ProcessList.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">startProcess</span><span class="hljs-params">(HostingRecord hostingRecord, String entryPoint,</span></span><br><span class="hljs-function"><span class="hljs-params">        ProcessRecord app, <span class="hljs-keyword">int</span> uid, <span class="hljs-keyword">int</span>[] gids, <span class="hljs-keyword">int</span> runtimeFlags, <span class="hljs-keyword">int</span> mountExternal,</span></span><br><span class="hljs-function"><span class="hljs-params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">long</span> startTime)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> Process.ProcessStartResult startResult;<br>        <span class="hljs-comment">// 是否从webviewZygote创建进程</span><br>        <span class="hljs-comment">// 这种情况下会通过WebViewZygote来启动进程</span><br>        <span class="hljs-keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;<br>            startResult = startWebView(entryPoint,<br>                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,<br>                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,<br>                    app.info.dataDir, <span class="hljs-keyword">null</span>, app.info.packageName,<br>                    <span class="hljs-keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hostingRecord.usesAppZygote()) &#123;<br>            <span class="hljs-comment">// 是否从AppZygote来创建进程</span><br>            <span class="hljs-keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);<br><br>            startResult = appZygote.getProcess().start(entryPoint,<br>                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,<br>                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,<br>                    app.info.dataDir, <span class="hljs-keyword">null</span>, app.info.packageName,<br>                    <span class="hljs-comment">/*useUsapPool=*/</span> <span class="hljs-keyword">false</span>,<br>                    <span class="hljs-keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从默认的Zygote中创建进程</span><br>            <span class="hljs-comment">// 本次流程进入这里</span><br>            startResult = Process.start(entryPoint,<br>                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,<br>                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,<br>                    app.info.dataDir, invokeWith, app.info.packageName,<br>                    <span class="hljs-keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> startResult;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法主要是判断应该由哪个Zygote进程来创建我们的App进程。</p><p>一般情况下，我们不指定Zygote进程时，HostingRecord中使用默认Zygote。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HostingRecord</span><span class="hljs-params">(String hostingType, ComponentName hostingName)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(hostingType, hostingName, REGULAR_ZYGOTE);<br>&#125;<br></code></pre></td></tr></table></figure><p>Process#start方法把进程的启动工作转发给了ZygoteProcess，ZygoteProcess#start又调用了startViaZygote方法，我们直接来到startViaZygote方法中。</p><h3 id="ZygoteProcess-startViaZygote"><a href="#ZygoteProcess-startViaZygote" class="headerlink" title="ZygoteProcess#startViaZygote"></a>ZygoteProcess#startViaZygote</h3><blockquote><p>frameworks/base/core/java/android/os/ZygoteProcess.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">startViaZygote</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> String processClass,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> String niceName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> uid, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> gid,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] gids,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-keyword">int</span> runtimeFlags, <span class="hljs-keyword">int</span> mountExternal,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-keyword">int</span> targetSdkVersion,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String seInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@NonNull</span> String abi,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String instructionSet,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String appDataDir,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String invokeWith,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-keyword">boolean</span> startChildZygote,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String packageName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-keyword">boolean</span> useUsapPool,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                  <span class="hljs-meta">@Nullable</span> String[] extraArgs)</span></span><br><span class="hljs-function">                                                  <span class="hljs-keyword">throws</span> ZygoteStartFailedEx </span>&#123;<br>    ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-comment">// 设置启动参数</span><br>    argsForZygote.add(<span class="hljs-string">&quot;--runtime-args&quot;</span>);<br>    argsForZygote.add(<span class="hljs-string">&quot;--setuid=&quot;</span> + uid);<br>    argsForZygote.add(<span class="hljs-string">&quot;--setgid=&quot;</span> + gid);<br>    argsForZygote.add(<span class="hljs-string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">synchronized</span>(mLock) &#123;<br>        <span class="hljs-comment">// 发送参数到Zygote并且获取结果</span><br>        <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),<br>                                          useUsapPool,<br>                                          argsForZygote);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该过程主要工作是生成argsForZygote数组，该数组保存了进程的uid、pid、groups、targetSDK、niceName等一系列参数。</p><h3 id="ZygoteProcess-zygoteSendArgsAndGetResult"><a href="#ZygoteProcess-zygoteSendArgsAndGetResult" class="headerlink" title="ZygoteProcess#zygoteSendArgsAndGetResult"></a>ZygoteProcess#zygoteSendArgsAndGetResult</h3><blockquote><p>frameworks/base/core/java/android/os/ZygoteProcess.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">zygoteSendArgsAndGetResult</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ZygoteState zygoteState, <span class="hljs-keyword">boolean</span> useUsapPool, <span class="hljs-meta">@NonNull</span> ArrayList&lt;String&gt; args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> ZygoteStartFailedEx </span>&#123;<br>    <span class="hljs-comment">// 检验参数列表是否合法</span><br>    ···<br>      <br>    <span class="hljs-comment">// 此次流程useUsapPool = true &amp;&amp; mUsapPoolEnabled = false</span><br>    <span class="hljs-keyword">if</span> (useUsapPool &amp;&amp; mUsapPoolEnabled &amp;&amp; canAttemptUsap(args)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            <span class="hljs-comment">// If there was an IOException using the USAP pool we will log the error and</span><br>            <span class="hljs-comment">// attempt to start the process through the Zygote.</span><br>            Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with USAP pool - &quot;</span><br>                    + ex.getMessage());<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 本次流程走这里</span><br>    <span class="hljs-keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了一个新名词：<strong>UsapPool</strong>。UsapPool是Android 10中的一种新机制，主要就是在Zygote里面维护一个<strong>进程池</strong>，不过android 10中并没有开启此功能，也就是mUsapPoolEnabled参数默认时为false的。</p><h3 id="ZygoteProcess-attemptZygoteSendArgsAndGetResult"><a href="#ZygoteProcess-attemptZygoteSendArgsAndGetResult" class="headerlink" title="ZygoteProcess#attemptZygoteSendArgsAndGetResult"></a>ZygoteProcess#attemptZygoteSendArgsAndGetResult</h3><blockquote><p>frameworks/base/core/java/android/os/ZygoteProcess.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">attemptZygoteSendArgsAndGetResult</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ZygoteState zygoteState, String msgStr)</span> <span class="hljs-keyword">throws</span> ZygoteStartFailedEx </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// zygoteState由openZygoteSocketIfNeeded方法返回</span><br>        <span class="hljs-comment">// openZygoteSocketIfNeeded方法方法根据abi类型选择Zygote还是Zygote64的ZygoteState</span><br>        <span class="hljs-comment">// 获取服务端（Zygote）输出流</span><br>        <span class="hljs-keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;<br>        <span class="hljs-comment">// // 获取服务端（Zygote）输入流</span><br>        <span class="hljs-keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;<br><br>        <span class="hljs-comment">// 将参数写入Zygote</span><br>        zygoteWriter.write(msgStr);<br>        zygoteWriter.flush();<br><br>        Process.ProcessStartResult result = <span class="hljs-keyword">new</span> Process.ProcessStartResult();<br>        <span class="hljs-comment">// 获取Zygote返回的结果</span><br>        result.pid = zygoteInputStream.readInt();<br>        result.usingWrapper = zygoteInputStream.readBoolean();<br><br>        <span class="hljs-keyword">if</span> (result.pid &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        zygoteState.close();<br>        Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with Zygote - &quot;</span><br>                + ex.toString());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p><p>到这里SystemServer所做的前置工作就完成了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们来回顾一下本节中SystemServer的主要工作。</p><p>SystemServer在启动一个Activity时，会判断Activity对应进程是否存在，不存在则会启动该进程。</p><p>进程启动代码由ActivityManagerService$LocalService开始，接着将会转发到ProcessList中。</p><p>ProcessList会检查进程是否是孤立进程，尝试获取现有的ProcessRecord对象，并且尝试复用进程。</p><p>如果无法复用进程，那么将会继续配置参数启动该进程，其中配置了目标进程的入口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br></code></pre></td></tr></table></figure><p>最终会通过Socket的方式将参数发送到Zygote中，并且阻塞等待返回。</p><p>时序图如下所示。</p><p><img src="/img/ams_send_process_creation_request.jpg" alt="AMS发送进程启动请求"></p><h2 id="Zygote接收请求并创建App进程"><a href="#Zygote接收请求并创建App进程" class="headerlink" title="Zygote接收请求并创建App进程"></a>Zygote接收请求并创建App进程</h2><p>在之前的<a href="/2021/05/14/7ca6484e/#ZygoteServer-runSelectLoop">系统进程启动过程</a>一文中我们知道，Zygote在创建完SystemServer后，将会开启无限循环以等待子进程的请求，具体的流程已经在文中分析过了，这里简单过一遍。</p><h3 id="ZygoteServer-runSelectLoop"><a href="#ZygoteServer-runSelectLoop" class="headerlink" title="ZygoteServer#runSelectLoop"></a>ZygoteServer#runSelectLoop</h3><p>frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Runnable <span class="hljs-title">runSelectLoop</span><span class="hljs-params">(String abiList)</span> </span>&#123;<br>  <br>      ···<br>  <br>      <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>          &#125;<br> <br>          <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// 收到新的建立通信的请求，建立通信连接</span><br>              ZygoteConnection newPeer = acceptCommandPeer(abiList);<br>              <span class="hljs-comment">// 加入到peers和fds, 即下一次也开始监听</span><br>              peers.add(newPeer);<br>              socketFDs.add(newPeer.getFileDescriptor());<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;<br>              <span class="hljs-comment">// 说明接收到AMS发送过来创建应用程序的请求，调用processOneCommand来创建新的应用程序进程</span><br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//有socket连接，创建ZygoteConnection对象，并添加到fds</span><br>                  ZygoteConnection connection = peers.get(pollIndex);<br>                  <span class="hljs-comment">// 处理连接</span><br>                  <span class="hljs-keyword">final</span> Runnable command = connection.processOneCommand(<br><span class="hljs-keyword">this</span>);<br> <br>     ···<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ZygoteConnection-processOneCommand"><a href="#ZygoteConnection-processOneCommand" class="headerlink" title="ZygoteConnection#processOneCommand"></a>ZygoteConnection#processOneCommand</h3><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Runnable <span class="hljs-title">processOneCommand</span><span class="hljs-params">(ZygoteServer zygoteServer)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">//fork子进程</span><br>    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, <br>parsedArgs.mGids,<br>            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, <br>parsedArgs.mSeInfo,<br>            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.<br>mStartChildZygote,<br>            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs<br>.mTargetSdkVersion);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来看看进程fork是如何做的。</p><h3 id="Zygote-forkAndSpecialize"><a href="#Zygote-forkAndSpecialize" class="headerlink" title="Zygote#forkAndSpecialize"></a>Zygote#forkAndSpecialize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">forkAndSpecialize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid, <span class="hljs-keyword">int</span> gid, <span class="hljs-keyword">int</span>[] gids, <span class="hljs-keyword">int</span> runtimeFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span>[][] rlimits, <span class="hljs-keyword">int</span> mountExternal, String seInfo, String niceName, <span class="hljs-keyword">int</span>[] fdsToClose,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span>[] fdsToIgnore, <span class="hljs-keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> targetSdkVersion)</span> </span>&#123;<br>    <span class="hljs-comment">// fork之前执行的操作</span><br>    ZygoteHooks.preFork();<br>    <span class="hljs-comment">// 重新设置线程优先级</span><br>    resetNicePriority();<br>    <span class="hljs-comment">// fork创建进程</span><br>    <span class="hljs-keyword">int</span> pid = nativeForkAndSpecialize(<br>            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,<br>            fdsToIgnore, startChildZygote, instructionSet, appDataDir);<br>    ···<br>    <span class="hljs-comment">// fork之后需要执行的操作</span><br>    ZygoteHooks.postForkCommon();<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法将fork分为了三步：preFork、nativeForkAndSpecialize和postForkCommon，其中nativeForkAndSpecialize为真正执行fork的步骤。</p><h3 id="ZygoteHooks-preFork"><a href="#ZygoteHooks-preFork" class="headerlink" title="ZygoteHooks#preFork"></a>ZygoteHooks#preFork</h3><blockquote><p>libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preFork</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 停止守护线程</span><br>    Daemons.stop();<br>    <span class="hljs-comment">// 完成gc堆的初始化工作</span><br>    token = nativePreFork();<br>    <span class="hljs-comment">// 等待所有线程停止</span><br>    waitUntilAllThreadsStopped();<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Dalvik虚拟机的存在，Zygote中除了主线程外还运行了几条守护线程：</p><p><img src="/img/image-20210531180408524.png" alt="Zygote中的线程"></p><p>分别是：</p><ul><li>Java堆内存整理线程：HeapTaskDaemon</li><li>引用队列处理线程：ReferenceQueueDaemon</li><li>执行finalize()方法的析构线程：FinalizerDaemon</li><li>析构方法监控线程：FinalizerWatchdogDaemon</li></ul><p>在fork前需要将这些守护线程停止。</p><h4 id="Daemons-stop"><a href="#Daemons-stop" class="headerlink" title="Daemons#stop"></a>Daemons#stop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Daemon[] DAEMONS = <span class="hljs-keyword">new</span> Daemon[] &#123;<br>        HeapTaskDaemon.INSTANCE,<br>        ReferenceQueueDaemon.INSTANCE,<br>        FinalizerDaemon.INSTANCE,<br>        FinalizerWatchdogDaemon.INSTANCE,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Daemon daemon : DAEMONS) &#123;<br>        daemon.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到与上图中的是一致的。</p><h4 id="nativePreFork"><a href="#nativePreFork" class="headerlink" title="nativePreFork"></a>nativePreFork</h4><p>此方法通过JNI最终调用到了dalvik_system_ZygoteHooks.cc中的ZygoteHooks_nativePreFork方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">ZygoteHooks_nativePreFork</span><span class="hljs-params">(JNIEnv* env, jclass)</span> </span>&#123;<br>  Runtime* runtime = Runtime::Current();<br>  <span class="hljs-comment">// 检查当前Runtime是否为Zygtoe</span><br>  CHECK(runtime-&gt;IsZygote()) &lt;&lt; <span class="hljs-string">&quot;runtime instance not started with -Xzygote&quot;</span>;<br><br>  runtime-&gt;PreZygoteFork();<br><br>  <span class="hljs-comment">// 将线程转换为long型并保存到token，该过程是非线程安全的</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(ThreadForEnv(env));<br>&#125;<br></code></pre></td></tr></table></figure><p>PreZygoteFork定义在runtime.cc中：</p><blockquote><p>art/runtime/runtime.cc</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::PreZygoteFork</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (GetJit() != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// 完成JIT编译器fork前的工作</span><br>    GetJit()-&gt;PreZygoteFork();<br>  &#125;<br>  <span class="hljs-comment">// 完成GC堆fork前的工作</span><br>  heap_-&gt;PreZygoteFork();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里不再深入到虚拟机中。</p><h4 id="waitUntilAllThreadsStopped"><a href="#waitUntilAllThreadsStopped" class="headerlink" title="waitUntilAllThreadsStopped"></a>waitUntilAllThreadsStopped</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitUntilAllThreadsStopped</span><span class="hljs-params">()</span> </span>&#123;<br>    File tasks = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/proc/self/task&quot;</span>);<br>    <span class="hljs-comment">// 如果当前不为单线程，继续等待，直到单线程才退出循环</span><br>    <span class="hljs-keyword">while</span> (tasks.list().length &gt; <span class="hljs-number">1</span>) &#123;<br>      Thread.yield();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法会等待当前进程的线程数量为1才会退出。</p><p>ZygoteHooks.preFork()的主要工作便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程，并等待这些线程的停止，初始化gc堆的工作,并将线程转换为long型并保存到token中，以便后续能恢复准备线程。</p><h3 id="Zygote-nativeForkAndSpecialize"><a href="#Zygote-nativeForkAndSpecialize" class="headerlink" title="Zygote#nativeForkAndSpecialize"></a>Zygote#nativeForkAndSpecialize</h3><p>nativeForkAndSpecialize通过JNI最终调用如下方法：</p><blockquote><p>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span><br><span class="hljs-function"><span class="hljs-params">        jint runtime_flags, jobjectArray rlimits,</span></span><br><span class="hljs-function"><span class="hljs-params">        jint mount_external, jstring se_info, jstring nice_name,</span></span><br><span class="hljs-function"><span class="hljs-params">        jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote,</span></span><br><span class="hljs-function"><span class="hljs-params">        jstring instruction_set, jstring app_data_dir)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理蓝牙进程和网络进程相关问题</span><br>    jlong capabilities = CalculateCapabilities(env, uid, gid, gids, is_child_zygote);<br><br>    <span class="hljs-keyword">if</span> (UNLIKELY(managed_fds_to_close == <span class="hljs-literal">nullptr</span>)) &#123;<br>      ZygoteFailure(env, <span class="hljs-string">&quot;zygote&quot;</span>, nice_name, <span class="hljs-string">&quot;Zygote received a null fds_to_close vector.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 将Java数组转换为Vector</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fds_to_close =<br>        ExtractJIntArray(env, <span class="hljs-string">&quot;zygote&quot;</span>, nice_name, managed_fds_to_close).value();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fds_to_ignore =<br>        ExtractJIntArray(env, <span class="hljs-string">&quot;zygote&quot;</span>, nice_name, managed_fds_to_ignore)<br>            .value_or(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;());<br><br>    <span class="hljs-comment">// 处理Android 10中USAP功能相关问题</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; usap_pipes = MakeUsapPipeReadFDVector();<br><br>    fds_to_close.insert(fds_to_close.end(), usap_pipes.begin(), usap_pipes.end());<br>    fds_to_ignore.insert(fds_to_ignore.end(), usap_pipes.begin(), usap_pipes.end());<br><br>    fds_to_close.push_back(gUsapPoolSocketFD);<br><br>    <span class="hljs-keyword">if</span> (gUsapPoolEventFD != <span class="hljs-number">-1</span>) &#123;<br>      fds_to_close.push_back(gUsapPoolEventFD);<br>      fds_to_ignore.push_back(gUsapPoolEventFD);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行fork</span><br>    <span class="hljs-keyword">pid_t</span> pid = ForkCommon(env, <span class="hljs-literal">false</span>, fds_to_close, fds_to_ignore);<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,<br>                       capabilities, capabilities,<br>                       mount_external, se_info, nice_name, <span class="hljs-literal">false</span>,<br>                       is_child_zygote == JNI_TRUE, instruction_set, app_data_dir);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正执行fork的过程在ForkCommon方法和SpecializeCommon方法中。</p><h4 id="ForkCommon"><a href="#ForkCommon" class="headerlink" title="ForkCommon"></a>ForkCommon</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从Zygote fork出公共进程</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">pid_t</span> <span class="hljs-title">ForkCommon</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">bool</span> is_system_server,</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; fds_to_close,</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; fds_to_ignore)</span> </span>&#123;<br>  <span class="hljs-comment">// 设置子进程的signal信号处理函数</span><br>  SetSignalHandlers();<br><br>  <span class="hljs-comment">// 失败处理函数</span><br>  <span class="hljs-keyword">auto</span> fail_fn = <span class="hljs-built_in">std</span>::bind(ZygoteFailure, env, is_system_server ? <span class="hljs-string">&quot;system_server&quot;</span> : <span class="hljs-string">&quot;zygote&quot;</span>,<br>                           <span class="hljs-literal">nullptr</span>, _1);<br><br>  <span class="hljs-comment">// 临时block住子进程SIGCHLD信号，信号处理导致出错</span><br>  BlockSignal(SIGCHLD, fail_fn);<br><br>  <span class="hljs-comment">// 关闭所有日志相关的文件描述符</span><br>  __android_log_close();<br>  stats_log_close();<br><br>  <span class="hljs-comment">// 如果是当前zygote第一次fork，创建文件描述符表</span><br>  <span class="hljs-keyword">if</span> (gOpenFdTable == <span class="hljs-literal">nullptr</span>) &#123;<br>    gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则判断需要ignore的文件描述与表中是否有变化</span><br>    gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn);<br>  &#125;<br><br>  android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level();<br><br>  <span class="hljs-comment">// 执行fork</span><br>  <span class="hljs-keyword">pid_t</span> pid = fork();<br><br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 如果pid为0，则此时为子进程</span><br>    <span class="hljs-comment">// 应用进程的预初始化工作</span><br>    PreApplicationInit();<br><br>    <span class="hljs-comment">// 清除需要关闭的文件描述符</span><br>    DetachDescriptors(env, fds_to_close, fail_fn);<br><br>    <span class="hljs-comment">// 清除Usap表</span><br>    ClearUsapTable();<br><br>    <span class="hljs-comment">// 重新打开所有之前打开的文件描述符</span><br>    gOpenFdTable-&gt;ReopenOrDetach(fail_fn);<br><br>    android_fdsan_set_error_level(fdsan_error_level);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ALOGD(<span class="hljs-string">&quot;Forked child process %d&quot;</span>, pid);<br>  &#125;<br><br>  <span class="hljs-comment">// fork结束，Unblock子进程SIGCHLD信号</span><br>  UnblockSignal(SIGCHLD, fail_fn);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>在fork之前，还需要处理子进程信号和文件描述符问题。对于文件描述符有两个数组，fds_to_close中存放子进程需要关闭的文件描述符，fds_to_ignore中存放子进程需要继承的文件描述符，不过子进程会重新打开这些文件描述符，因此与Zygote并不是共享的。</p><p>真正执行fork操作的是fork()函数，我们重点分析这个方法。</p><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>fork采用<strong>copy-on-write</strong>技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型：</p><ul><li>在父进程中，fork返回新创建的子进程pid。</li><li>在子进程中，fork返回0；</li><li>当出现错误时，fork返回负数。</li></ul><p>fork的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。</p><p> Zygote进程是所有Android进程的母体，包括system_server和各个App进程。</p><p>Zygote利用fork方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。</p><p><img src="/img/zygote_fork.jpeg" alt="fork()函数执行"></p><p>copy-on-write过程：</p><p>当父子进程任一方修改内存数据时（这是on-write时机），才发生缺页中断，从而分配新的物理内存（这是copy操作）。</p><p>copy-on-write原理：</p><p>写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常（page fault），Linux收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p><p>了解到上述知识后，来看看fork的代码：</p><blockquote><p>bionic/libc/bionic/fork.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fork</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 父进程回调此方法完成准备工作</span><br>  __bionic_atfork_run_prepare();<br><br>  <span class="hljs-keyword">pthread_internal_t</span>* self = __get_thread();<br><br>  <span class="hljs-comment">// clone是一个系统调用</span><br>  <span class="hljs-keyword">int</span> result = clone(<span class="hljs-literal">nullptr</span>,<br>                     <span class="hljs-literal">nullptr</span>,<br>                     (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD),<br>                     <span class="hljs-literal">nullptr</span>,<br>                     <span class="hljs-literal">nullptr</span>,<br>                     <span class="hljs-literal">nullptr</span>,<br>                     &amp;(self-&gt;tid));<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 子进程设置缓存pid</span><br>    self-&gt;set_cached_pid(gettid());<br><br>    android_fdsan_set_error_level(ANDROID_FDSAN_ERROR_LEVEL_DISABLED);<br><br>    <span class="hljs-comment">// 子进程回调</span><br>    __bionic_atfork_run_child();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 父进程回调</span><br>    __bionic_atfork_run_parent();<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行clone的前后都有相应的回调方法：</p><ul><li>__bionic_atfork_run_prepare： fork完成前，父进程回调方法</li><li>__bionic_atfork_run_child： fork完成后，子进程回调方法</li><li>__bionic_atfork_run_paren： fork完成后，父进程回调方法</li></ul><p>此三个方法的实现都位于bionic/pthread_atfork.cpp中，有需要的话可以扩展这些方法。</p><h4 id="SpecializeCommon"><a href="#SpecializeCommon" class="headerlink" title="SpecializeCommon"></a>SpecializeCommon</h4><p>在fork完成之后，子进程已经创建完毕，此时子进程会调用SpecializeCommon()方法。</p><blockquote><p>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecializeCommon</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">uid_t</span> uid, <span class="hljs-keyword">gid_t</span> gid, jintArray gids, jint runtime_flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                             jobjectArray rlimits, jlong permitted_capabilities,</span></span><br><span class="hljs-function"><span class="hljs-params">                             jlong effective_capabilities, jint mount_external,</span></span><br><span class="hljs-function"><span class="hljs-params">                             jstring managed_se_info, jstring managed_nice_name,</span></span><br><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">bool</span> is_system_server, <span class="hljs-keyword">bool</span> is_child_zygote,</span></span><br><span class="hljs-function"><span class="hljs-params">                             jstring managed_instruction_set, jstring managed_app_data_dir,</span></span><br><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">bool</span> is_top_app, jobjectArray pkg_data_info_list,</span></span><br><span class="hljs-function"><span class="hljs-params">                             jobjectArray allowlisted_data_info_list, <span class="hljs-keyword">bool</span> mount_data_dirs,</span></span><br><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">bool</span> mount_storage_dirs)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建进程组</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rc = createProcessGroup(uid, getpid());<br>        <span class="hljs-keyword">if</span> (rc == -EROFS) &#123;<br>            ALOGW(<span class="hljs-string">&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-number">0</span>) &#123;<br>            ALOGE(<span class="hljs-string">&quot;createProcessGroup(%d, %d) failed: %s&quot;</span>, uid, <span class="hljs-comment">/* pid= */</span> <span class="hljs-number">0</span>, strerror(-rc));<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 设置Gid</span><br>    SetGids(env, gids, is_child_zygote, fail_fn);<br>    <span class="hljs-comment">// 设置资源limit</span><br>    SetRLimits(env, rlimits, fail_fn);<br><br>    <span class="hljs-keyword">if</span> (need_pre_initialize_native_bridge) &#123;<br>        <span class="hljs-comment">// Due to the logic behind need_pre_initialize_native_bridge we know that</span><br>        <span class="hljs-comment">// instruction_set contains a value.</span><br>        android::PreInitializeNativeBridge(app_data_dir.has_value() ? app_data_dir.value().c_str()<br>                                                                    : <span class="hljs-literal">nullptr</span>,<br>                                           instruction_set.value().c_str());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (setresgid(gid, gid, gid) == <span class="hljs-number">-1</span>) &#123;<br>        fail_fn(CREATE_ERROR(<span class="hljs-string">&quot;setresgid(%d) failed: %s&quot;</span>, gid, strerror(errno)));<br>    &#125;<br><br>    SetUpSeccompFilter(uid, is_child_zygote);<br><br>    <span class="hljs-comment">// 设置调度策略</span><br>    SetSchedulerPolicy(fail_fn, is_top_app);<br><br>    ···<br><br>    <span class="hljs-comment">// 给子进程主线程设置一个名字</span><br>    <span class="hljs-keyword">if</span> (nice_name.has_value()) &#123;<br>        SetThreadName(nice_name.value());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_system_server) &#123;<br>        SetThreadName(<span class="hljs-string">&quot;system_server&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 恢复对于SIGCHLD信号的处理</span><br>    UnsetChldSignalHandler();<br><br>    <span class="hljs-keyword">if</span> (is_system_server) &#123;<br>        env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags);<br>        <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>            fail_fn(<span class="hljs-string">&quot;Error calling post fork system server hooks.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// TODO(b/117874058): Remove hardcoded label here.</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* kSystemServerLabel = <span class="hljs-string">&quot;u:r:system_server:s0&quot;</span>;<br>        <span class="hljs-keyword">if</span> (selinux_android_setcon(kSystemServerLabel) != <span class="hljs-number">0</span>) &#123;<br>            fail_fn(CREATE_ERROR(<span class="hljs-string">&quot;selinux_android_setcon(%s)&quot;</span>, kSystemServerLabel));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (is_child_zygote) &#123;<br>        initUnsolSocketToSystemServer();<br>    &#125;<br><br>    <span class="hljs-comment">// 等价于调用Zygote.callPostForkChildHooks</span><br>    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,<br>                              is_system_server, is_child_zygote, managed_instruction_set);<br><br>    <span class="hljs-comment">// 设置默认进程优先级</span><br>    setpriority(PRIO_PROCESS, <span class="hljs-number">0</span>, PROCESS_PRIORITY_DEFAULT);<br><br>    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>        fail_fn(<span class="hljs-string">&quot;Error calling post fork hooks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CallStaticVoidMethod方法使用JNI调用到了Zygote#callPostForkChildHooks方法。</p><h4 id="Zygote-callPostForkChildHooks"><a href="#Zygote-callPostForkChildHooks" class="headerlink" title="Zygote#callPostForkChildHooks"></a>Zygote#callPostForkChildHooks</h4><blockquote><p>frameworks/base/core/java/com/android/internal/os/Zygote.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callPostForkChildHooks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> runtimeFlags, <span class="hljs-keyword">boolean</span> isSystemServer,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> isZygote, String instructionSet)</span> </span>&#123;<br>    ZygoteHooks.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@libcore</span>.api.CorePlatformApi<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postForkChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> runtimeFlags, <span class="hljs-keyword">boolean</span> isSystemServer, <span class="hljs-keyword">boolean</span> isZygote,</span></span><br><span class="hljs-function"><span class="hljs-params">        String instructionSet)</span> </span>&#123;<br>    nativePostForkChild(token, runtimeFlags, isSystemServer, isZygote, instructionSet);<br><br>    Math.setRandomSeedInternal(System.currentTimeMillis());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里设置了进程的随机数种子为当前系统时间。</p><h5 id="nativePostForkChild"><a href="#nativePostForkChild" class="headerlink" title="nativePostForkChild"></a>nativePostForkChild</h5><blockquote><p>art/runtime/native/dalvik_system_ZygoteHooks.cc</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ZygoteHooks_nativePostForkChild</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jclass,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jlong token,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jint runtime_flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jboolean is_system_server,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jboolean is_zygote,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            jstring instruction_set)</span> </span>&#123;<br>  DCHECK(!(is_system_server &amp;&amp; is_zygote));<br><br>  <span class="hljs-comment">// 从之前保存的token中获得Thread对象</span><br>  Thread* thread = <span class="hljs-keyword">reinterpret_cast</span>&lt;Thread*&gt;(token);<br>  <span class="hljs-comment">// 重新设置线程tid</span><br>  thread-&gt;InitAfterFork();<br>  runtime_flags = EnableDebugFeatures(runtime_flags);<br>  <br>  ···<br><br>  <span class="hljs-comment">// 设置HiddenAPI的执行策略</span><br>  api_enforcement_policy = hiddenapi::EnforcementPolicyFromInt(<br>      (runtime_flags &amp; HIDDEN_API_ENFORCEMENT_POLICY_MASK) &gt;&gt; API_ENFORCEMENT_POLICY_SHIFT);<br>  runtime_flags &amp;= ~HIDDEN_API_ENFORCEMENT_POLICY_MASK;<br><br>  ···<br><br>  <span class="hljs-comment">// GC堆处理fork完成后的工作</span><br>  runtime-&gt;GetHeap()-&gt;PostForkChildAction(thread);<br>  <span class="hljs-keyword">if</span> (runtime-&gt;GetJit() != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!is_system_server) &#123;<br>      <span class="hljs-comment">// JIT编译器处理fork完成后的工作</span><br>      runtime-&gt;GetJit()-&gt;GetCodeCache()-&gt;PostForkChildAction(<br>          <span class="hljs-comment">/* is_system_server= */</span> <span class="hljs-literal">false</span>, is_zygote);<br>    &#125;<br>    runtime-&gt;GetJit()-&gt;PostForkChildAction(is_system_server, is_zygote);<br>  &#125;<br><br>  <span class="hljs-comment">// 验证hiddenAPI策略</span><br>  <span class="hljs-keyword">bool</span> do_hidden_api_checks = api_enforcement_policy != hiddenapi::EnforcementPolicy::kDisabled;<br>  DCHECK(!(is_system_server &amp;&amp; do_hidden_api_checks))<br>      &lt;&lt; <span class="hljs-string">&quot;SystemServer should be forked with EnforcementPolicy::kDisable&quot;</span>;<br>  DCHECK(!(is_zygote &amp;&amp; do_hidden_api_checks))<br>      &lt;&lt; <span class="hljs-string">&quot;Child zygote processes should be forked with EnforcementPolicy::kDisable&quot;</span>;<br>  runtime-&gt;SetHiddenApiEnforcementPolicy(api_enforcement_policy);<br>  runtime-&gt;SetDedupeHiddenApiWarnings(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (api_enforcement_policy != hiddenapi::EnforcementPolicy::kDisabled &amp;&amp;<br>      runtime-&gt;GetHiddenApiEventLogSampleRate() != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">std</span>::srand(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(NanoTime()));<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (is_zygote) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (instruction_set != <span class="hljs-literal">nullptr</span> &amp;&amp; !is_system_server) &#123;<br>    <span class="hljs-function">ScopedUtfChars <span class="hljs-title">isa_string</span><span class="hljs-params">(env, instruction_set)</span></span>;<br>    InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());<br>    Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;<br>    <span class="hljs-keyword">if</span> (isa != InstructionSet::kNone &amp;&amp; isa != kRuntimeISA) &#123;<br>      action = Runtime::NativeBridgeAction::kInitialize;<br>    &#125;<br>    <span class="hljs-comment">// app进程执行此方法初始化</span><br>    runtime-&gt;InitNonZygoteOrPostFork(env, is_system_server, action, isa_string.c_str());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    runtime-&gt;InitNonZygoteOrPostFork(<br>        env,<br>        is_system_server,<br>        Runtime::NativeBridgeAction::kUnload,<br>        <span class="hljs-comment">/*isa=*/</span> <span class="hljs-literal">nullptr</span>,<br>        profile_system_server);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Runtime-InitNonZygoteOrPostFork"><a href="#Runtime-InitNonZygoteOrPostFork" class="headerlink" title="Runtime#InitNonZygoteOrPostFork"></a>Runtime#InitNonZygoteOrPostFork</h4><blockquote><p>art/runtime/runtime.cc</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::InitNonZygoteOrPostFork</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    JNIEnv* env,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> is_system_server,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> is_child_zygote,</span></span><br><span class="hljs-function"><span class="hljs-params">    NativeBridgeAction action,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* isa,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> profile_system_server)</span> </span>&#123;<br>  <br>  ···<br><br>  <span class="hljs-comment">// 为GC堆创建线程池</span><br>  heap_-&gt;CreateThreadPool();<br><br>  <span class="hljs-keyword">if</span> (!is_system_server) &#123;<br>    <span class="hljs-function">ScopedTrace <span class="hljs-title">timing</span><span class="hljs-params">(<span class="hljs-string">&quot;CreateThreadPool&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kStackSize = <span class="hljs-number">64</span> * KB;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kMaxRuntimeWorkers = <span class="hljs-number">4u</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> num_workers =<br>        <span class="hljs-built_in">std</span>::min(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(<span class="hljs-built_in">std</span>::thread::hardware_concurrency()), kMaxRuntimeWorkers);<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(Thread::Current(), *Locks::runtime_thread_pool_lock_)</span></span>;<br>    CHECK(thread_pool_ == <span class="hljs-literal">nullptr</span>);<br>    thread_pool_.reset(<span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-string">&quot;Runtime&quot;</span>, num_workers, <span class="hljs-comment">/*create_peers=*/</span><span class="hljs-literal">false</span>, kStackSize));<br>    thread_pool_-&gt;StartWorkers(Thread::Current());<br>  &#125;<br><br>  <span class="hljs-comment">// 重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br>  heap_-&gt;ResetGcPerformanceInfo();<br>  GetMetrics()-&gt;Reset();<br>  <br>  ···<br><br>  <span class="hljs-comment">// 设置信号处理函数</span><br>  StartSignalCatcher();<br><br>  ···<br><br>  <span class="hljs-comment">// 启动JDWP线程</span><br>  GetRuntimeCallbacks()-&gt;StartDebugger();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码做了大量删减，只需要了解一下即可，不再继续深入。</p><h3 id="ZygoteHooks-postForkCommon"><a href="#ZygoteHooks-postForkCommon" class="headerlink" title="ZygoteHooks#postForkCommon"></a>ZygoteHooks#postForkCommon</h3><p>在执行完fork操作后，我们需要恢复之前停止的几条守护线程。</p><blockquote><p>libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postForkCommon</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在恢复守护线程之前通知一下Runtime</span><br>    nativePostZygoteFork();<br>    Daemons.startPostZygoteFork();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Runtime-PostZygoteFork"><a href="#Runtime-PostZygoteFork" class="headerlink" title="Runtime#PostZygoteFork"></a>Runtime#PostZygoteFork</h4><blockquote><p>art/runtime/runtime.cc</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::PostZygoteFork</span><span class="hljs-params">()</span> </span>&#123;<br>  jit::Jit* jit = GetJit();<br>  <span class="hljs-keyword">if</span> (jit != <span class="hljs-literal">nullptr</span>) &#123;<br>    jit-&gt;PostZygoteFork();<br>    <span class="hljs-comment">// 确保JIT中的线程有足够的优先级</span><br>    <span class="hljs-keyword">if</span> (kIsDebugBuild &amp;&amp; jit-&gt;GetThreadPool() != <span class="hljs-literal">nullptr</span>) &#123;<br>      jit-&gt;GetThreadPool()-&gt;CheckPthreadPriority(jit-&gt;GetThreadPoolPthreadPriority());<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 重设所有状态</span><br>  ResetStats(<span class="hljs-number">0xFFFFFFFF</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Daemons-startPostZygoteFork"><a href="#Daemons-startPostZygoteFork" class="headerlink" title="Daemons#startPostZygoteFork"></a>Daemons#startPostZygoteFork</h4><blockquote><p>libcore/libart/src/main/java/java/lang/Daemons.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPostZygoteFork</span><span class="hljs-params">()</span> </span>&#123;<br>    postZygoteFork = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (Daemon daemon : DAEMONS) &#123;<br>        daemon.startPostZygoteFork();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPostZygoteFork</span><span class="hljs-params">()</span> </span>&#123;<br>    postZygoteFork = <span class="hljs-keyword">true</span>;<br>    startInternal();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (thread != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;already running&quot;</span>);<br>    &#125;<br>    thread = <span class="hljs-keyword">new</span> Thread(ThreadGroup.systemThreadGroup, <span class="hljs-keyword">this</span>, name);<br>    thread.setDaemon(<span class="hljs-keyword">true</span>);<br>    thread.setSystemDaemon(<span class="hljs-keyword">true</span>);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>本节中的内容都在Zygote进程中，主要做了以下工作：</p><ol><li>Zygote通过Socket接收到SystemServer传递过来的创建进程请求。</li><li>Zygote通过Zygote.forkAndSpecialize方法创建子进程，这又分为几个步骤：<ul><li>preFork：停止Zygote中的4条守护线程，预初始化JIT和GC堆。</li><li>nativeForkAndSpecialize：调用fork()函数来创建新进程，设置新进程的gid、主线程的tid，重置GC数据，设置信号处理函数，启动JDWP线程等。</li><li>postForkCommon：重新启动停止的4条守护线程并通知JIT。</li></ul></li></ol><p>本节时序图如下所示。</p><p><img src="/img/zygote_create_app_process.jpg" alt="Zygote接收请求并创建App进程"></p><h2 id="App进程初始化"><a href="#App进程初始化" class="headerlink" title="App进程初始化"></a>App进程初始化</h2><p>在fork完成之后，子进程进入ZygoteConnection#handleChildProc方法中执行。</p><p>在Framework系列<a href="/2021/05/14/7ca6484e/#System-Server%E8%BF%9B%E7%A8%8B">第一篇</a>中分析了在fork出System Server进程后，System Server做了几个工作：</p><ul><li>初始化Log系统，设置时区、userAgent等</li><li>启动Binder线程池</li><li>执行Java main方法</li></ul><p>此处的App进程与SystemServer的工作十分类似，最终都会调用到RuntimeInit中的findStaticMain方法来执行Java main方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClassLoader classLoader)</span> </span>&#123;<br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一的区别是传入的className不同，App进程中的className在AMS中就被定义好，并通过Socket传递到Zygote进程中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br></code></pre></td></tr></table></figure><p>下面我们就来看看ActivityThread的main方法做了什么操作。</p><h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread#main"></a>ActivityThread#main</h3><p>我们知道Android App实际上是一个Java程序，那么Java程序都会有一个main方法作为程序入口，而ActivityThread中的main方法就是整个App的入口。</p><blockquote><p>frameworks/base/core/java/android/app/ActivityThread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 创建主线程Looper</span><br>    Looper.prepareMainLooper();<br><br>    ···<br>     <br>    <span class="hljs-comment">// 创建ActivityThread对象并调用其attach方法</span><br>    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();<br>    thread.attach(<span class="hljs-keyword">false</span>, startSeq);<br><br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br><br>    ···<br>    <br>    <span class="hljs-comment">// 开启主线程消息循环</span><br>    Looper.loop();<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法中创建了主线程Looper并且开启了消息循环。</p><p>Android的Handler机制相信大家已经相当熟悉，开启消息循环一方面能处理本线程和其他线程发送的事件，另一方面可以保证main方法一直在执行当中。</p><p>考虑到篇幅原因本篇不再继续深入分析attach方法，下面来总结一下上文。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个App进程的启动分为三个部分，涉及到三个进程。</p><ul><li>SystemServer进程：通过ActivityManagerService.startProcess发起创建进程请求，会先收集新进程的各种参数例如uid、gid、niceName等，通过Socket发送给Zygote进程。</li><li>Zygote进程：接收到SystemServer发送过来的参数后封装成Argument对象，通过forkAndSpecialize核心方法fork自身创建App进程，主要分为几步：<ul><li>preFork：停止Zygote的4个Daemon线程，仅保留主线程，初始化JIT和GC堆</li><li>nativeForkAndSpecialize：调用linux中fork()方法创建子进程，其中会创建Java堆线程的线程池、重置GC性能数据、设置子进程的崩溃信号处理函数、启动JDWP线程等</li><li>postForkCommon：重新启动守护线程</li></ul></li><li>App进程：从handleChildProc()方法进入App进程的执行，初始化Binder驱动、创建Binder线程池，设置ART虚拟机的参数，反射调用Java main方法，开启消息循环。</li></ul><p>其中AMS执行到ZygoteProcess中的attemptZygoteSendArgsAndGetResult会阻塞AMS线程，直到socket返回新进程的pid才会返回。</p><p>简化后的流程如下图所示。</p><p><img src="/img/process_creation.jpg" alt="process_creation"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:">Android API 29 Platform</a></li><li><a href="https://book.douban.com/subject/30358046/">《Android进阶解密》</a></li><li><a href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a></li><li><a href="http://gityuan.com/2016/03/26/app-process-create/">理解Android进程创建流程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（二）——Activity启动流程</title>
    <link href="/2021/05/22/4cb0a496/"/>
    <url>/2021/05/22/4cb0a496/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意（WARNING）：本文含有大量AOSP源码，阅读过程中如出现头晕、目眩、恶心、犯困等症状属正常情况，作者本人亦无法避免症状产生，故不承担任何法律责任。</p><p>本文所贴源码全部来自 Android API 29 Platform，即 Android 10.0。</p></blockquote><p>Android 中待启动的 Activity 分为两类，一种是 App 的Root Activity，也就是根Activity，另一种是普通的 Activity。</p><p>两类 Activity 的启动过程有不少重叠的部分，根 Activity 特殊的点在于，启动它时涉及到整个应用进程的启动，因此更具有指导意义。</p><p>本文将通过分析根Activity的启动过程来理解Android 10中Activity的启动流程。根 Activity 的启动过程分为三个部分，分别是：</p><ul><li><strong>Launcher 请求 ATMS 过程</strong></li><li><strong>ATMS 调用 ApplicationThread 过程</strong></li><li><strong>ActivityThread启动Activity过程</strong></li></ul><p>另外还涉及到目标App进程的启动过程，不过本文主要讨论Activity的启动流程，App进程的启动将会在下篇文章讲解。</p><p>下面就以这三个部分为基础来分析根 Activity 的启动过程。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>为了避免阅读源码过程中出现不适，这里先简单介绍一些后面会出现的相关类。</p><h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><ul><li><strong>ActivityThread</strong>：整个 App main 方法所在的类，所谓主线程就是指它所执行的线程，所以通常会称其为主线程。它负责管理应用程序进程的主线程的执行，处理 ATMS 的调度和执行Activity，Broadcast及相关操作。</li><li><strong>ApplicationThread</strong>：它是 ActivityThread 的一个内部类，继承自 IApplicationThread.Stub，是一个 IBinder。ActivityThread 通过它来进行 IPC 调用，与 SystemServer 通信。</li><li><strong>Intrumentation</strong>：用于监控应用程序与系统交互，启动 Activity 或者调用 Activity、Application 的生命周期都需要经过它的处理。</li><li><strong>ActivityTaskManager</strong>：Activity，Service 等与 ATMS 跨进程交互的接口，ATMS的辅助类。后文简称为 ATM。</li><li><strong>ActivityTaskManagerService</strong>：管理 Activity 和它的回退栈、任务栈的系统服务，Android 10以前是 AMS 的工作，Android 10中将部分工作从 AMS 抽离为 ATMS。后文将简称为 ATMS。</li><li><strong>ActivityRecord</strong>：system_server进程中用来描述Activity的数据类型。ActivityRecord中存储了Activity的信息，如所在的进程名称，应用的包名，所在的任务栈的taskAffinity等，与ActivityClientRecord、Activity的是一一对应关系。</li><li><strong>ActivityClientRecord</strong>：App进程中用来描述Activity的数据类型。</li><li><strong>TaskRecord</strong>：表示一个任务栈，记录了Activity启动的先后顺序，栈中严格按照先进后出的特性维护一系列ActivityRecord。</li><li><strong>ActivityStack</strong>：负责维护TaskRecord，内部保存了当前Stack中所有的Task列表。</li><li><strong>ActivityDisplay</strong>：管理所有ActivityStack，表示当前屏幕的抽象，内部维护了mHomeStack、mStacks、mPreferredToFocusableStack和mLastFocusedStack等ActivityStack。</li><li><strong>RootActivityContainer</strong>：Android10中新增的类，由ActivityStackSupervisor中抽离而来，其作为Activity容器的根节点，负责管理所有的ActivityDisplay。</li><li><strong>ActivityStackSupervisor</strong>：Android系统中Activity的最大管家，通过持有RootActivityContainer来间接管理所有的Activity。</li><li><strong>ClientLifecycleManager</strong>：组合多个客户端生命周期转换和请求，作为单个事务来执行。</li></ul><h3 id="Activity栈管理机制"><a href="#Activity栈管理机制" class="headerlink" title="Activity栈管理机制"></a>Activity栈管理机制</h3><p>Activity栈结构如下图所示。</p><p><img src="/img/activity_stack_model.jpg" alt="Activity栈管理模型"></p><p>用关系链表来表示它们的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityStackSupervisor.mRootActivityContainer<br>-&gt; RootActivityContainer.mActivityDisplays<br>-&gt; ActivityDisplay.mStacks<br>-&gt; ActivityStack.mTaskHistory<br>-&gt; TaskRecord.mActivities<br>-&gt; ActivityRecord<br></code></pre></td></tr></table></figure><h2 id="Launcher-请求-AMS-过程"><a href="#Launcher-请求-AMS-过程" class="headerlink" title="Launcher 请求 AMS 过程"></a>Launcher 请求 AMS 过程</h2><p>当我们启动系统时首先启动的App就是 Launcher，通过 Launcher 我们可以点击图标启动任何一个App，继而启动它的 Main Activity。整个过程发生在Launcher#startActivitySafely方法中。</p><h3 id="Launcher-startActivitySafely"><a href="#Launcher-startActivitySafely" class="headerlink" title="Launcher#startActivitySafely"></a>Launcher#startActivitySafely</h3><blockquote><p>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v, Intent intent, ItemInfo item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> String sourceContainer)</span> </span>&#123;<br>    ··· <br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">super</span>.startActivitySafely(v, intent, item, sourceContainer);<br>    ···<br>    <span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>startActivitySafely 方法继承自 BaseDraggingActivity：</p><blockquote><p>packages/apps/Launcher3/src/com/android/launcher3/BaseDraggingActivity.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v, Intent intent, <span class="hljs-meta">@Nullable</span> ItemInfo item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> String sourceContainer)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 1</span><br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>        intent.setSourceBounds(getViewBounds(v));<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> isShortcut = (item <span class="hljs-keyword">instanceof</span> WorkspaceItemInfo)<br>                &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT<br>                || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)<br>                &amp;&amp; !((WorkspaceItemInfo) item).isPromise();<br>        <span class="hljs-keyword">if</span> (isShortcut) &#123;<br>            <span class="hljs-comment">// Shortcuts need some special checks due to legacy reasons.</span><br>            startShortcutIntentSafely(intent, optsBundle, item, sourceContainer);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || user.equals(Process.myUserHandle())) &#123;<br>            <span class="hljs-comment">// Could be launching some bookkeeping activity</span><br>            <span class="hljs-comment">// 2</span><br>            startActivity(intent, optsBundle);<br>            AppLaunchTracker.INSTANCE.get(<span class="hljs-keyword">this</span>).onStartApp(intent.getComponent(),<br>                    Process.myUserHandle(), sourceContainer);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            getSystemService(LauncherApps.class).startMainActivity(<br>                    intent.getComponent(), user, intent.getSourceBounds(), optsBundle);<br>            AppLaunchTracker.INSTANCE.get(<span class="hljs-keyword">this</span>).onStartApp(intent.getComponent(), user,<br>                    sourceContainer);<br>        &#125;<br>        getUserEventDispatcher().logAppLaunch(v, intent, user);<br>        <span class="hljs-keyword">if</span> (item != <span class="hljs-keyword">null</span>) &#123;<br>            InstanceId instanceId = <span class="hljs-keyword">new</span> InstanceIdSequence().newInstanceId();<br>            logAppLaunch(item, instanceId);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException|ActivityNotFoundException|SecurityException e) &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>        Log.e(TAG, <span class="hljs-string">&quot;Unable to launch. tag=&quot;</span> + item + <span class="hljs-string">&quot; intent=&quot;</span> + intent, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码注释1处是我们比较熟悉的了，通过设置 FLAG_ACTIVITY_NEW_TASK flag让 Activity 在新的任务栈中启动。在注释 2 处会调用 startActivity 方法，这个 startActivity 方法在 Activity 中实现。</p><h3 id="Activity-startActivity"><a href="#Activity-startActivity" class="headerlink" title="Activity#startActivity"></a>Activity#startActivity</h3><blockquote><p>frameworks/base/core/java/android/app/Activity.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.startActivity(intent, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, <span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>        startActivityForResult(intent, -<span class="hljs-number">1</span>, options);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note we want to go through this call for compatibility with</span><br>        <span class="hljs-comment">// applications that may have overridden the method.</span><br>        startActivityForResult(intent, -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>startActivity 方法最终会调用到 startActivityForResult 方法并传入-1表示不需要返回。</p><h3 id="Activity-startActivityForResult"><a href="#Activity-startActivityForResult" class="headerlink" title="Activity#startActivityForResult"></a>Activity#startActivityForResult</h3><p>继续来看startActivityForResult：</p><blockquote><p>frameworks/base/core/java/android/app/Activity.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(<span class="hljs-meta">@RequiresPermission</span> Intent intent, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>    <span class="hljs-comment">// Activity mParent</span><br>    <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>        options = transferSpringboardActivityOptions(options);<br>        Instrumentation.ActivityResult ar =<br>            mInstrumentation.execStartActivity(<br>                <span class="hljs-keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-keyword">this</span>,<br>                intent, requestCode, options);<br>        <span class="hljs-keyword">if</span> (ar != <span class="hljs-keyword">null</span>) &#123;<br>            mMainThread.sendActivityResult(<br>                mToken, mEmbeddedID, requestCode, ar.getResultCode(),<br>                ar.getResultData());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (requestCode &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// If this start is requesting a result, we can avoid making</span><br>            <span class="hljs-comment">// the activity visible until the result is received.  Setting</span><br>            <span class="hljs-comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br>            <span class="hljs-comment">// activity hidden during this time, to avoid flickering.</span><br>            <span class="hljs-comment">// This can only be done when a result is requested because</span><br>            <span class="hljs-comment">// that guarantees we will get information back when the</span><br>            <span class="hljs-comment">// activity is finished, no matter what happens to it.</span><br>            mStartedActivity = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        cancelInputsAndStartExitTransition(options);<br>        <span class="hljs-comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>            mParent.startActivityFromChild(<span class="hljs-keyword">this</span>, intent, requestCode, options);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Note we want to go through this method for compatibility with</span><br>            <span class="hljs-comment">// existing applications that may have overridden it.</span><br>            mParent.startActivityFromChild(<span class="hljs-keyword">this</span>, intent, requestCode);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mParent 属性会在 Activity attach 时设置，表示 Activity 启动时的父 Activity，但 Main Activity 的 mParent 是为 null 的，因此会进入 if 判断中。if 代码块中调用到了 Instrumentation#execStartActivity，剩下都交给 Instrumentation 来处理。</p><h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation#execStartActivity"></a>Instrumentation#execStartActivity</h3><p>Instrumentation 类主要用来监控应用程序与系统交互，mMainThread 对象是 ActivityThread，通过 getApplicationThread 方法获取 ApplicationThread 对象。ApplicationThread 继承自 Stub，也就是 Binder，这为我们后面与 AMS 通信提供了基础。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IApplicationThread</span>.<span class="hljs-title">Stub</span></span><br></code></pre></td></tr></table></figure><p>继续跟踪源码，来到 Instrumentation#execStartActivity 方法中：</p><blockquote><p>frameworks/base/core/java/android/app/Instrumentation.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;<br>    IApplicationThread whoThread = (IApplicationThread) contextThread;<br>    ···<br>    <span class="hljs-keyword">try</span> &#123;<br>        intent.migrateExtraStreamToClipData();<br>        intent.prepareToLeaveProcess(who);<br>        <span class="hljs-keyword">int</span> result = ActivityTaskManager.getService()<br>            .startActivity(whoThread, who.getBasePackageName(), intent,<br>                    intent.resolveTypeIfNeeded(who.getContentResolver()),<br>                    token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,<br>                    requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);<br>        checkStartActivityResult(result, intent);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 binder IPC 调用到了 <strong>ActivityTaskManagerService（ATMS）</strong>中。</p><p>ATMS 是个远程服务，需要通过 ServiceManager 来获取，ServiceManager 底层最终调用的还是 Native 层的 ServiceManager，它是 Binder 的守护服务，通过它能够获取在 Android 系统启动时注册的系统服务，这其中就包含这里提到的 ATMS。获取服务的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityTaskManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> IActivityTaskManagerSingleton.get();<br>   &#125;<br><br>   <span class="hljs-meta">@UnsupportedAppUsage(trackingBug = 129726065)</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =<br>           <span class="hljs-keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityTaskManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>                   <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);<span class="hljs-comment">// 1</span><br>                   <span class="hljs-keyword">return</span> IActivityTaskManager.Stub.asInterface(b); <span class="hljs-comment">// 2</span><br>               &#125;<br>           &#125;;<br></code></pre></td></tr></table></figure><p>注释 1 处通过 ServiceManager 获取对应的系统服务，也就是 IBinder 类型的 ATMS 引用。注释 2 处将它转换成 ActivityTaskManager 类型的对象，这段代码采用的是 AIDL，IActivityTaskManager.java 类是由 AIDL 工具在编译时自动生成的，IActivityTaskManager.aidl 的文件路径为 frameworks/base/core/java/android/app/IActivityTaskManager.aidl。 要实现进程间通信，服务端也就是 ATMS 只需要继承 IActivityTaskManager.Stub 类并实现相应的方法也就可以了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们回顾一下 Launcher 所做工作，startActivity 最终都会调用到 startActivityForResult，而启动一个 Activity 必须通过系统服务来执行，因此会使用 Launcher 的 ApplicationThread 来发起一次 IPC 调用，最终在 Instrumentation#execStartActivitiesAsUser 中请求 ATMS 来启动 Activity。</p><p>这个过程的时序图如下所示。</p><p><img src="/img/framework_launcher_start_activity.jpg" alt="Launcher请求ATMS过程时序图"></p><h2 id="ATMS-到-ApplicationThread-的调用过程"><a href="#ATMS-到-ApplicationThread-的调用过程" class="headerlink" title="ATMS 到 ApplicationThread 的调用过程"></a>ATMS 到 ApplicationThread 的调用过程</h2><p>Launcher 请求 AMS 后 ，代码逻辑已经进入 ATMS 中，接着是 ATMS 到 ApplicationThread 的调用流程。</p><h3 id="ActivityTaskManagerService-startActivity"><a href="#ActivityTaskManagerService-startActivity" class="headerlink" title="ActivityTaskManagerService#startActivity"></a>ActivityTaskManagerService#startActivity</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">    Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>            resultWho, requestCode, startFlags, profilerInfo, bOptions,<br>            UserHandle.getCallingUserId());<br>&#125;<br></code></pre></td></tr></table></figure><p>ATMS中会调用startActivityAsUser方法，这里需要注意一点就是startActivityAsUser方法比startActivity多了一个参数，为UserHandle.getCallingUserId()，ATMS根据这个参数来判断调用者的权限。</p><h3 id="ActivityTaskManagerService-startActivityAsUser"><a href="#ActivityTaskManagerService-startActivityAsUser" class="headerlink" title="ActivityTaskManagerService#startActivityAsUser"></a>ActivityTaskManagerService#startActivityAsUser</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> validateIncomingUser)</span> </span>&#123;<br>    <span class="hljs-comment">// 1</span><br>    enforceNotIsolatedCaller(<span class="hljs-string">&quot;startActivityAsUser&quot;</span>);<br><br>    <span class="hljs-comment">// 2</span><br>    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,<br>            Binder.getCallingPid(), Binder.getCallingUid(), <span class="hljs-string">&quot;startActivityAsUser&quot;</span>);<br><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="hljs-string">&quot;startActivityAsUser&quot;</span>)<br>            .setCaller(caller)<br>            .setCallingPackage(callingPackage)<br>            .setResolvedType(resolvedType)<br>            .setResultTo(resultTo)<br>            .setResultWho(resultWho)<br>            .setRequestCode(requestCode)<br>            .setStartFlags(startFlags)<br>            .setProfilerInfo(profilerInfo)<br>            .setActivityOptions(bOptions)<br>            .setMayWait(userId)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>注释1处判断调用者进程是否被隔离，如果被隔离则抛出SecurityException异常。</p><p>注释2处检查调用者是否有权限，如果没有权限也会抛出SecurityException异常。</p><p>注释3出通过ActivityStartController来获取一个ActivityStarter，并且配置了一些参数，这里要注意setMayWait方法传入了userId，会将ActivityStarter的mayWait属性置为true，后面会用到。</p><p>ActivityStarter是Android 7.0中新加入的类，它是加载Activity的控制类，会收集所有的逻辑来决定如何将 Intent和Flags转换为Activity，并将 Activity和Task以及Stack相关联。 </p><h3 id="ActivityStarter-execute"><a href="#ActivityStarter-execute" class="headerlink" title="ActivityStarter#execute"></a>ActivityStarter#execute</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (mRequest.mayWait) &#123;<br>            <span class="hljs-keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,<br>                    mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,<br>                    mRequest.intent, mRequest.resolvedType,<br>                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,<br>                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,<br>                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,<br>                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,<br>                    mRequest.inTask, mRequest.reason,<br>                    mRequest.allowPendingRemoteAnimationRegistryLookup,<br>                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ···<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        onExecutionComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于mRequest.mayWait被置为true，因此会调用startActivityMayWait方法。startActivityMayWait多了几个参数，需要注意的是TaskRecord代表启动Activity所在的栈。</p><h3 id="ActivityStarter-startActivityMayWait"><a href="#ActivityStarter-startActivityMayWait" class="headerlink" title="ActivityStarter#startActivityMayWait"></a>ActivityStarter#startActivityMayWait</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityMayWait</span><span class="hljs-params">(IApplicationThread caller, <span class="hljs-keyword">int</span> callingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">        String callingPackage, <span class="hljs-keyword">int</span> requestRealCallingPid, <span class="hljs-keyword">int</span> requestRealCallingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, String resolvedType, IVoiceInteractionSession voiceSession,</span></span><br><span class="hljs-function"><span class="hljs-params">        IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, WaitResult outResult,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration globalConfig, SafeActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> userId, TaskRecord inTask, String reason,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingIntentRecord originatingPendingIntent, <span class="hljs-keyword">boolean</span> allowBackgroundActivityStart)</span> </span>&#123;<br>    <span class="hljs-comment">// intent中不允许携带文件描述符</span><br>    <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.hasFileDescriptors()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;File descriptors passed in Intent&quot;</span>);<br>    &#125;<br>    ··· <br>    <span class="hljs-comment">// 解析Intent</span><br>    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,<br>            <span class="hljs-number">0</span> <span class="hljs-comment">/* matchFlags */</span>,<br>                    computeResolveFilterUid(<br>                            callingUid, realCallingUid, mRequest.filterCallingUid));<br>    ···<br>    <span class="hljs-comment">// 解析Activity信息，当有多个可供选择时在这里弹出选择框</span><br>    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);<br><br>    <span class="hljs-keyword">synchronized</span> (mService.mGlobalLock) &#123;<br>        ··· <br>        <span class="hljs-comment">// 启动Activity</span><br>        <span class="hljs-keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,<br>                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,<br>                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,<br>                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,<br>                allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,<br>                allowBackgroundActivityStart);<br>        ···<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>startActivityMayWait较为复杂，其中关键的几点都已经用注释标注，主要是通过解析Intent来获取将要启动的Activity信息。</p><h3 id="ActivityStarter-startActivity"><a href="#ActivityStarter-startActivity" class="headerlink" title="ActivityStarter#startActivity"></a>ActivityStarter#startActivity</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="hljs-function"><span class="hljs-params">         String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">         IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">         IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">         String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">         SafeActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span></span><br><span class="hljs-function"><span class="hljs-params">         TaskRecord inTask, <span class="hljs-keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="hljs-function"><span class="hljs-params">         PendingIntentRecord originatingPendingIntent, <span class="hljs-keyword">boolean</span> allowBackgroundActivityStart)</span> </span>&#123;<br>     ···<br>     <span class="hljs-comment">// 此处创建了一个ActivityRecord对象</span><br>     <span class="hljs-comment">// 同时会通过ActivityRecord和intent构建appToken</span><br>     ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,<br>             callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),<br>             resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,<br>             mSupervisor, checkedOptions, sourceRecord);<br>     <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;<br>         outActivity[<span class="hljs-number">0</span>] = r;<br>     &#125;<br><br>    ......<br><br>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> res = startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,<br>             <span class="hljs-keyword">true</span> <span class="hljs-comment">/* doResume */</span>, checkedOptions, inTask, outActivity, restrictedBgActivity);<span class="hljs-comment">//4</span><br>     .....<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><p>startActivity中有个关键点就是，将要启动的Activity的<strong>ActivityRecord</strong>对象在这里被创建。ActivityRecord构建的同时会根据ActivityRecord和intent创建一个<strong>appToken</strong>。appToken是一个IBinder对象，用于提供给WMS关联Window和Activity，后面文章会详细分析。startActivity调用了另一个startActivity的重载，继而调用到了startActivityUnchecked方法。</p><h3 id="ActivityStarter-startActivityUnchecked"><a href="#ActivityStarter-startActivityUnchecked" class="headerlink" title="ActivityStarter#startActivityUnchecked"></a>ActivityStarter#startActivityUnchecked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置初始状态值，这里的r赋值给mStartActivity</span><br>        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,<br>                voiceInteractor);<br>        <span class="hljs-comment">// 计算启动task的标志位Flag</span><br>        <span class="hljs-comment">// 主要处理一些Intent Flag冲突、复用问题</span><br>        <span class="hljs-comment">// 以及SingleInstance和SingleTask的处理</span><br>        computeLaunchingTaskFlags();<br>  <br>        <span class="hljs-comment">// 通过sourceActivity计算sourceTask</span><br>        <span class="hljs-comment">// 主要处理 FLAG_ACTIVITY_NEW_TASK 问题</span><br>        computeSourceStack();<br>  <br>        mIntent.setFlags(mLaunchFlags);<br><br>        <span class="hljs-comment">// 寻找是否有可以复用的ActivityRecord</span><br>        ActivityRecord reusedActivity = getReusableIntentActivity();<br>        ···<br>        <span class="hljs-keyword">if</span> (mReusedActivity != <span class="hljs-keyword">null</span>) &#123;<br>            ···<br>            <span class="hljs-comment">// 将当前栈移至前台</span><br>            mReusedActivity = setTargetStackAndMoveToFrontIfNeeded(mReusedActivity);<br>　　　　　    ···<br>            setTaskFromIntentActivity(mReusedActivity);<br><br>            <span class="hljs-keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="hljs-keyword">null</span>) &#123;<br>                resumeTargetStackIfNeeded();<br>                <span class="hljs-keyword">return</span> START_TASK_TO_FRONT;<br>            &#125;<br>        &#125;<br>　　　　 ···<br>     　　<span class="hljs-comment">//singleTop 或者singleInstance的处理</span><br>        <span class="hljs-keyword">if</span> (dontStart) &#123;<br>            <span class="hljs-comment">// For paranoia, make sure we have correctly resumed the top activity.</span><br>            topStack.mLastPausedActivity = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>                mRootActivityContainer.resumeFocusedStacksTopActivities();<br>            &#125;<br>            ActivityOptions.abort(mOptions);<br>            <span class="hljs-keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// We don&#x27;t need to start a new activity, and the client said not to do</span><br>                <span class="hljs-comment">// anything if that is the case, so this is it!</span><br>                <span class="hljs-keyword">return</span> START_RETURN_INTENT_TO_CALLER;<br>            &#125;<br>            ···<br>            <span class="hljs-comment">// 向已存在的Activity分发新的Intent</span><br>            <span class="hljs-comment">// 会回调其onNewIntent()方法</span><br>            deliverNewIntent(top);<br>　　    　   ···<br>            <span class="hljs-keyword">return</span> START_DELIVERED_TO_TOP;<br>        &#125;<br>  <br>        <span class="hljs-keyword">boolean</span> newTask = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">final</span> TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="hljs-keyword">null</span>)<br>                ? mSourceRecord.getTaskRecord() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 设置对应的task</span><br>        <span class="hljs-keyword">int</span> result = START_SUCCESS;<br>        <span class="hljs-keyword">if</span> (mStartActivity.resultTo == <span class="hljs-keyword">null</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span> &amp;&amp; !mAddingToTask<br>                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="hljs-number">0</span>) &#123;<br>            newTask = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// intent设置了FLAG_ACTIVITY_NEW_TASK，新建task</span><br>            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 设置sourceRecord所在栈，即standard启动模式</span><br>            result = setTaskFromSourceRecord();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mInTask != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 指定了启动的taskAffinity，设置到对应的task中</span><br>            result = setTaskFromInTask();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在当前焦点的task中启动，这种情况不会发生</span><br>            result = setTaskToCurrentTopOrCreateNewTask();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result != START_SUCCESS) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        ··· <br>        <span class="hljs-comment">// mDoResume由外部传入，本次流程中为true</span><br>        <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>            <span class="hljs-comment">// 使用ActivityStaskSupervisor去显示该Activity</span><br>            <span class="hljs-keyword">final</span> ActivityRecord topTaskActivity =<br>                    mStartActivity.getTaskRecord().topRunningActivityLocked();<br>            <span class="hljs-keyword">if</span> (!mTargetStack.isFocusable()<br>                    || (topTaskActivity != <span class="hljs-keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay<br>                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;<br>                <span class="hljs-comment">// If the activity is not focusable, we can&#x27;t resume it, but still would like to</span><br>                <span class="hljs-comment">// make sure it becomes visible as it starts (this will also trigger entry</span><br>                <span class="hljs-comment">// animation). An example of this are PIP activities.</span><br>                <span class="hljs-comment">// Also, we don&#x27;t want to resume activities in a task that currently has an overlay</span><br>                <span class="hljs-comment">// as the starting activity just needs to be in the visible paused state until the</span><br>                <span class="hljs-comment">// over is removed.</span><br>                mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);<br>                <span class="hljs-comment">// Go ahead and tell window manager to execute app transition for this activity</span><br>                <span class="hljs-comment">// since the app transition will not be triggered through the resume channel.</span><br>                mTargetStack.getDisplay().mDisplayContent.executeAppTransition();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前activity是可以获取焦点的但当前Stack没有获取焦点</span><br>                <span class="hljs-keyword">if</span> (mTargetStack.isFocusable()<br>                        &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;<br>                    <span class="hljs-comment">// 将对应Task移至前台</span><br>                    mTargetStack.moveToFront(<span class="hljs-string">&quot;startActivityUnchecked&quot;</span>);<br>                &#125;<br>                 <span class="hljs-comment">// 使栈顶activity可见，即resume状态</span><br>                 mRootActivityContainer.resumeFocusedStacksTopActivities(<br>                        mTargetStack, mStartActivity, mOptions);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mStartActivity != <span class="hljs-keyword">null</span>) &#123;<br>            mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());<br>        &#125;<br>        mRootActivityContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);<br><br>        mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTaskRecord(),<br>                preferredWindowingMode, mPreferredDisplayId, mTargetStack);<br><br>        <span class="hljs-keyword">return</span> START_SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure><p>startActivityUnchecked主要处理任务栈相关，处理singleTop、singleInstance问题，计算Intent Flag，以及栈顶复用问题。接着调用了调用了RootActivityContainer的resumeFocusedStacksTopActivities方法。</p><h3 id="RootActivityContainer-resumeFocusedStacksTopActivities"><a href="#RootActivityContainer-resumeFocusedStacksTopActivities" class="headerlink" title="RootActivityContainer#resumeFocusedStacksTopActivities"></a>RootActivityContainer#resumeFocusedStacksTopActivities</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeFocusedStacksTopActivities</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;<br><br>        ......<br><br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (targetStack != <span class="hljs-keyword">null</span> &amp;&amp; (targetStack.isTopStackOnDisplay()<br>                || getTopDisplayFocusedStack() == targetStack)) &#123; <br>            <span class="hljs-comment">// 使栈顶Activity可见（resume）</span><br>            result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);<br>        &#125;<br><br>        .......<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>resumeFocusedStacksTopActivities方法中调用ActivityStack#resumeTopActivityUncheckedLocked启动栈顶的Activity。</p><h3 id="ActivityStack-resumeTopActivityUncheckedLocked"><a href="#ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="ActivityStack#resumeTopActivityUncheckedLocked"></a>ActivityStack#resumeTopActivityUncheckedLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mInResumeTopActivity) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 防止递归调用，确保只有一个Activity执行该方法</span><br>        mInResumeTopActivity = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// resume栈顶Activity</span><br>        result = resumeTopActivityInnerLocked(prev, options);<br><br>        <span class="hljs-keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span> || !next.canTurnScreenOn()) &#123;<br>            checkReadyForSleep();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInResumeTopActivity = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>inResumeTopActivity用于保证每次只有一个Activity执行resumeTopActivityUncheckedLocked()操作。</p><h3 id="ActivityStack-resumeTopActivityInnerLocked"><a href="#ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="ActivityStack#resumeTopActivityInnerLocked"></a>ActivityStack#resumeTopActivityInnerLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 获取栈顶未finish的activity</span><br>    ActivityRecord next = topRunningActivityLocked(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>    ···<br>    <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;<br>        ···<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ···<br>        mStackSupervisor.startSpecificActivityLocked(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>resumeTopActivityInnerLocked方法的逻辑非常复杂，主要是判断当前是否真的需要resume栈顶Activity。这里精简了一下，当我们的栈顶activity没有绑定到任何Application的时候，就会调用ActivityStackSupervisor#startSpecificActivityLocked，我们此时恰好就是这种情况。</p><h3 id="ActivityStackSupervisor-startSpecificActivityLocked"><a href="#ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="ActivityStackSupervisor#startSpecificActivityLocked"></a>ActivityStackSupervisor#startSpecificActivityLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过ATMS获取目标进程的WindowProcessController对象</span><br>    <span class="hljs-comment">// WindowProcessController用于ActivityManager与WindowManager同步进程状态</span><br>    <span class="hljs-comment">// 如果wpc为空，则表示对应进程不存在或者未启动</span><br>    <span class="hljs-keyword">final</span> WindowProcessController wpc =<br>            mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br><br>    <span class="hljs-keyword">boolean</span> knownToBeDead = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 这里的hasThread表示的是IApplicationThread</span><br>    <span class="hljs-keyword">if</span> (wpc != <span class="hljs-keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 启动activity</span><br>            realStartActivityLocked(r, wpc, andResume, checkConfig);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Exception when starting activity &quot;</span><br>                    + r.intent.getComponent().flattenToShortString(), e);<br>        &#125;<br><br>        <span class="hljs-comment">// If a dead object exception was thrown -- fall through to</span><br>        <span class="hljs-comment">// restart the application.</span><br>        knownToBeDead = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里主要处理键盘锁问题</span><br>    <span class="hljs-keyword">if</span> (getKeyguardController().isKeyguardLocked()) &#123;<br>        r.notifyUnknownVisibilityLaunched();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>        <span class="hljs-comment">// 如果对应App进程还未启动</span><br>        <span class="hljs-comment">// 通过handler发送消息启动进程</span><br>        <span class="hljs-comment">// 这部分将在下文讨论</span><br>        <span class="hljs-keyword">final</span> Message msg = PooledLambda.obtainMessage(<br>                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,<br>                r.info.applicationInfo, knownToBeDead, <span class="hljs-string">&quot;activity&quot;</span>, r.intent.getComponent());<br>        mService.mH.sendMessage(msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>realStartActivityLocked中将会真正启动一个Activity。</p><h3 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor#realStartActivityLocked"></a>ActivityStackSupervisor#realStartActivityLocked</h3><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</p></blockquote><p>realStartActivityLocked方法中创建了一个启动Activity事务，并利用IApplicationThread发送到目标App中，精简后的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            ···<br>            <span class="hljs-comment">// 创建一个启动Activity事务.</span><br>            <span class="hljs-keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(<br>                    proc.getThread(), r.appToken);<br><br>            <span class="hljs-keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;<br>            <span class="hljs-comment">// 添加Callback，注意这里创建的是LaunchActivityItem</span><br>            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="hljs-keyword">new</span> Intent(r.intent),<br>                    System.identityHashCode(r), r.info,<br>                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global</span><br>                    <span class="hljs-comment">// and override configs.</span><br>                    mergedConfiguration.getGlobalConfiguration(),<br>                    mergedConfiguration.getOverrideConfiguration(), r.compat,<br>                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),<br>                    r.icicle, r.persistentState, results, newIntents,<br>                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),<br>                            r.assistToken));<br><br>            <span class="hljs-comment">// 设置此次事务应该执行的最终状态</span><br>            <span class="hljs-comment">// 此次流程将会设置为resume，表示activity应该执行到onResume状态</span><br>            <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem;<br>            <span class="hljs-keyword">if</span> (andResume) &#123;<br>                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lifecycleItem = PauseActivityItem.obtain();<br>            &#125;<br>            clientTransaction.setLifecycleStateRequest(lifecycleItem);<br><br>            <span class="hljs-comment">// 执行事务</span><br>            mService.getLifecycleManager().scheduleTransaction(clientTransaction);<br>    ···<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从Android 8.0开始Activity的启动将会通过事务来完成，事务将会通过目标App的IApplicationThread远程发送到目标App中，然后通过ClientLifecycleManager 来执行。至此ATMS中执行的逻辑就结束了，剩下的就是目标App的ApplicationThread来执行目标Activity的各个生命周期方法了。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>同样的来回顾一下ATMS所做的工作。</p><ul><li>首先ATMS会判断权限信息，只有具有权限的调用进程才可以启动Activity。</li><li>接着ActivityStarter解析Intent的内容，创建对应的ActivityRecord对象，根据是否需要新建Task来新建或者选择对应的TaskRecord添加Activity，并处理Task相关状态信息，例如前后台的转移。</li><li>然后就会使前台Task的栈顶Activity可见，这个过程就会启动对应的Activity，必要情况会启动对应的进程。</li><li>最后通过IPC调用将启动Activity的事务发送到对应进程中，交由对应App来处理。</li></ul><p>这部分的时序图如下所示。</p><p><img src="/img/framework_atms_start_activity.jpg" alt="ATMS执行时序图"></p><h2 id="ActivityThread启动Activity过程"><a href="#ActivityThread启动Activity过程" class="headerlink" title="ActivityThread启动Activity过程"></a>ActivityThread启动Activity过程</h2><p>经过ATMS的一系列调用后，Activity启动工作终于来到了目标App进程中。</p><p>所谓的目标进程，是指目标Activity所在的进程。它与原Activity属于同一进程，也就是App内的Activity启动；也有可能属于另外一个App，这种情况属于跨App启动Activity。</p><p>不管是在App内启动还是跨App启动，其流程是一致的，都是由ApplicationThread接收到Binder通信传递过来的事务开始执行。</p><h3 id="ApplicationThread-scheduleTransaction"><a href="#ApplicationThread-scheduleTransaction" class="headerlink" title="ApplicationThread#scheduleTransaction"></a>ApplicationThread#scheduleTransaction</h3><blockquote><p>frameworks/base/core/java/android/app/ActivityThread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>    ActivityThread.<span class="hljs-keyword">this</span>.scheduleTransaction(transaction);<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationThread#scheduleTransaction调用了ActivityThread#scheduleTransaction将事务交给主线程处理，ActivityThread#scheduleTransaction方法定义在其父类<strong>ClientTransactionHandler</strong>中。</p><h3 id="ClientTransactionHandler-scheduleTransaction"><a href="#ClientTransactionHandler-scheduleTransaction" class="headerlink" title="ClientTransactionHandler#scheduleTransaction"></a>ClientTransactionHandler#scheduleTransaction</h3><blockquote><p>frameworks/base/core/java/android/app/ClientTransactionHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    transaction.preExecute(<span class="hljs-keyword">this</span>);<br>    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用sendMessage方法往主线程发送了一条what为<strong>ActivityThread.H.EXECUTE_TRANSACTION</strong>的消息，并将事务传递。</p><h3 id="ActivityThread-sendMessage"><a href="#ActivityThread-sendMessage" class="headerlink" title="ActivityThread#sendMessage"></a>ActivityThread#sendMessage</h3><p>ApplicationThread运行在Binder线程，与ActivityThread通信需经过Handler，而H是ActivityThread中的一个内部类，它继承自Handler，当ActivityThread调用sendMessage方法时其实就是在调用H#sendMessage。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) &#123;<br>        Slog.v(TAG,<br>                <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what) + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>    &#125;<br>    Message msg = Message.obtain();<br>    msg.what = what;<br>    msg.obj = obj;<br>    msg.arg1 = arg1;<br>    msg.arg2 = arg2;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    mH.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="H-handleMessage"><a href="#H-handleMessage" class="headerlink" title="H#handleMessage"></a>H#handleMessage</h3><p>现在我们知道H是Handler的话，就知道消息一定在其handlerMessage方法中进行处理，来看看对应的消息是如何处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>    <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>        <span class="hljs-comment">// 省略一些case</span><br>        ···<br>        <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>            <span class="hljs-keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;<br>            mTransactionExecutor.execute(transaction);<br>            <span class="hljs-keyword">if</span> (isSystem()) &#123;<br>                <span class="hljs-comment">// Client transactions inside system process are recycled on the client side</span><br>                <span class="hljs-comment">// instead of ClientLifecycleManager to avoid being cleared before this</span><br>                <span class="hljs-comment">// message is handled.</span><br>                transaction.recycle();<br>            &#125;<br>            <span class="hljs-comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 省略一些case</span><br>        ···<br>    &#125;<br>    Object obj = msg.obj;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> SomeArgs) &#123;<br>        ((SomeArgs) obj).recycle();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中使用TransactionExecutor#execute来执行事务。</p><h3 id="TransactionExecutor-execute"><a href="#TransactionExecutor-execute" class="headerlink" title="TransactionExecutor#execute"></a>TransactionExecutor#execute</h3><p>TransactionExecutor是专门用于处理事务的类，用于保证事务以正确的顺序执行。</p><blockquote><p>frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Start resolving transaction&quot;</span>);<br>    <span class="hljs-comment">// ActivityRecord中的appToken</span><br>    <span class="hljs-keyword">final</span> IBinder token = transaction.getActivityToken();<br>    ···<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler));<br>    <span class="hljs-comment">// 执行所有Callback</span><br>    executeCallbacks(transaction);<br>    <span class="hljs-comment">// 执行到对应生命周期</span><br>    executeLifecycleState(transaction);<br>    mPendingActions.clear();<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;End resolving transaction&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>之前我们在<strong>ActivityStackSupervisor</strong>中创建事务并且通过<strong>addCallback</strong>的的方式将其添加到ClientTransaction中，现在调用executeCallbacks来执行每个Callback。</p><h3 id="TransactionExecutor-executeCallbacks"><a href="#TransactionExecutor-executeCallbacks" class="headerlink" title="TransactionExecutor#executeCallbacks"></a>TransactionExecutor#executeCallbacks</h3><blockquote><p>frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeCallbacks</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();<br>    <span class="hljs-keyword">if</span> (callbacks == <span class="hljs-keyword">null</span> || callbacks.isEmpty()) &#123;<br>        <span class="hljs-comment">// 快速返回路径</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Resolving callbacks in transaction&quot;</span>);<br><br>    <span class="hljs-keyword">final</span> IBinder token = transaction.getActivityToken();<br>    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);<br><br>    <span class="hljs-keyword">final</span> ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> finalState = finalStateRequest != <span class="hljs-keyword">null</span> ? finalStateRequest.getTargetState()<br>            : UNDEFINED;<br>    <span class="hljs-comment">// Index of the last callback that requests some post-execution state.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> lastCallbackRequestingState = lastCallbackRequestingState(transaction);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = callbacks.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> ClientTransactionItem item = callbacks.get(i);<br>        <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Resolving callback: &quot;</span> + item);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> postExecutionState = item.getPostExecutionState();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> closestPreExecutionState = mHelper.getClosestPreExecutionState(r,<br>                item.getPostExecutionState());<br>        <span class="hljs-keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;<br>            <span class="hljs-comment">// 这个方法可以平滑的执行生命周期</span><br>            cycleToPath(r, closestPreExecutionState, transaction);<br>        &#125;<br>        <span class="hljs-comment">// 执行item的execute方法</span><br>        item.execute(mTransactionHandler, token, mPendingActions);<br>        item.postExecute(mTransactionHandler, token, mPendingActions);<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Launch activity request will create an activity record.</span><br>            r = mTransactionHandler.getActivityClient(token);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Skip the very last transition and perform it by explicit state request instead.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldExcludeLastTransition =<br>                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;<br>            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上节代码我们知道启动Activity时创建的ClientTransactionItem为<strong>LaunchActivityItem</strong>，后面将执行它的execute方法。</p><h3 id="LaunchActivityItem-execute"><a href="#LaunchActivityItem-execute" class="headerlink" title="LaunchActivityItem#execute"></a>LaunchActivityItem#execute</h3><blockquote><p>frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;activityStart&quot;</span>);<br>    ActivityClientRecord r = <span class="hljs-keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,<br>            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,<br>            mPendingResults, mPendingNewIntents, mIsForward,<br>            mProfilerInfo, client, mAssistToken);<br>    <span class="hljs-comment">// 处理启动Activity前的事项</span><br>    client.handleLaunchActivity(r, pendingActions, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);<br>&#125;<br></code></pre></td></tr></table></figure><p>client是ActivityThread，方法中调用ActivityThread#handleLaunchActivity来启动Activity。</p><h3 id="ActivityThread-handleLaunchActivity"><a href="#ActivityThread-handleLaunchActivity" class="headerlink" title="ActivityThread#handleLaunchActivity"></a>ActivityThread#handleLaunchActivity</h3><blockquote><p>frameworks/base/core/java/android/app/ActivityThread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 初始化WindowManager</span><br>    WindowManagerGlobal.initialize();<br>    ···<br>    <span class="hljs-comment">// 启动Activity</span><br>    <span class="hljs-keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<br>    ···<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>Activity启动的核心代码都在performLaunchActivity方法里。</p><h3 id="ActivityThread-performLaunchActivity"><a href="#ActivityThread-performLaunchActivity" class="headerlink" title="ActivityThread#performLaunchActivity"></a>ActivityThread#performLaunchActivity</h3><blockquote><p>frameworks/base/core/java/android/app/ActivityThread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 为Activity创建Context</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    Activity activity = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 反射创建Activity对象</span><br>        java.lang.ClassLoader cl = appContext.getClassLoader();<br>        activity = mInstrumentation.newActivity(<br>                cl, component.getClassName(), r.intent);<br>        StrictMode.incrementExpectedActivityCount(activity.getClass());<br>        r.intent.setExtrasClassLoader(cl);<br>        r.intent.prepareToEnterProcess();<br>        <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>            r.state.setClassLoader(cl);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Unable to instantiate activity &quot;</span> + component<br>                + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取Application实例</span><br>        Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);<br>        ···<br>        <span class="hljs-keyword">if</span> (activity != <span class="hljs-keyword">null</span>) &#123;<br>            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());<br>            Configuration config = <span class="hljs-keyword">new</span> Configuration(mCompatConfiguration);<br>            <span class="hljs-keyword">if</span> (r.overrideConfig != <span class="hljs-keyword">null</span>) &#123;<br>                config.updateFrom(r.overrideConfig);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="hljs-string">&quot;Launching activity &quot;</span><br>                    + r.activityInfo.name + <span class="hljs-string">&quot; with config &quot;</span> + config);<br>            Window window = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (r.mPendingRemoveWindow != <span class="hljs-keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;<br>                window = r.mPendingRemoveWindow;<br>                r.mPendingRemoveWindow = <span class="hljs-keyword">null</span>;<br>                r.mPendingRemoveWindowManager = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            appContext.setOuterContext(activity);<br>            <span class="hljs-comment">// 调用activity.attach进行初始化</span><br>            <span class="hljs-comment">// 建立Context与Activity的联系，Window将会在这里创建</span><br>            <span class="hljs-comment">// 后面会出文章详解</span><br>            activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>                    r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                    r.embeddedID, r.lastNonConfigurationInstances, config,<br>                    r.referrer, r.voiceInteractor, window, r.configCallback,<br>                    r.assistToken);<br><br>            ···<br>            <span class="hljs-comment">// 回调onCreate</span><br>            <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!activity.mCalled) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>                    <span class="hljs-string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +<br>                    <span class="hljs-string">&quot; did not call through to super.onCreate()&quot;</span>);<br>            &#125;<br>            r.activity = activity;<br>        &#125;<br>        <span class="hljs-comment">// 更新LifeCycle状态</span><br>        r.setState(ON_CREATE);<br>        ···<br>    <span class="hljs-keyword">return</span> activity;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此Activity就已经被成功创建，并执行了其生命周期相关方法。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Activity真正的启动工作在其对应的App中进行，主要有几个步骤：</p><ul><li>ApplicationThread接收到ATMS发送过来的事务，通过Handler发送到主线程处理。</li><li>ActivityThread内部Handler（H）处理消息，并将事务交给TransactionExecutor处理。</li><li>TransactionExecutor执行事务的所有Callback，继而执行ActivityThread#handleLaunchActivity。</li><li>ActivityThread#handleLaunchActivity调用performLaunchActivity方法来执行核心逻辑。</li><li>ActivityThread#performLaunchActivity中反射创建的Activity实例，并且调用了attach方法绑定一些信息，然后调用callActivityOnCreate执行Activity生命周期。</li></ul><p>这部分的时序图如下所示。</p><p><img src="/img/framwork_target_app_start_activity.jpg" alt="目标进程启动Activity过程时序图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于Android API 29源码分析了Activity的启动流程。整个过程涉及了四个进程和两次IPC调用，这四个进程分别是<strong>Launcher进程</strong>、<strong>SystemServer进程</strong>、<strong>应用程序进程</strong>、以及可能参与的<strong>Zygote进程</strong>。</p><p>我们来总结一下这几个过程的工作：</p><ol><li>Launcher进程：通过点击图标生成Intent，通知ATMS启动对应Activity。</li><li>SystemServer进程：<ul><li>检查调用（Launcher）进程是否被隔离、是否有权限启动Activity，然后生成ActivityStarter来处理Activity启动事宜。</li><li>解析Intent中的信息，通过这些信息解析出包含Activity信息的ActivityInfo对象。判断Activity是否有在清单文件中注册、是否有权限等。</li><li>计算Intent的Flags，处理LaunchMode问题，判断Activity的目标任务栈，将Activity添加到任务栈中。</li><li>将任务栈移至前台，使栈顶的Activity可见，会创建一个事务并通过IPC发送到目标App进程。</li><li>如果App进程不存在，启动App进程。</li></ul></li><li>应用程序进程：<ul><li>接收SystemServer传递的事务并且执行事务。</li><li>反射创建Activity对象，为Activity创建Context、Window等。</li><li>回调其onCreate、onStart、onResume生命周期。</li></ul></li></ol><p>Launcher进程负责通知ATMS发起Activity启动；SystemServer进程中参与的主要是ATMS服务，它负责计算构造目标的Intent、处理TaskRecord和ActivityRecord信息、以及ActivityStack的处理，最后将启动消息发送到对应应用程序进程；应用程序进程负责接收ATMS发送过来的事务并处理，Activity的创建以及生命周期的回调都在这里处理。</p><p>若应用程序进程还未启动，Zygote进程还需要参与进来创建对应进程。</p><p>下篇文章将会继续分析Zygote进程创建目标App进程的过程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:">Android API 29 Platform</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/30358046/">《Android进阶解密》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.jianshu.com/p/9c12cd6a35e0">Android Fk: Activty管理之token总结</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Framework（一）——关键系统进程启动过程</title>
    <link href="/2021/05/14/7ca6484e/"/>
    <url>/2021/05/14/7ca6484e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意（WARNING）：本文含有大量AOSP源码，阅读过程中如出现头晕、目眩、恶心、犯困等症状属正常情况，作者本人亦无法避免症状产生，故不承担任何法律责任。</p><p>本文所贴源码全部来自 Android API 29 Platform，即 Android 10.0。</p><p>阅读本文需要有一定的C/C++基础。</p></blockquote><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p>当我们看到”<strong>Android系统架构</strong>“这几个字时，通常会联想到Google官方发布的五层系统架构图，如下所示。</p><p><img src="/img/android-stack.png" alt="Google官方Android系统架构图"></p><p>通过这张图我们可以理解Android系统如何分层以及各层功能职责，不过对于各层的运行细节、层与层之间如何进行通信和配合工作等我们还是无法得知。</p><p>为了窥探Android系统的全貌，我们可以从一些关键进程的启动入手，分析Android内部的环环相扣的内在联系。</p><p>这里借用<strong>gityuan</strong>大佬的一张图：</p><p><img src="/img/android-boot.jpeg" alt="Android系统启动架构图(图源gityuan.com)"></p><p>从上图我们可以看到整个系统启动中有几个关键进程：</p><ul><li>Init进程</li><li>Zygote进程</li><li>System Server进程</li><li>应用程序进程</li></ul><p>下面我们根据这些进程的启动顺序来分析各进程的启动过程以及其主要工作，为了防止篇幅过长，应用程序进程将会在后面的文章单独分析。</p><h2 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h2><p>要了解Init进程，首先要知道Android系统的启动过程，分为几个步骤：</p><ol><li>启动电源以及系统系统：当电源按下时引导芯片代码从预定义的地方（固化在 ROM）开始执行。加载引导程序BootLoader到RAM中，然后执行。</li><li>引导程序BootLoader：引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。</li><li>Linux Kernel启动：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。在内核完成系统设置后，它首先在系统文件中寻找init.rc文件，并启动init进程。</li><li>Init 进程启动：init进程做的工作比较多 ，主要用来初始化和启动属性服务，也用来启动 Zygote 进程。</li></ol><p>Init进程是Linux系统中用户空间的第一个进程，pid固定为1。</p><h3 id="Init进程的入口函数"><a href="#Init进程的入口函数" class="headerlink" title="Init进程的入口函数"></a>Init进程的入口函数</h3><p>Init进程启动后执行其main方法，对应源码在 system/core/init/main.cpp 文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// system/core/init/main.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __has_feature(address_sanitizer)</span><br>    __asan_set_error_report_callback(AsanReportCallback);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// Boost prio which will be restored later</span><br>    setpriority(PRIO_PROCESS, <span class="hljs-number">0</span>, <span class="hljs-number">-20</span>);<br>    <span class="hljs-comment">// ueventd主要是负责设备节点的创建、权限设定等一系列工作</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> ueventd_main(argc, argv);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// //参数为subcontext，初始化日志系统</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;subcontext&quot;</span>)) &#123;<br>            android::base::InitLogging(argv, &amp;android::base::KernelLogger);<br>            <span class="hljs-keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();<br><br>            <span class="hljs-keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);<br>        &#125;<br><br>        <span class="hljs-comment">// 参数为selinux_setup，启动Selinux安全策略</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;selinux_setup&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> SetupSelinux(argv);<br>        &#125;<br><br>        <span class="hljs-comment">// 参数为second_stage，进行第二阶段</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;second_stage&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> SecondStageMain(argc, argv);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 默认进行第一阶段</span><br>    <span class="hljs-keyword">return</span> FirstStageMain(argc, argv);<br>&#125;<br><br><span class="hljs-comment">// system/core/init/first_stage_init.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstStagetMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-comment">// init crash时重启引导加载程序</span><br>  <span class="hljs-comment">// 这个函数主要作用将各种信号量，如SIGABRT,SIGBUS等的行为设置为SA_RESTART,一旦监听到这些信号即执行重启系统</span><br>  <span class="hljs-keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>      InstallRebootSignalHandlers();<br>  &#125;<br>  ···<br><span class="hljs-comment">// 主要是创建挂载相关文件目录</span><br>CHECKCALL(mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>));<br>CHECKCALL(mkdir(<span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-number">0755</span>));<br>CHECKCALL(mkdir(<span class="hljs-string">&quot;/dev/socket&quot;</span>, <span class="hljs-number">0755</span>));<br>CHECKCALL(mount(<span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span><br>CHECKCALL(mount(<span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));<br>...<br><span class="hljs-comment">// 传入selinux_setup--&gt;main.cpp</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path = <span class="hljs-string">&quot;/system/bin/init&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* args[] = &#123;path, <span class="hljs-string">&quot;selinux_setup&quot;</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>execv(path, <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>**&gt;(args));<br>...<br>&#125;<br><br><span class="hljs-comment">// system/core/init/selinux.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SetupSelinux</span><span class="hljs-params">(<span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br><span class="hljs-comment">// 设置SELinux, 执行一些安全策略</span><br>SelinuxSetupKernelLogging();<br>SelinuxInitialize();<br>  <br>  ···<br><br><span class="hljs-comment">// 传入second_stage--&gt;main.cpp</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path = <span class="hljs-string">&quot;/system/bin/init&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* args[] = &#123;path, <span class="hljs-string">&quot;second_stage&quot;</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>execv(path, <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>**&gt;(args));<br>&#125;<br><br><span class="hljs-comment">// 第二阶段</span><br><span class="hljs-comment">// system/core/init/init.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 初始化内核Logging</span><br>    InitKernelLogging(argv);<br>    ···<br>    <span class="hljs-comment">// 初始化属性服务</span><br>    PropertyInit();<br><br>    ···<br><br>    <span class="hljs-comment">// Now set up SELinux for second stage.</span><br>    SelinuxSetupKernelLogging();<br>    ···<br>      <br>    <span class="hljs-comment">// 装载子进程信号处理，为了防止僵尸子进程无法回收</span><br>    InstallSignalFdHandler(&amp;epoll);<br>    InstallInitNotifier(&amp;epoll);<br>    <span class="hljs-comment">// 开启属性服务</span><br>    StartPropertyService(&amp;property_fd);<br>    ···<br>    <span class="hljs-comment">// 加载解析init.rc脚本</span><br>    LoadBootScripts(am, sm);<br>    ··· <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析init.rc文件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadBootScripts</span><span class="hljs-params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;<br><span class="hljs-comment">// 构造一个解析器</span><br>Parser parser = CreateParser(action_manager, service_list);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bootscript = GetProperty(<span class="hljs-string">&quot;ro.boot.init_rc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">if</span> (bootscript.empty()) &#123;<br>parser.ParseConfig(<span class="hljs-string">&quot;/init.rc&quot;</span>);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法中通过判断参数个数以及类型来执行对应的代码，主要分为两个阶段的工作：</p><ul><li><strong>第一阶段（FirstStageMain）</strong>：<ul><li>ueventd/watchdogd跳转及环境变量设置</li><li>挂载文件系统并创建目录</li><li>初始化日志输出、挂载分区设备</li><li>启用SELinux安全策略</li><li>初始化内核log系统</li></ul></li><li><strong>第二阶段（SecondStageMain）</strong>：<ul><li>创建进程会话密钥并初始化属性系统</li><li>执行SELinux第二阶段并恢复一些文件安全上下文</li><li>新建epoll并初始化子进程终止信号处理函数</li><li>设置其他系统属性并开启属性服务</li><li>解析init.rc脚本文件，启动Zygote进程和其它进程</li></ul></li></ul><h3 id="解析init-rc文件"><a href="#解析init-rc文件" class="headerlink" title="解析init.rc文件"></a>解析init.rc文件</h3><p>init.rc是一个配置文件，内部是由Android初始化语言编写的脚本，主要包含五种类型语句：</p><ul><li>Action</li><li>Command</li><li>Service</li><li>Option</li><li>Import</li></ul><p>我们只需要关注service命令即可。service命令可以开启一个服务，格式如下：</p><blockquote><p>service &lt;name&gt;&lt;pathname&gt; [&lt;argument&gt;]* &lt;option&gt; &lt;option&gt;</p></blockquote><p>参数含义如下表所示。</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&lt;name&gt;</td><td align="center">表示此服务的名称</td></tr><tr><td align="center">&lt;pathname&gt;</td><td align="center">服务所在路径</td></tr><tr><td align="center">&lt;argument&gt;</td><td align="center">启动服务所带的参数</td></tr><tr><td align="center">&lt;option&gt;</td><td align="center">对此服务的约束选项</td></tr></tbody></table><p>Init进程在解析init.rc文件时，会创建和启动service命令指定的进程，其中Zygote进程就是这样被启动的。</p><p>init.rc文件中通过import来导入对应Zygote的rc文件，主流厂商使用的是init.zygote64_32.rc，完整路径如下：</p><blockquote><p>system/core/rootdir/init.zygote64_32.rc</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    socket zygote stream 660 root system<br>    socket usap_pool_primary stream 660 root system<br>    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse<br>    onrestart write /sys/power/state on<br>    onrestart restart audioserver<br>    onrestart restart cameraserver<br>    onrestart restart media<br>    onrestart restart netd<br>    onrestart restart wificond<br>    task_profiles ProcessCapacityHigh MaxPerformance<br>    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal<br><br>service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    socket zygote_secondary stream 660 root system<br>    socket usap_pool_secondary stream 660 root system<br>    onrestart restart zygote<br>    task_profiles ProcessCapacityHigh MaxPerformance<br></code></pre></td></tr></table></figure><p>下面我们来分析下这段脚本。</p><h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>init.zygote64_32.rc文件包含两个service指令，对应两个Zygote进程。</p><h3 id="第一个Zygote进程"><a href="#第一个Zygote进程" class="headerlink" title="第一个Zygote进程"></a>第一个Zygote进程</h3><p>第一个Zygote进程的进程名为zygote，进程通过/system/bin/app_process64来启动，并且会创建一个名为zygote的socket。</p><p>对应脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote<br>    class main<br>    priority -20<br>    user root   // 用户为root<br>    group root readproc reserved_disk  // 访问组<br>    socket zygote stream 660 root system  // 创建一个socket，名字叫zygote，以tcp形式<br>    socket usap_pool_primary stream 660 root system<br>    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse<br>    onrestart write /sys/power/state on   // onrestart 指当进程重启时执行后面的命令<br>    onrestart restart audioserver<br>    onrestart restart cameraserver<br>    onrestart restart media<br>    onrestart restart netd<br>    onrestart restart wificond<br>    task_profiles ProcessCapacityHigh MaxPerformance<br>    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal<br></code></pre></td></tr></table></figure><p>通过执行进行/system/bin/app_process64并传入4个参数启动Zygote进程，这五个参数分别是：</p><ul><li>-Xzygote：该参数将作为虚拟机启动时所需的参数</li><li>/system/bin：代表虚拟机程序所在目录</li><li>–zygote：指明以ZygoteInit.java类中的main函数作为虚拟机执行入口</li><li>–start-system-server：告诉Zygote进程启动systemServe进程</li><li>–socket-name：指定socket的名字</li></ul><h3 id="第二个Zygote进程"><a href="#第二个Zygote进程" class="headerlink" title="第二个Zygote进程"></a>第二个Zygote进程</h3><p>第一个Zygote进程的进程名为zygote_secondary，进程通过/system/bin/app_process32来启动，并且会创建一个名为zygote_secondary的socket。</p><p>对应脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    socket zygote_secondary stream 660 root system<br>    socket usap_pool_secondary stream 660 root system<br>    onrestart restart zygote<br>    task_profiles ProcessCapacityHigh MaxPerformance<br></code></pre></td></tr></table></figure><p>可以看到Zygote进程通过/system/bin/app_process64和/system/bin/app_process32来启动，入口函数位于frameworks/base/cmds/app_process/app_main.cpp中。</p><h3 id="Zygote进程入口函数"><a href="#Zygote进程入口函数" class="headerlink" title="Zygote进程入口函数"></a>Zygote进程入口函数</h3><blockquote><p>frameworks/base/cmds/app_process/app_main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> argv[])</span></span>&#123;<br>  ···<br>  <span class="hljs-comment">// 构造AppRuntime</span><br>  <span class="hljs-function">AppRuntime <span class="hljs-title">runtime</span><span class="hljs-params">(argv[<span class="hljs-number">0</span>], computeArgBlockSize(argc, argv))</span></span>;<br>  argc--;<br>  argv++;<br>  ···<br>  <span class="hljs-comment">// while循环拼接参数：根据init.rc中的配置，这里zygote=true</span><br>  <span class="hljs-comment">// 是否为zygote进程</span><br>  <span class="hljs-keyword">bool</span> zygote = <span class="hljs-literal">false</span>;   <br>  <span class="hljs-comment">// 是否启动SystemServer进程</span><br>  <span class="hljs-keyword">bool</span> startSystemServer = <span class="hljs-literal">false</span>;  <br>  <span class="hljs-comment">// 是否为应用进程</span><br>  <span class="hljs-keyword">bool</span> application = <span class="hljs-literal">false</span>;  <br>  <span class="hljs-comment">// 进程名</span><br>  String8 niceName;  <br>  <span class="hljs-comment">// 入口类名</span><br>  String8 className;  <br><span class="hljs-keyword">while</span> (i &lt; argc) &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* arg = argv[i++];<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--zygote&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>zygote = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 为进程取一个名字，这里为zygote64</span><br>niceName = ZYGOTE_NICE_NAME;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--start-system-server&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>startSystemServer = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--application&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>application = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(arg, <span class="hljs-string">&quot;--nice-name=&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>) &#123;<br>niceName.setTo(arg + <span class="hljs-number">12</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(arg, <span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>) &#123;<br>className.setTo(arg);<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>--i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>  ···<br><span class="hljs-comment">// 根据前面init.rc指定传入参数</span><br><span class="hljs-keyword">if</span> (zygote) &#123;<br>    <span class="hljs-comment">// 本次流程进入此分支，加载ZygoteInit</span><br>runtime.start(<span class="hljs-string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className) &#123;<br>    <span class="hljs-comment">//如果是application启动模式，则加载RuntimeInit</span><br>runtime.start(<span class="hljs-string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);<br>app_usage();<br>LOG_ALWAYS_FATAL(<span class="hljs-string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法中主要是创建了一个AppRuntime对象，然后根据传入的参数判断当前进程类型，可能为Zygote或者应用进程，本次流程为Zygote进程。最后进行参数的拼接，调用AppRuntime.start方法启动虚拟机并传入参数。</p><h3 id="AppRuntime-start"><a href="#AppRuntime-start" class="headerlink" title="AppRuntime#start"></a>AppRuntime#start</h3><p>AppRuntime继承自AndroidRuntime，start方法定义在AndroidRuntime中，先看看此方法的注释以及声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Start the Android runtime.  This involves starting the virtual machine</span><br><span class="hljs-comment"> * and calling the &quot;static void main(String[] args)&quot; method in the class</span><br><span class="hljs-comment"> * named by &quot;className&quot;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Passes the main function two arguments, the class name and the specified</span><br><span class="hljs-comment"> * options string.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* className, <span class="hljs-keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-keyword">bool</span> zygote)</span></span><br></code></pre></td></tr></table></figure><p>通过注释我们知道这个方法主要干了两件事：</p><ul><li>启动Dalvik虚拟机</li><li>调用”static void main(String[] args)“方法</li></ul><p>下面来过一过源码。</p><blockquote><p>frameworks/base/core/jni/AndroidRuntime.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* className, <span class="hljs-keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-keyword">bool</span> zygote)</span></span><br><span class="hljs-function"></span>&#123;<br>    ···<br>    <span class="hljs-comment">/* start the virtual machine */</span><br>    <span class="hljs-comment">// 初始化JNI，会创建虚拟机</span><br>    JniInvocation jni_invocation;<br>    jni_invocation.Init(<span class="hljs-literal">NULL</span>);<br>    JNIEnv* env;<br>    <span class="hljs-comment">// 启动Dalvik虚拟机，主要是设置一大堆启动参数</span><br>    <span class="hljs-keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 启动成功回调</span><br>    onVmCreated(env);<br>  <br>    <span class="hljs-comment">// 注册JNI函数</span><br>    <span class="hljs-keyword">if</span> (startReg(env) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;Unable to register all android natives\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ···<br><br>    <span class="hljs-comment">// 启动Java main方法需要一个String[]类型的参数</span><br>    <span class="hljs-comment">// 在这里构建这个参数</span><br>    jclass stringClass;<br>    jobjectArray strArray;<br>    jstring classNameStr;<br><br>    stringClass = env-&gt;FindClass(<span class="hljs-string">&quot;java/lang/String&quot;</span>);<br>    assert(stringClass != <span class="hljs-literal">NULL</span>);<br>    strArray = env-&gt;NewObjectArray(options.size() + <span class="hljs-number">1</span>, stringClass, <span class="hljs-literal">NULL</span>);<br>    assert(strArray != <span class="hljs-literal">NULL</span>);<br>    classNameStr = env-&gt;NewStringUTF(className);<br>    assert(classNameStr != <span class="hljs-literal">NULL</span>);<br>    env-&gt;SetObjectArrayElement(strArray, <span class="hljs-number">0</span>, classNameStr);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; options.size(); ++i) &#123;<br>        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="hljs-built_in">string</span>());<br>        assert(optionsStr != <span class="hljs-literal">NULL</span>);<br>        env-&gt;SetObjectArrayElement(strArray, i + <span class="hljs-number">1</span>, optionsStr);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span><br><span class="hljs-comment">     * not return until the VM exits.</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">// 将&quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com/android/internal/os/ZygoteInit&quot;</span><br>    <span class="hljs-keyword">char</span>* slashClassName = toSlashClassName(className != <span class="hljs-literal">NULL</span> ? className : <span class="hljs-string">&quot;&quot;</span>);<br>    jclass startClass = env-&gt;FindClass(slashClassName);<br>    <span class="hljs-keyword">if</span> (startClass == <span class="hljs-literal">NULL</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);<br>        <span class="hljs-comment">/* keep going */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取main方法jmethodID</span><br>        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="hljs-string">&quot;main&quot;</span>,<br>            <span class="hljs-string">&quot;([Ljava/lang/String;)V&quot;</span>);<br>        <span class="hljs-keyword">if</span> (startMeth == <span class="hljs-literal">NULL</span>) &#123;<br>            ALOGE(<span class="hljs-string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);<br>            <span class="hljs-comment">/* keep going */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Native调用Java main方法，至此进入Java世界</span><br>            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>            <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck())<br>                threadExitUncaughtException(env);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(slashClassName);<br><br>    ALOGD(<span class="hljs-string">&quot;Shutting down VM\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)<br>        ALOGW(<span class="hljs-string">&quot;Warning: unable to detach main thread\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="hljs-number">0</span>)<br>        ALOGW(<span class="hljs-string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码配合注释还是很容易理解的，首先初始化了JNI服务，然后启动了Dalvik虚拟机，最后根据传入的className，使用JNI方式调用ZygoteInit#main方法。</p><h3 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit#main"></a>ZygoteInit#main</h3><p>代码执行到这里的时候，我们已经从晦涩的C++世界进入了熟悉的Java世界中。</p><p>来到ZygoteInit.java类，找到对应的Java main方法，此方法的主要工作为：</p><ol><li>预加载类和资源</li><li>创建服务端Socket</li><li>启动SystemServer进程</li><li>开启循环，等待客户端请求</li></ol><p>下面通过源码来分析这四个步骤。</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 创建ZygoteServer</span><br>    ZygoteServer zygoteServer = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 调用native函数，确保当前没有其它线程在运行</span><br>    ZygoteHooks.startZygoteNoThreadCreation();<br><br>    <span class="hljs-comment">// Zygote goes into its own process group.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 设置Zygote的pid和gid为0</span><br>        Os.setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failed to setpgid(0,0)&quot;</span>, ex);<br>    &#125;<br><br>    Runnable caller;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>        <span class="hljs-comment">// 得到systrace的监控TAG</span><br>        String bootTimeTag = Process.is64Bit() ? <span class="hljs-string">&quot;Zygote64Timing&quot;</span> : <span class="hljs-string">&quot;Zygote32Timing&quot;</span>;<br>        <span class="hljs-comment">// 通过systradce来追踪 函数ZygoteInit</span><br>        TimingsTraceLog bootTimingsTraceLog = <span class="hljs-keyword">new</span> TimingsTraceLog(bootTimeTag,<br>                Trace.TRACE_TAG_DALVIK);<br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;ZygoteInit&quot;</span>);<br>        <span class="hljs-comment">// 开启DDMS(Dalvik Debug Monitor Service)功能</span><br>        <span class="hljs-comment">// 注册所有已知的Java VM的处理块的监听器。线程监听、内存监听、native 堆内存监听、debug模式监听等等</span><br>        RuntimeInit.enableDdms();<br><br>        <span class="hljs-keyword">boolean</span> startSystemServer = <span class="hljs-keyword">false</span>;<br>        String zygoteSocketName = <span class="hljs-string">&quot;zygote&quot;</span>;<br>        String abiList = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">boolean</span> enableLazyPreload = <span class="hljs-keyword">false</span>;<br>      <br>        <span class="hljs-comment">// 解析传入main方法的参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; argv.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;<br>                <span class="hljs-comment">// 启动zygote时才会传入，表示需要启动systemServer</span><br>                startSystemServer = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;<br>                <span class="hljs-comment">// 启动zygote_secondary时才会传入</span><br>                enableLazyPreload = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;<br>                abiList = argv[i].substring(ABI_LIST_ARG.length());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;<br>                <span class="hljs-comment">// 创建socket指定的名称，zygote或者zygote_secondary</span><br>                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unknown command line argument: &quot;</span> + argv[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断需要创建的Socket类型</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);<br><br>        <span class="hljs-keyword">if</span> (abiList == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;No ABI list supplied.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 在第一次zygote启动时，enableLazyPreload为false，执行preload</span><br>        <span class="hljs-keyword">if</span> (!enableLazyPreload) &#123;<br>            <span class="hljs-comment">// systrace 追踪ZygotePreload</span><br>            bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;ZygotePreload&quot;</span>);<br>            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,<br>                    SystemClock.uptimeMillis());<br>            <span class="hljs-comment">// 加载进程的资源和类</span><br>            preload(bootTimingsTraceLog);<br>            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,<br>                    SystemClock.uptimeMillis());<br>            bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// ZygotePreload</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Zygote.resetNicePriority();<br>        &#125;<br><br>        <br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PostZygoteInitGC&quot;</span>);<br>        gcAndFinalize();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PostZygoteInitGC</span><br><br>        <span class="hljs-comment">// 结束ZygoteInit的systrace追踪</span><br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// ZygoteInit</span><br>        <span class="hljs-comment">// 禁用systrace追踪，以便fork的进程不会从zygote继承过时的跟踪标记</span><br>        Trace.setTracingEnabled(<span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);<br><br><br>        Zygote.initNativeState(isPrimaryZygote);<br><br>        ZygoteHooks.stopZygoteNoThreadCreation();<br><br>        <span class="hljs-comment">// 调用ZygoteServer构造函数，会根据传入的参数创建对应的socket</span><br>        zygoteServer = <span class="hljs-keyword">new</span> ZygoteServer(isPrimaryZygote);<br><br>        <span class="hljs-keyword">if</span> (startSystemServer) &#123;<br>            <span class="hljs-comment">// fork出system server</span><br>            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);<br><br>            <span class="hljs-comment">// 这里r如果为null，则表示当前是zygote进程，那么就会继续执行下面的代码，开启循环</span><br>            <span class="hljs-comment">// 如果r不为null，则表示当前是子进程，那么就会直接执行子进程然后return</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>                r.run();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        Log.i(TAG, <span class="hljs-string">&quot;Accepting command socket connections&quot;</span>);<br><br>        <span class="hljs-comment">// zygote进程进入无限循环，处理子进程请求</span><br>        caller = zygoteServer.runSelectLoop(abiList);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;System zygote died with exception&quot;</span>, ex);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (zygoteServer != <span class="hljs-keyword">null</span>) &#123;<br>            zygoteServer.closeServerSocket();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span><br>    <span class="hljs-comment">// command.</span><br>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;<br>        caller.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Zygote实际上也是采用的C/S结构，它首先会使用预加载机制加载一些公<br>共的类和资源，这样子进程就无需再次加载。</p><p>然后通过ZygoteServer来创建本地服务端的socket，用于与其他进程通信。</p><p>在第一次启动时它会通过fork自身的方式启动SystemServer进程，然后会一直等待子进程Socket请求请求，通过fork zygote可以快速创建一个已经初始化好的”Java 世界进程“，这也是Zygote名称的由来。</p><p>下面我们来看看预加载方法。</p><h3 id="ZygoteInit-preLoad"><a href="#ZygoteInit-preLoad" class="headerlink" title="ZygoteInit#preLoad"></a>ZygoteInit#preLoad</h3><p>preLoad中大量使用了systrace来监控方法执行性能，这里我将它们去除掉了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preload</span><span class="hljs-params">(TimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;<br>    <span class="hljs-comment">// 用于Hook的函数，开始预载</span><br>    beginPreload();<br>  <br>    <span class="hljs-comment">// 预加载类</span><br>    <span class="hljs-comment">// 列表位于/system/etc/preloaded-classes</span><br>    preloadClasses();<br>    <br>    <span class="hljs-comment">// 加载一些无法放到启动类加载器Path路径下的类</span><br>    cacheNonBootClasspathClassLoaders();<br>    <br>    <span class="hljs-comment">// 加载公用的资源文件，主要是图片和颜色</span><br>    preloadResources();<br>  <br>    <span class="hljs-comment">// 预载硬件抽象层</span><br>    nativePreloadAppProcessHALs();<br>  <br>    <span class="hljs-comment">// 预加载图形驱动</span><br>    maybePreloadGraphicsDriver();<br>  <br>    <span class="hljs-comment">// 加载公用的类库</span><br>    <span class="hljs-comment">// android、compiler_rt、jnigraphics等library</span><br>    preloadSharedLibraries();<br>  <br>    <span class="hljs-comment">// 加载公用的文字资源</span><br>    preloadTextResources();<br>    <br>    <span class="hljs-comment">// 初始化Webview</span><br>    WebViewFactory.prepareWebViewInZygote();<br>    <span class="hljs-comment">// 用于Hook的函数，完成预载</span><br>    endPreload();<br>    warmUpJcaProviders();<br><br>    sPreloadComplete = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些预加载的类都是Android中的一些关键类，整个列表定义在frameworks/base/config/preloaded-classes中，Android 10中一共有1万多个。资源主要是加载framework-res.apk中的资源、openGL以及WebView等，我们经常用的android.R文件就是来自这里。</p><p>预加载的好处是在fork创建子进程时无需再次创建这些类和资源，只需复制即可。</p><h3 id="ZygoteInit-forkSystemServer"><a href="#ZygoteInit-forkSystemServer" class="headerlink" title="ZygoteInit#forkSystemServer"></a>ZygoteInit#forkSystemServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">forkSystemServer</span><span class="hljs-params">(String abiList, String socketName,</span></span><br><span class="hljs-function"><span class="hljs-params">        ZygoteServer zygoteServer)</span> </span>&#123;<br>    ···<br>    ZygoteArguments parsedArgs;<br><br>    <span class="hljs-keyword">int</span> pid;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ZygoteCommandBuffer commandBuffer = <span class="hljs-keyword">new</span> ZygoteCommandBuffer(args);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 封装参数</span><br>            parsedArgs = ZygoteArguments.getInstance(commandBuffer);<br>        &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;Unexpected argument error for forking system server&quot;</span>, e);<br>        &#125;<br>        commandBuffer.close();<br>        Zygote.applyDebuggerSystemProperty(parsedArgs);<br>        Zygote.applyInvokeWithSystemProperty(parsedArgs);<br><br>        <span class="hljs-keyword">if</span> (Zygote.nativeSupportsMemoryTagging()) &#123;<br>            <span class="hljs-comment">/* The system server has ASYNC MTE by default, in order to allow</span><br><span class="hljs-comment">             * system services to specify their own MTE level later, as you</span><br><span class="hljs-comment">             * can&#x27;t re-enable MTE once it&#x27;s disabled. */</span><br>            String mode = SystemProperties.get(<span class="hljs-string">&quot;arm64.memtag.process.system_server&quot;</span>, <span class="hljs-string">&quot;async&quot;</span>);<br>            <span class="hljs-keyword">if</span> (mode.equals(<span class="hljs-string">&quot;async&quot;</span>)) &#123;<br>                parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_ASYNC;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode.equals(<span class="hljs-string">&quot;sync&quot;</span>)) &#123;<br>                parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_SYNC;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mode.equals(<span class="hljs-string">&quot;off&quot;</span>)) &#123;<br>                <span class="hljs-comment">/* When we have an invalid memory tag level, keep the current level. */</span><br>                parsedArgs.mRuntimeFlags |= Zygote.nativeCurrentTaggingLevel();<br>                Slog.e(TAG, <span class="hljs-string">&quot;Unknown memory tag level for the system server: \&quot;&quot;</span> + mode + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Zygote.nativeSupportsTaggedPointers()) &#123;<br>            <span class="hljs-comment">/* Enable pointer tagging in the system server. Hardware support for this is present</span><br><span class="hljs-comment">             * in all ARMv8 CPUs. */</span><br>            parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_TBI;<br>        &#125;<br><br>        <span class="hljs-comment">/* Enable gwp-asan on the system server with a small probability. This is the same</span><br><span class="hljs-comment">         * policy as applied to native processes and system apps. */</span><br>        parsedArgs.mRuntimeFlags |= Zygote.GWP_ASAN_LEVEL_LOTTERY;<br><br>        <span class="hljs-keyword">if</span> (shouldProfileSystemServer()) &#123;<br>            parsedArgs.mRuntimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;<br>        &#125;<br><br>        <span class="hljs-comment">/* Request to fork the system server process */</span><br>        pid = Zygote.forkSystemServer(<br>                parsedArgs.mUid, parsedArgs.mGid,<br>                parsedArgs.mGids,<br>                parsedArgs.mRuntimeFlags,<br>                <span class="hljs-keyword">null</span>,<br>                parsedArgs.mPermittedCapabilities,<br>                parsedArgs.mEffectiveCapabilities);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>    &#125;<br><br>    <span class="hljs-comment">/* For child process */</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hasSecondZygote(abiList)) &#123;<br>            waitForSecondaryZygote(socketName);<br>        &#125;<br><br>        zygoteServer.closeServerSocket();<br>        <span class="hljs-keyword">return</span> handleSystemServerProcess(parsedArgs);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>forkSystemServer方法将会采用JNI的方式调用nativeForkSystemServer方法来创建子进程。在子进程中调用handleSystemServerProcess方法，会返回一个Runnale对象，通过调用这个Runnable的run方法来执行SystemServer的main方法。</p><h3 id="ZygoteServer-runSelectLoop"><a href="#ZygoteServer-runSelectLoop" class="headerlink" title="ZygoteServer#runSelectLoop"></a>ZygoteServer#runSelectLoop</h3><p>在创建完SystemServer之后，Zygote的前置工作就已经完成，接下来将会进入无限循环中，等待SystemServer通知它创建App进程。runSelectLoop的源码较为复杂，这里做了大量精简，我们只需要关注关键方法即可。</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Runnable <span class="hljs-title">runSelectLoop</span><span class="hljs-params">(String abiList)</span> </span>&#123;<br>  <br>      ···<br>          <br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 利用管道机制阻塞等待事件</span><br>          Os.poll(pollFDs, -<span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;poll failed&quot;</span>, ex);<br>      &#125;<br> <br>      <span class="hljs-keyword">boolean</span> usapPoolFDRead = <span class="hljs-keyword">false</span>;<br> <br>      <span class="hljs-comment">// 倒序处理，即优先处理已建立链接的信息，后处理新建链接的请求</span><br>      <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>          &#125;<br> <br>          <span class="hljs-comment">// server socket最先加入fds， 因此这里是server socket收到数据</span><br>          <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// 收到新的建立通信的请求，建立通信连接</span><br>              ZygoteConnection newPeer = acceptCommandPeer(abiList);<br>              <span class="hljs-comment">// 加入到peers和fds, 即下一次也开始监听</span><br>              peers.add(newPeer);<br>              socketFDs.add(newPeer.getFileDescriptor());<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;<br>              <span class="hljs-comment">// 说明接收到AMS发送过来创建应用程序的请求，调用processOneCommand来创建新的应用程序进程</span><br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//有socket连接，创建ZygoteConnection对象,并添加到fds</span><br>                  ZygoteConnection connection = peers.get(pollIndex);<br>                  <span class="hljs-comment">// 处理连接</span><br>                  <span class="hljs-keyword">final</span> Runnable command = connection.processOneCommand(<br><span class="hljs-keyword">this</span>);<br> <br>     ···<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ZygoteConnection-processOneCommand"><a href="#ZygoteConnection-processOneCommand" class="headerlink" title="ZygoteConnection#processOneCommand"></a>ZygoteConnection#processOneCommand</h3><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Runnable <span class="hljs-title">processOneCommand</span><span class="hljs-params">(ZygoteServer zygoteServer)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">//fork子进程</span><br>    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, <br>parsedArgs.mGids,<br>            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, <br>parsedArgs.mSeInfo,<br>            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.<br>mStartChildZygote,<br>            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs<br>.mTargetSdkVersion);<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        zygoteServer.setForkChild();<br>        <span class="hljs-comment">// 子进程执行</span><br>        <span class="hljs-keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,<br>                parsedArgs.mStartChildZygote);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 父进程执行</span><br>        handleParentProc(pid, descriptors, serverPipeFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ZygoteConnection-handleChildProc"><a href="#ZygoteConnection-handleChildProc" class="headerlink" title="ZygoteConnection#handleChildProc"></a>ZygoteConnection#handleChildProc</h3><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">handleChildProc</span><span class="hljs-params">(ZygoteArguments parsedArgs,</span></span><br><span class="hljs-function"><span class="hljs-params">        FileDescriptor pipeFd, <span class="hljs-keyword">boolean</span> isZygote)</span> </span>&#123;<br>  <br>    <span class="hljs-comment">// 关闭继承自Zygote的Socket</span><br>    closeSocket();<br><br>    <span class="hljs-comment">// 设置目标App进程名</span><br>    Zygote.setAppProcessName(parsedArgs, TAG);<br><br>    <span class="hljs-keyword">if</span> (parsedArgs.mInvokeWith != <span class="hljs-keyword">null</span>) &#123;<br>        WrapperInit.execApplication(parsedArgs.mInvokeWith,<br>                parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,<br>                VMRuntime.getCurrentInstructionSet(),<br>                pipeFd, parsedArgs.mRemainingArgs);<br><br>        <span class="hljs-comment">// Should not get here.</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;WrapperInit.execApplication unexpectedly returned&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isZygote) &#123;<br>            <span class="hljs-comment">// App进程，执行main方法</span><br>            <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,<br>                    parsedArgs.mDisabledCompatChanges,<br>                    parsedArgs.mRemainingArgs, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* classLoader */</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 子Zygote进程初始化        </span><br>            <span class="hljs-keyword">return</span> ZygoteInit.childZygoteInit(<br>                    parsedArgs.mRemainingArgs  <span class="hljs-comment">/* classLoader */</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Zygote进程所做的工作有点多，我们来总结一下它的主要工作流程。</p><ol><li>启动Android系统中第一个Java虚拟机，并且初始化了JNI，注册了Android中的JNI函数。</li><li>调用Java层ZygoteInit类的main函数，进入Java世界。</li><li>建立Socket服务端，用于与客户端进行IPC通信，主要是接收SystemServer的启动App进程请求。</li><li>预加载类、资源、Webview等。</li><li>通过fork自身的方式，启动SystemServer进程。</li><li>调用runSelectLoopMode方法，进入无限循环，等待创建子进程的请求。</li></ol><h2 id="System-Server进程"><a href="#System-Server进程" class="headerlink" title="System Server进程"></a>System Server进程</h2><p>SystemServer进程主要用于创建系统服务，我们熟知的 AMS、ATMS、WMS 和 PMS 都是由它来创建的，其进程名为“system_server”。</p><p>下面就继续跟踪上节的ZygoteInit#handleSystemServerProcess方法来分析SystemServer的工作流程。</p><h3 id="ZygoteInit-handleSystemServerProcess"><a href="#ZygoteInit-handleSystemServerProcess" class="headerlink" title="ZygoteInit#handleSystemServerProcess"></a>ZygoteInit#handleSystemServerProcess</h3><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">handleSystemServerProcess</span><span class="hljs-params">(ZygoteArguments parsedArgs)</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 如果有参数中有--invokewith</span><br>    <span class="hljs-keyword">if</span> (parsedArgs.mInvokeWith != <span class="hljs-keyword">null</span>) &#123;<br>        String[] args = parsedArgs.mRemainingArgs;<br>        <span class="hljs-keyword">if</span> (systemServerClasspath != <span class="hljs-keyword">null</span>) &#123;<br>            String[] amendedArgs = <span class="hljs-keyword">new</span> String[args.length + <span class="hljs-number">2</span>];<br>            amendedArgs[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;-cp&quot;</span>;<br>            amendedArgs[<span class="hljs-number">1</span>] = systemServerClasspath;<br>            System.arraycopy(args, <span class="hljs-number">0</span>, amendedArgs, <span class="hljs-number">2</span>, args.length);<br>            args = amendedArgs;<br>        &#125;<br><br>        WrapperInit.execApplication(parsedArgs.mInvokeWith,<br>                parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,<br>                VMRuntime.getCurrentInstructionSet(), <span class="hljs-keyword">null</span>, args);<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unexpected return from WrapperInit.execApplication&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此次流程进入此分支</span><br>        ClassLoader cl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (systemServerClasspath != <span class="hljs-keyword">null</span>) <br>            <span class="hljs-comment">// 创建PathClassLoader</span><br>            cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion);<br><br>            Thread.currentThread().setContextClassLoader(cl);<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余参数传递给SystemServer</span><br>        <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,<br>                parsedArgs.mDisabledCompatChanges,<br>                parsedArgs.mRemainingArgs, cl);<br>    &#125;<br>    <span class="hljs-comment">/* should never reach here */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意的是，PathClassLoader在这里被创建。</p><p>接着调用了ZygoteInit#zygoteInit方法。</p><h3 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit#zygoteInit"></a>ZygoteInit#zygoteInit</h3><p>zygoteInit方法接收3个参数：</p><ul><li>targetSdkVersion：系统设置的目标SDK版本</li><li>disabledCompatChanges：禁用的一些兼容选项</li><li>argv：传递给虚拟机的启动参数，也就是main方法接收到的参数</li></ul><p>源码如下：</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">zygoteInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, <span class="hljs-keyword">long</span>[] disabledCompatChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (RuntimeInit.DEBUG) &#123;<br>        Slog.d(RuntimeInit.TAG, <span class="hljs-string">&quot;RuntimeInit: Starting application from zygote&quot;</span>);<br>    &#125;<br><br>    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ZygoteInit&quot;</span>);<br>    <span class="hljs-comment">// 重定向Log输出流</span><br>    RuntimeInit.redirectLogStreams();<br>    <span class="hljs-comment">// 一些通用的初始化，例如log、时区、http userAgent等</span><br>    RuntimeInit.commonInit();<br>    <span class="hljs-comment">// 关键方法1，启动Binder线程池</span><br>    ZygoteInit.nativeZygoteInit();<br>    <span class="hljs-comment">// 关键方法2，执行Java main方法</span><br>    <span class="hljs-keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,<br>            classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法中有两个关键方法，已在代码中标明，下面就来分析下这两个方法。</p><h3 id="ZygoteInit-nativeZygoteInit"><a href="#ZygoteInit-nativeZygoteInit" class="headerlink" title="ZygoteInit#nativeZygoteInit"></a>ZygoteInit#nativeZygoteInit</h3><p>nativeZygotelnit是一个Native方法，因此我们先要了解它对应的JNI文件，源码中的JNI文件都可以在 frameworks/base/core/jni 目录中找到。</p><blockquote><p>frameworks/base/core/jni/AndroidRuntime.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">register_com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="hljs-params">(JNIEnv* env)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> JNINativeMethod methods[] = &#123;<br>        &#123; <span class="hljs-string">&quot;nativeZygoteInit&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>,<br>            (<span class="hljs-keyword">void</span>*) com_android_internal_os_ZygoteInit_nativeZygoteInit &#125;,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> jniRegisterNativeMethods(env, <span class="hljs-string">&quot;com/android/internal/os/ZygoteInit&quot;</span>,<br>        methods, NELEM(methods));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过JNI的gMethods数组，可以看出nativeZygotelnit方法对应的是JNI文件AndroidRuntime.cpp的com_android_internal_os_zygotelnit_nativeZygotelnit函数：</p><blockquote><p>frameworks/base/core/jni/AndroidRuntime.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> AndroidRuntime* gCurRuntime = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="hljs-params">(JNIEnv* env, jobject clazz)</span></span><br><span class="hljs-function"></span>&#123;<br>    gCurRuntime-&gt;onZygoteInit();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到gCurRuntime是AndroidRuntime的指针，指向的是子类AppRuntime，实际调用的是AppRuntime中的onZygoteInit方法：</p><blockquote><p>frameworks/base/cmds/app_process/app_main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onZygoteInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sp&lt;ProcessState&gt; proc = ProcessState::self();<br>    ALOGV(<span class="hljs-string">&quot;App process: starting thread pool.\n&quot;</span>);<br>    <span class="hljs-comment">// 启动Binder线程池</span><br>    proc-&gt;startThreadPool();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中调用了<strong>ProcessState#startThreadPool</strong>方法来启动Binder线程池，这里就不再深入了。</p><h3 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit#applicationInit"></a>RuntimeInit#applicationInit</h3><p>applicationInit方法主要是设置虚拟机的TargetSDKVersion，并且通过传递过来的参数找到并启动Java Main方法。</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">applicationInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, <span class="hljs-keyword">long</span>[] disabledCompatChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;<br>    nativeSetExitWithoutCleanup(<span class="hljs-keyword">true</span>);<br><br>    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);<br>    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);<br><br>    <span class="hljs-keyword">final</span> Arguments args = <span class="hljs-keyword">new</span> Arguments(argv);<br><br>    <span class="hljs-comment">// 找到对应类的入口函数</span><br>    <span class="hljs-keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RuntimeInit-findStaticMain"><a href="#RuntimeInit-findStaticMain" class="headerlink" title="RuntimeInit#findStaticMain"></a>RuntimeInit#findStaticMain</h3><p>findStaticMain使用反射创建的入口类，并调用main方法，注意这里的ClassLoader是我们上面提到过的PathClassLoader。</p><blockquote><p>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClassLoader classLoader)</span> </span>&#123;<br>    Class&lt;?&gt; cl;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Missing class when invoking static main &quot;</span> + className,<br>                ex);<br>    &#125;<br><br>    Method m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m = cl.getMethod(<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123; String[].class &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Missing static main on &quot;</span> + className, ex);<br>    &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Problem getting static main on &quot;</span> + className, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> modifiers = m.getModifiers();<br>    <span class="hljs-keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Main method is not public and static on &quot;</span> + className);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * This throw gets caught in ZygoteInit.main(), which responds</span><br><span class="hljs-comment">     * by invoking the exception&#x27;s run() method. This arrangement</span><br><span class="hljs-comment">     * clears up all the stack frames that were required in setting</span><br><span class="hljs-comment">     * up the process.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MethodAndArgsCaller(m, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法返回了一个MethodAndArgsCaller对象，MethodAndArgsCaller是一个Runnable，它主要是调用了传入的Method对象，并将异常都强转为了RuntimeException和Error。</p><p>MethodAndArgsCaller将会返回到ZygoteInit#main方法中执行，接下来就进入了SystemServer.java的main方法中。</p><h3 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer#main"></a>SystemServer#main</h3><p>SystemServer的入口main函数位于SystemServer.java中。</p><blockquote><p>frameworks/base/services/java/com/android/server/SystemServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> SystemServer().run();<br>&#125;<br></code></pre></td></tr></table></figure><p>main方法只是常见了一个SystemServer对象并调用其run方法。</p><blockquote><p>frameworks/base/services/java/com/android/server/SystemServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    TimingsTraceAndSlog t = <span class="hljs-keyword">new</span> TimingsTraceAndSlog();<br>    <span class="hljs-keyword">try</span> &#123;<br>        t.traceBegin(<span class="hljs-string">&quot;InitBeforeStartServices&quot;</span>);<br>        ···<br>        <span class="hljs-comment">// 省略设置一大堆虚拟机的系统属性</span><br>        <span class="hljs-comment">// 矫正时区等操作</span><br>        ···<br>        <span class="hljs-comment">// 清除JVM中的内存增长上限</span><br>        VMRuntime.getRuntime().clearGrowthLimit();<br>        <br>        <span class="hljs-comment">// 设置binder线程池最大线程数，Android 10里面为31</span><br>        BinderInternal.setMaxThreads(sMaxBinderThreads);<br><br>        <span class="hljs-comment">// 设置当前进程优先级</span><br>        android.os.Process.setThreadPriority(<br>                android.os.Process.THREAD_PRIORITY_FOREGROUND);<br>        android.os.Process.setCanSelfBackground(<span class="hljs-keyword">false</span>);<br>      <br>        <span class="hljs-comment">// 创建SystemServer进程的主线程Looper</span><br>        Looper.prepareMainLooper();<br>        Looper.getMainLooper().setSlowLogThresholdMs(<br>                SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);<br><br>        SystemServiceRegistry.sEnableServiceNotFoundWtf = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 加载android_servers.so库，初始化Native服务</span><br>        System.loadLibrary(<span class="hljs-string">&quot;android_servers&quot;</span>);<br><br>        <span class="hljs-comment">// 允许堆内存分析</span><br>        initZygoteChildHeapProfiling();<br><br>        <span class="hljs-comment">// Debug模式下开启一条线程监听文件描述符泄露</span><br>        <span class="hljs-keyword">if</span> (Build.IS_DEBUGGABLE) &#123;<br>            spawnFdLeakCheckThread();<br>        &#125;<br><br>        <span class="hljs-comment">// Check whether we failed to shut down last time we tried.</span><br>        <span class="hljs-comment">// This call may not return.</span><br>        performPendingShutdown();<br><br>        <span class="hljs-comment">// 创建系统上下文</span><br>        createSystemContext();<br><br>        <span class="hljs-comment">// Call per-process mainline module initialization.</span><br>        ActivityThread.initializeMainlineModules();<br><br>        <span class="hljs-comment">// 创建系统管理服务——SystemServiceManager</span><br>        mSystemServiceManager = <span class="hljs-keyword">new</span> SystemServiceManager(mSystemContext);<br>        mSystemServiceManager.setStartInfo(mRuntimeRestart,<br>                mRuntimeStartElapsedTime, mRuntimeStartUptime);<br>        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<br>        <span class="hljs-comment">// Prepare the thread pool for init tasks that can be parallelized</span><br>        SystemServerInitThreadPool.start();<br>        <span class="hljs-comment">// Debug模式下绑定JVMTI Agent</span><br>        <span class="hljs-keyword">if</span> (Build.IS_DEBUGGABLE) &#123;<br>        ···<br>    &#125;<br><br>    <span class="hljs-comment">// Setup the default WTF handler</span><br>    RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf);<br><br>    <span class="hljs-comment">// Start services.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        t.traceBegin(<span class="hljs-string">&quot;StartServices&quot;</span>);<br>        <span class="hljs-comment">// 启动引导服务</span><br>        startBootstrapServices(t);<br>        <span class="hljs-comment">// 启动核心服务</span><br>        startCoreServices(t);<br>        <span class="hljs-comment">// 启动其他服务</span><br>        startOtherServices(t);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;******************************************&quot;</span>);<br>        Slog.e(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;************ Failure starting system services&quot;</span>, ex);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        t.traceEnd(); <span class="hljs-comment">// StartServices</span><br>    &#125;<br>  <br>    ···<br>  <br>    <span class="hljs-comment">// 开启Loop循环</span><br>    Looper.loop();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>createSystemContext用于创建系统上下文，此方法中首先会创建ActivityThread对象，并且调用ActivityThread#attach方法，然后通过ActivityThread对象来构建SystemContext。</p><p>在启动服务之前，方法中首先创建了SystemServiceManager，由它负责创建、启动和管理服务。</p><p>接着通过三个方法来分别启动不同类型的服务：</p><ul><li>startBootstrapServices：启动引导服务，包括Installer、ActivityManagerService、ActivityTaskManagerService、PackageManagerService等。</li><li>startCoreServices：启动核心服务，包括SystemConfigService、BatteryService、UsageStatsService、WebViewUpdateService等。</li><li>startOtherServices：启动其他服务，包括NetworkManagementService、NetworkStatsService、InputManagerService、TelephonyRegistry等。</li></ul><p>实际上每个方法负责启动的服务还有很多，这里只是举例了几个常用的服务。</p><p>这些服务的启动逻辑是相似的，这里以Android 10新增的ActivityTaskManagerService为例，来演示一遍服务启动流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityTaskManagerService atm =<br>    mSystemServiceManager<br>        .startService(ActivityTaskManagerService.Lifecycle.class)<br>        .getService();<br></code></pre></td></tr></table></figure><p>ActivityTaskManagerService的静态内部类Lifecycle继承自SystemService，其构造方法中会创建外部类ActivityTaskManagerService的实例。</p><h4 id="SystemServiceManager-startService"><a href="#SystemServiceManager-startService" class="headerlink" title="SystemServiceManager#startService"></a>SystemServiceManager#startService</h4><blockquote><p>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;SystemService&gt; mServices = <span class="hljs-keyword">new</span> ArrayList&lt;SystemService&gt;();    <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> SystemService service)</span> </span>&#123;<br>    <span class="hljs-comment">// 注册服务（添加到list中）</span><br>    mServices.add(service);<br>    <span class="hljs-keyword">long</span> time = SystemClock.elapsedRealtime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用onStart启动服务</span><br>        service.onStart();<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failed to start service &quot;</span> + service.getClass().getName()<br>                + <span class="hljs-string">&quot;: onStart threw an exception&quot;</span>, ex);<br>    &#125;<br>    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, <span class="hljs-string">&quot;onStart&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ActivityTaskService-Lifecycle-onStart"><a href="#ActivityTaskService-Lifecycle-onStart" class="headerlink" title="ActivityTaskService.Lifecycle#onStart"></a>ActivityTaskService.Lifecycle#onStart</h4><blockquote><p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lifecycle</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 注册到ServiceManager中供其他进程使用</span><br>    publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);<br>    mService.start();<br>&#125;<br><br><span class="hljs-comment">// ActivityTaskManagerService</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将内部类ActivityTaskManagerService$LocalService添加到本地服务中，供本地进程内使用</span><br>    LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法做了两件事：</p><ol><li>将ActivityTaskManagerService对象注册到ServiceManager中，其他进程通过访问ServiceManager来获取ActivityTaskManagerService的代理对象。</li><li>将ActivityTaskManagerService的内部类LocalService添加到本地服务列表，LocalService不是一个IBinder对象，它用于当前进程内部使用ATMS服务。</li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我们来总结一下SystemServer进程被创建后所做的工作：</p><ol><li>启动Binder线程池，用于与其他进程进行Bind通信。</li><li>创建SystemServiceManager，用于启动、创建和管理服务。</li><li>启动各种系统服务，分为引导服务、核心服务和其他服务。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面通过几个问题来结束此篇<del>又臭又长</del>的文章。</p><h3 id="Q：系统服务何时启动？如何启动？"><a href="#Q：系统服务何时启动？如何启动？" class="headerlink" title="Q：系统服务何时启动？如何启动？"></a>Q：系统服务何时启动？如何启动？</h3><p>A：在SystemServer进程启动时，会分批启动所有系统服务。</p><p>通过SystemServiceManager#startService来启动一个服务，服务启动后需要注册到ServiceManager中，其他进程访问ServiceManager来获取服务的代理对象。</p><h3 id="Q：什么是Zygote预加载？"><a href="#Q：什么是Zygote预加载？" class="headerlink" title="Q：什么是Zygote预加载？"></a>Q：什么是Zygote预加载？</h3><p>A：预加载是指在Zygote进程启动的时候就加载一些类库和资源文件，这样系统只需要在第一次启动Zygote时加载这些共用的资源，子进程创建时只需要复用即可无需再次加载。</p><p>这些资源被保存到全局变量Resources中，它是一个全局静态变量，可以通过 Resources.getSystem() 来使用它。</p><p><img src="/img//image-20210528163812187.png" alt="全局资源Resources"></p><h3 id="Q：系统中有几个Zygote进程？"><a href="#Q：系统中有几个Zygote进程？" class="headerlink" title="Q：系统中有几个Zygote进程？"></a>Q：系统中有几个Zygote进程？</h3><p>A：按照我们上面的源码分析，系统中有两个Zygote进程，进程名分别为zygote和zygote64。</p><p>但如果我们使用adb shell ps查看真机上的进程时，会发现多了一个名为webview_zygote的进程，有时候还会有一个名为App包名_zygote的进程。</p><p>这两个进程实际上是由ZygoteProcess#startChildZygote创建而来，这些进程继承了Zygote中的数据，并且可以与Zygote连接。</p><p>创建它们的目的通常是明确的，例如WebViewZygtoe用于启动一个WebView进程。</p><p>不过按照通常意义来讲的Zygote进程最少一个最多两个。</p><h3 id="Q：为什么SystemServer与Zygote进程之间的通信采用Unix-Domain-Sockt而不是Binder？"><a href="#Q：为什么SystemServer与Zygote进程之间的通信采用Unix-Domain-Sockt而不是Binder？" class="headerlink" title="Q：为什么SystemServer与Zygote进程之间的通信采用Unix Domain Sockt而不是Binder？"></a>Q：为什么SystemServer与Zygote进程之间的通信采用Unix Domain Sockt而不是Binder？</h3><p>A：关键的原因有：</p><ul><li>fork采用的是CopyOnWrite机制，由于可能存在的死锁问题，Unix禁止fork多线程程序。Zygote当然也是多线程的，除了主线程外还有4条守护线程，每次fork前都需要停止这些线程，待fork结束后重新执行。</li><li>Zygote进程先于SystemServer创建，如果要使用Binder，那么需要等待SystemServer创建完成之后再向SystemServer注册Binder服务，这里需要额外的同步操作。</li></ul><p>Binder机制是需要建立Binder线程池的，代理对象对Binder的调用是在Binder线程池中，在通过线程间通信通知主线程。</p><p>例如Activity启动时，AMS的本地代理IApplicationThread运行在Binder线程池中，处理完毕后通过Handler通知ActivityThread来执行启动Activity的流程。</p><p>Zygote本身只需与SystemServer以及子Zygote进程通信，并不依赖多线程来提升性能，若使用Binder反而增加了Zygote中的线程数，使得性能下降。</p><p><img src="/img/image-20210531180408524.png" alt="Zygote中的线程"></p><p>SystemServer不受到此限制，它并不需要fork自身来创建子进程，所以它会在第一时间初始化Binder线程池。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:">Android API 29 Platform</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/30358046/">《Android进阶解密》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="http://gityuan.com/2016/02/01/android-booting/">Android系统启动-综述</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://gityuan.com/2016/02/05/android-init/">Android系统启动-Init篇</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://blog.csdn.net/yiranfeng/article/details/103549394">Android 10.0系统启动之init进程-[Android取经之路]</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://blog.csdn.net/yiranfeng/article/details/103549872">Android10.0系统启动之Zygote进程-Android取经之路</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Android Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOSP</tag>
      
      <tag>Zygote</tag>
      
      <tag>SystemServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（六）——从字节码角度理解协程</title>
    <link href="/2021/05/06/40879c1f/"/>
    <url>/2021/05/06/40879c1f/</url>
    
    <content type="html"><![CDATA[<p>之前的协程文章中并没有采用字节码来分析，原因一是当时对字节码不是很熟悉，二是不好用一个更难的概念来解释一个没那么难的概念。我们知道协程的关键实现都是由 kotlinc 即编译器来完成，而 IDE 反编译的代码阅读性很差，那么现在学习了字节码之后就可以通过 javap 来一探究竟了。</p><h3 id="suspend-function"><a href="#suspend-function" class="headerlink" title="suspend function"></a>suspend function</h3><p>kotlin协程的”黑魔法“基础是 suspend 关键字，先来这个方法看看背后做了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestUserToken</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>  = <span class="hljs-string">&quot;faketoken&quot;</span><br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">(token: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;UserInfo&gt; &#123;<br>    thread &#123;<br>        Thread.sleep(<span class="hljs-number">1000L</span>)<br>        it.resumeWith(Result.success(UserInfo(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>)))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>requestUserToken 方法虽然声明为 suspend，但并没有发生<strong>”事实上的挂起“</strong>，使用 javap 编译后字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">requestUserToken</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, kotlin.coroutines.Continuation&lt;? <span class="hljs-keyword">super</span> java.lang.String&gt;)</span></span>;<br>  descriptor: (ILkotlin/coroutines/Continuation;)Ljava/lang/Object;<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>       0: ldc           #11                 // String faketoken<br>       <span class="hljs-number">2</span>: areturn<br></code></pre></td></tr></table></figure><p>可以看到 requestUserToken 方法的实现并没有什么特殊，但是我们只定义了一个 int 型参数，而方法签名中多了一个参数，为Continuation类型，是这个挂起函数与普通函数的唯一区别了。至于这个 Continuation 对象的作用暂时还不知道，先来看另外一个方法。</p><p>fetchUserInfo 的字节码就比较多了，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">(java.lang.String, kotlin.coroutines.Continuation&lt;? <span class="hljs-keyword">super</span> com.sukaidev.fuckingaosp.UserInfo&gt;)</span></span>;<br>  descriptor: (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">8</span>, locals=<span class="hljs-number">8</span>, args_size=<span class="hljs-number">2</span><br>       <span class="hljs-number">0</span>: iconst_0<br>       <span class="hljs-number">1</span>: istore_2<br>       <span class="hljs-number">2</span>: iconst_0<br>       <span class="hljs-number">3</span>: istore_3<br>       <span class="hljs-number">4</span>: aload_1<br>       <span class="hljs-number">5</span>: astore_3<br>       <span class="hljs-number">6</span>: iconst_0<br>       <span class="hljs-number">7</span>: istore        <span class="hljs-number">4</span><br>       9: new           #115                // class kotlin/coroutines/SafeContinuation<br>      <span class="hljs-number">12</span>: dup<br>      <span class="hljs-number">13</span>: aload_3<br>      14: invokestatic  #119                // Method kotlin/coroutines/intrinsics/IntrinsicsKt.intercepted:(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;<br>      17: invokespecial #120                // Method kotlin/coroutines/SafeContinuation.&quot;&lt;init&gt;&quot;:(Lkotlin/coroutines/Continuation;)V<br>      <span class="hljs-number">20</span>: astore        <span class="hljs-number">5</span><br>      <span class="hljs-number">22</span>: aload         <span class="hljs-number">5</span><br>      24: checkcast     #112                // class kotlin/coroutines/Continuation<br>      <span class="hljs-number">27</span>: astore        <span class="hljs-number">6</span><br>      <span class="hljs-number">29</span>: iconst_0<br>      <span class="hljs-number">30</span>: istore        <span class="hljs-number">7</span><br>      <span class="hljs-number">32</span>: iconst_0<br>      <span class="hljs-number">33</span>: iconst_0<br>      <span class="hljs-number">34</span>: aconst_null<br>      <span class="hljs-number">35</span>: aconst_null<br>      <span class="hljs-number">36</span>: iconst_0<br>      37: new           #146                // class com/sukaidev/fuckingaosp/CoroutineTestKt$fetchUserInfo$2$1<br>      <span class="hljs-number">40</span>: dup<br>      <span class="hljs-number">41</span>: aload         <span class="hljs-number">6</span><br>      43: invokespecial #147                // Method com/sukaidev/fuckingaosp/CoroutineTestKt$fetchUserInfo$2$1.&quot;&lt;init&gt;&quot;:(Lkotlin/coroutines/Continuation;)V<br>      46: checkcast     #125                // class kotlin/jvm/functions/Function0<br>      <span class="hljs-number">49</span>: bipush        <span class="hljs-number">31</span><br>      <span class="hljs-number">51</span>: aconst_null<br>      52: invokestatic  #131                // Method kotlin/concurrent/ThreadsKt.thread$default:(ZZLjava/lang/ClassLoader;Ljava/lang/String;ILkotlin/jvm/functions/Function0;ILjava/lang/Object;)Ljava/lang/Thread;<br>      <span class="hljs-number">55</span>: pop<br>      <span class="hljs-number">56</span>: nop<br>      <span class="hljs-number">57</span>: aload         <span class="hljs-number">5</span><br>      59: invokevirtual #134                // Method kotlin/coroutines/SafeContinuation.getOrThrow:()Ljava/lang/Object;<br>      <span class="hljs-number">62</span>: dup<br>      63: invokestatic  #41                 // Method kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED:()Ljava/lang/Object;<br>      <span class="hljs-number">66</span>: if_acmpne     <span class="hljs-number">73</span><br>      <span class="hljs-number">69</span>: aload_1<br>      70: invokestatic  #139                // Method kotlin/coroutines/jvm/internal/DebugProbesKt.probeCoroutineSuspended:(Lkotlin/coroutines/Continuation;)V<br>      <span class="hljs-number">73</span>: areturn<br></code></pre></td></tr></table></figure><p>方法同样有一个 Continuation 类型的入参，下面我们简称 completion，首先创建了一个 SafeContinuation 实例，然后调用 completion.intercepted 方法，接着调用了 SafeContinuation 的构造器，翻译成代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> safe = SafeContinuation(completion.intercepted())<br></code></pre></td></tr></table></figure><p>接下来就是比较关键的地方，第37行创建了一个 <strong>CoroutineTestKt$fetchUserInfo$2$1</strong> 对象，并将SafeContinuation 对象作为参数传入，CoroutineTestKt$fetchUserInfo$2$1 是编译器自动生成的类，对应我们传入 suspendCoroutine 方法中传入 thread 方法中的 block lambda。</p><p>第52行调用了 TreadKt.thread 方法，创建了一个线程，并把 CoroutineTestKt$fetchUserInfo$2$1 对象作为参数传入。</p><p>第59行调用 <code>SafeContinuation.getOrThrow</code> 方法来获取结果，如果结果为 <strong>COROUTINE_SUSPENDED</strong> 则表示发生了挂起，然后会调用 <strong>DebugProbesKt.probeCoroutineSuspended</strong> 方法将 completion 传入，最后返回结果。</p><p>DebugProbes.kt类定义了几个用于debugger调试用的切面方法，主要用于调试器追踪协程，同时也可以替换Continuation实例。</p><ul><li>probeCoroutineCreated：这个方法在createCoroutineUnintercepted中被调用，即我们每次调用createCoroutine时。</li><li>probeCoroutineResumed：这个方法在BaseContinuation#resumeWith中被调用。</li><li>probeCoroutineSuspended：在每次使用suspendCoroutineUninterceptedOrReturn来挂起协程时被调用。</li></ul><p>另外 DebugProbes.kt文件中 的注释中提到了比较关键的一点：</p><blockquote><p>Coroutines machinery implementation guarantees that the actual [frame] instance extends [BaseContinuationImpl] class, despite the fact that the declared type of [frame] parameter in this function is <code>Continuation&lt;*&gt;</code>. See [probeCoroutineCreated] for details.</p></blockquote><p>即编译器会保证中间生成的Continuation对象是继承自BaseContinuationImpl的，而协程的结束回调则是直接继承Continuation的，这个与我们后文提到的协程出口有关系。</p><p>DebugProbes中还提供了协程的状态流转图：</p><p><img src="/img/jvm/image-20210501222228476.png" alt="Kotlin协程的状态流转"></p><p>这对我们理解协程的执行有帮助。</p><h3 id="suspend-main"><a href="#suspend-main" class="headerlink" title="suspend main"></a>suspend main</h3><p>在<a href="/2021/02/01/595755ca/#%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84main%E5%87%BD%E6%95%B0">《深入理解Kotlin协程（一）——基本概念与原理》</a>一文中我们简单分析了可挂起的 main 函数的实现方式，下面就通过字节码来验证文中的分析过程。</p><p>以下面代码为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;suspend main.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后生成两个 class 文件，分别为 CoroutineTestKt.class 和 CoroutineTestKt$$$main.class。先来看看编译生成的 CoroutineTestKt$$$main.class 文件，这 class 文件的名字第一眼看过去觉得毫无头绪，为什么会有 3 个 $ 符号呢？</p><p>在<a href="/2021/04/25/d39e151e/#Kotlin-%E4%B8%AD%E7%9A%84-Lambda">上一篇文章</a>中我们讲过 Kotlin 中 Lambda 表达式的原理，其中说到了 kotlinc 生成的实现 Lambda 表达式的类的命名规则为：<strong>OuterClassName$OuterFunctionName$LambdaExpressionName$n</strong>。我们把本例的 suspend man 方法代入会发现恰好符合这个规则。</p><p>我们猜到了 CoroutineTestKt$$$main 实际由 Lambda 表达式生成，继续来看 CoroutineTestKt$$$main.class 的字节码，发现该类确实继承自 Lambda 类，并且实现了 Function1 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">coroutine</span>.<span class="hljs-title">CoroutineTestKt</span>$$$<span class="hljs-title">main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">internal</span>.<span class="hljs-title">Lambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">functions</span>.<span class="hljs-title">Function1</span></span><br></code></pre></td></tr></table></figure><p>虽然验证了我们的猜想，但实际上我们并没有编写任何 Lambda 表达式，这显然编译器对 <strong>suspend main</strong> 做的特殊处理。既然实现了 Function1 接口，那么就来看下 invoke 方法是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(java.lang.Object)</span></span>;<br>    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;<br>    flags: ACC_PUBLIC, ACC_FINAL, ACC_SYNTHETIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: aload_1<br>         1: checkcast     #19                 // class kotlin/coroutines/Continuation<br>         4: invokestatic  #25                 // Method coroutine/CoroutineTestKt.main:(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;<br>         <span class="hljs-number">7</span>: areturn<br>&#125;<br></code></pre></td></tr></table></figure><p>第 0~1 行将参数加载到栈中并强转为 <strong>Continuation</strong> 类型，然后调用了 CoroutineTestKt.main 方法将 Continuation 对象传入。</p><p>这里需要注意的是，invoke 方法携带一个 Continuation 类型的参数，跟我们上一节讨论的被 <strong>suspend</strong> 关键字修饰的方法（即挂起函数）是相同的，那么它也能作为一个挂起函数来使用。</p><p>CoroutineTestKt$$$main 中的字节码就只有 invoke 一个方法了，接下来就要去 CoroutineTestKt 中寻找哪个地方调用了 <strong>CoroutineTestKt$$$main.invoke</strong>。先来看 Java 入口 main 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: new           #10                 // class coroutine/CoroutineTestKt$$$main<br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: aload_0<br>         5: invokespecial #13                 // Method coroutine/CoroutineTestKt$$$main.&quot;&lt;init&gt;&quot;:([Ljava/lang/String;)V<br>         8: invokestatic  #19                 // Method kotlin/coroutines/jvm/internal/RunSuspendKt.runSuspend:(Lkotlin/jvm/functions/Function1;)V<br>        <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>main 方法中创建了 CoroutineTestKt$$$main 对象并且将其传给了 <strong>RunSuspendKt.runSuspend</strong> 方法，来看看这个方法做了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码已经很熟悉了，其实就是使用 suspend {} 代码块来启动一个协程，而这段协程的回调是 RunSuspend 对象，并且在启动协程后调用了 <strong>RunSuspend#await</strong> 方法。这个方法在<a href="/2021/02/01/595755ca/#%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84main%E5%87%BD%E6%95%B0">《深入理解Kotlin协程（一）——基本概念与原理》</a>一文中已经分析了，这里再贴出它的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">this</span>.result = result<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>                <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上就是用 <strong>wait/notify</strong> 来控制虚拟机执行流程，等待协程运行完再退出。</p><p>而这个传进来的 suspend {} 代码块实际上就是 CoroutineTestKt.class 中的另一个 main 方法，这个方法包含了协程需要执行的所有代码，具体内容下节讨论。现在我们可以用伪代码来表示整个 suspend main 的被编译后的逻辑了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 继承自 Continuation</span><br>    <span class="hljs-keyword">val</span> run = Runsuspend()<br>    <span class="hljs-comment">// suspend &#123;&#125; 被编译为 CoroutineTestKt$$$main</span><br>    <span class="hljs-keyword">suspend</span> main&#123;continuation -&gt;<br>        <span class="hljs-comment">// lambda体 被编译为CoroutineTestKt$$$main.class</span><br>        <span class="hljs-comment">// 此 main 方法由编译器额外生成</span><br>        CoroutineTestKt.main(continuation)<br>    &#125;.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程的启动和执行过程"><a href="#协程的启动和执行过程" class="headerlink" title="协程的启动和执行过程"></a>协程的启动和执行过程</h3><p>上一节我们搞懂了 suspend main 背后的逻辑，知道其背后实际上是创建了一个简单协程，但对于这个协程的启动和执行过程还不太清楚，现在我们就通过一个例子来深入一下协程的执行流程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> token = requestUserToken(<span class="hljs-number">0</span>)<br>    println(<span class="hljs-string">&quot;user token is : <span class="hljs-variable">$token</span>&quot;</span>)<br>    <span class="hljs-keyword">val</span> userInfo = fetchUserInfo(token)<br>    println(<span class="hljs-string">&quot;user info is : <span class="hljs-variable">$userInfo</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestUserToken</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span> = suspendCoroutine&lt;String&gt; &#123;<br>    it.resumeWith(Result.success(<span class="hljs-string">&quot;faketoken&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">(token: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;UserInfo&gt; &#123;<br>    thread &#123;<br>        Thread.sleep(<span class="hljs-number">1000L</span>)<br>        it.resumeWith(Result.success(UserInfo(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span>(<span class="hljs-keyword">val</span> userId: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> userName: String)<br></code></pre></td></tr></table></figure><p>该例依然是通过 suspend main 构建的协程，其中 requestUserToken 和 fetchUserInfo 都是挂起函数。</p><p>通过上面的分析我们已经知道 suspend main 创建的协程体为 CoroutineTestKt.main 静态方法，此方法接收一个 Continuation 类型的参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> java.lang.Object main(kotlin.coroutines.Continuation&lt;? <span class="hljs-keyword">super</span> kotlin.<span class="hljs-built_in">Unit</span>&gt;);<br></code></pre></td></tr></table></figure><p>那么这个参数是由谁传入的呢？回到上文中提到的 <strong>RunSuspendKt.runSuspend</strong> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    <span class="hljs-comment">// 启动协程</span><br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></td></tr></table></figure><p>此处的block 其实就是 CoroutineTestKt.main，继续跟进：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// block.startCoroutine(run)</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br><br><span class="hljs-comment">// 创建协程并且调用 resume(Unit) 启动</span><br>    createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 intrinsicsJvm.kt 文件中可以看到 <strong>createCoroutineUnintercepted</strong> 的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)<br>    <span class="hljs-comment">// 从Suspend Lambda创建的协程会继承自SuspendLambda，继而继承自BaseContinuationImpl</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl)<br>        create(probeCompletion)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// suspend function创建的协程</span><br>        createCoroutineFromSuspendFunction(probeCompletion) &#123;<br>            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>suspend main 创建的简单协程会通过 <strong>createCoroutineFromSuspendFunction</strong> 来创建，createCoroutineFromSuspendFunction 的源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createCoroutineFromSuspendFunction</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> context = completion.context<br>    <span class="hljs-comment">// label == 0 when coroutine is not started yet (initially) or label == 1 when it was</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (context === EmptyCoroutineContext)<br>        <span class="hljs-keyword">object</span> : RestrictedContinuationImpl(completion <span class="hljs-keyword">as</span> Continuation&lt;Any?&gt;) &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> label = <span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any? =<br>                <span class="hljs-keyword">when</span> (label) &#123;<br>                    <span class="hljs-number">0</span> -&gt; &#123;<br>                        label = <span class="hljs-number">1</span><br>                        result.getOrThrow() <span class="hljs-comment">// Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith</span><br>                        <span class="hljs-comment">// 调用 block ，也就是 CoroutineTestKt.main</span><br>                        <span class="hljs-comment">// 注意这里传入了this</span><br>                        block(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// run the block, may return or suspend</span><br>                    &#125;<br>                    <span class="hljs-number">1</span> -&gt; &#123;<br>                        label = <span class="hljs-number">2</span><br>                        result.getOrThrow() <span class="hljs-comment">// this is the result if the block had suspended</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;This coroutine had already completed&quot;</span>)<br>                &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">object</span> : ContinuationImpl(completion <span class="hljs-keyword">as</span> Continuation&lt;Any?&gt;, context) &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> label = <span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any? =<br>                <span class="hljs-keyword">when</span> (label) &#123;<br>                    <span class="hljs-number">0</span> -&gt; &#123;<br>                        label = <span class="hljs-number">1</span><br>                        result.getOrThrow() <span class="hljs-comment">// Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith</span><br>                        <span class="hljs-comment">// 调用我们的协程体构造块</span><br>                        block(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// run the block, may return or suspend</span><br>                    &#125;<br>                    <span class="hljs-number">1</span> -&gt; &#123;<br>                        label = <span class="hljs-number">2</span><br>                        result.getOrThrow() <span class="hljs-comment">// this is the result if the block had suspended</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;This coroutine had already completed&quot;</span>)<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到当我们的 CoroutineContext 为 <strong>EmptyCoroutineContext</strong> 时，创建的是一个 <strong>RestrictedContinuationImpl</strong> 对象，RestrictedContinuationImpl 继承自 <strong>BaseContinuationImpl</strong>，主要实现了 <strong>invokeSuspend</strong> 方法。invokeSuspend 方法实际是一个状态机实现，其中 label 作为状态变量控制状态机的状态转移，通过注释我们知道：</p><ul><li>label 默认为0，当 invokeSuspend 方法第一次执行时，label 将会被设置为1，然后会调用我们的协程体代码，即 block，<strong>将 this 传入</strong>，并返回结果，这个结果可能是执行结果也可能是挂起标志。</li><li>当 invokeSuspend 方法第二此执行时，此时 label 为1，这种情况说明 block 发生了挂起，此时通过 result.getOrThrow 获取到的就是真正的执行结果，然后将结果返回。</li><li>若 invokeSuspend 调用时 label 既不为0也不为1，则说明协程被重复启动了，此时会直接抛异常。</li></ul><p>到这里我们已经知道了 suspend main 创建的是一个 RestrictedContinuationImpl 对象，当调用 <strong>resume(Unit)</strong> 启动协程时，实际会调用到 <strong>BaseContinuationImpl#resumeWith</strong> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span><br>    <span class="hljs-keyword">var</span> param = result<br>  <br>    <span class="hljs-comment">// 注意理解这个while循环存在的意义</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        probeCoroutineResumed(current)<br>        with(current) &#123;<br>            <span class="hljs-keyword">val</span> completion = completion!! <br>            <span class="hljs-keyword">val</span> outcome: Result&lt;Any?&gt; =<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 在这里调用了 invokeSuspend</span><br>                    <span class="hljs-keyword">val</span> outcome = invokeSuspend(param)<br>                    <span class="hljs-comment">// 如果协程挂起  直接返回退出while循环</span><br>                    <span class="hljs-keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="hljs-keyword">return</span><br>                    Result.success(outcome)<br>                &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>                    Result.failure(exception)<br>                &#125;<br>            releaseIntercepted()<br>            <span class="hljs-keyword">if</span> (completion <span class="hljs-keyword">is</span> BaseContinuationImpl) &#123;<br>                <span class="hljs-comment">// 如果 completion 是 BaseContinuationImpl类型</span><br>                <span class="hljs-comment">// 说明 completion 并不是真正的协程结束回调，更新 current 继续循环</span><br>                current = completion<br>                param = outcome<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果 completion 不是 BaseContinuationImpl 类型</span><br>                <span class="hljs-comment">// 例如 suspend main 中的 RunSuspend 就直接继承自 Continuation</span><br>                <span class="hljs-comment">// 说明 completion 是真正的协程结束回调，调用 resumeWith 并 return</span><br>                completion.resumeWith(outcome)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个while(true)循环，借助注释可以帮助我们理解：</p><blockquote><p>This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume.</p></blockquote><p>这句话的意思是，此while循环可以帮助我们展开一些没有发生真正挂起的协程调用，相当于将递归转换成为了迭代，使得堆栈的跟踪更为简短和清晰。</p><p>来到循环内部，可以看到invokeSuspend 方法在这里被调用，那么协程体也会在此处执行，对应本例中的 CoroutineTestKt.main 方法，同时会将 this 传入，也就是说 <strong>CoroutineTestKt.main 中首次传入的参数为 RunSuspend#runSuspend 中创建的 RestrictedContinuationImpl 对象</strong>。</p><p>接着分析协程的执行流程，如果 invokeSuspend 方法返回的是挂起标志 <strong>COROUTINE_SUSPENDED</strong> 的话，就会直接 return，使得当前while循环退出，等待 resumeWith 下一次被调用。这也是我们在使用 suspendCoroutine 挂起外部协程时需要调用 resumeWith 恢复协程执行的原因。</p><p><img src="/img/jvm/image-20210508141910803.png" alt="使用resumeWith恢复协程执行"></p><p>再次进入 resumeWith 后，invokeSuspend 返回的就是真正的结果了，此时会判断 completion 的类型：</p><ul><li>如果 completion 为 BaseContinuationImpl 类型，说明此时的结束回调 competition 并不是真正的协程结束回调，那么就会更新 current 和 param 的值，循环继续。</li><li>如果 completion 不为 BaseContinuationImpl，例如本例中 RunSuspend 直接继承自 Continuation，说明协程执行完毕，则会调用 completion.resumeWith，然后return。</li></ul><p>到这里协程的整个执行大致的流程就分析完毕了，下一节我们结合这个流程来分析例子的执行过程。</p><h3 id="同步方式写异步代码的秘密"><a href="#同步方式写异步代码的秘密" class="headerlink" title="同步方式写异步代码的秘密"></a>同步方式写异步代码的秘密</h3><p>我们都知道 kotlin 协程可以以同步方式编写异步代码是 kotlinc 所做的”黑魔法“，但是具体是怎么做的，以及协程具体如何执行我们还是一概不知，而对协程 debug 也会经常出现代码与字节码不匹配的情况，因此要搞懂具体的原理还是要从字节码来入手。</p><p>继续看上节的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> token = requestUserToken(<span class="hljs-number">0</span>)<br>    println(<span class="hljs-string">&quot;user token is : <span class="hljs-variable">$token</span>&quot;</span>)<br>    <span class="hljs-keyword">val</span> userInfo = fetchUserInfo(token)<br>    println(<span class="hljs-string">&quot;user info is : <span class="hljs-variable">$userInfo</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestUserToken</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span> = suspendCoroutine&lt;String&gt; &#123;<br>    it.resumeWith(Result.success(<span class="hljs-string">&quot;faketoken&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">(token: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;UserInfo&gt; &#123;<br>    thread &#123;<br>        Thread.sleep(<span class="hljs-number">1000L</span>)<br>        it.resumeWith(Result.success(UserInfo(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span>(<span class="hljs-keyword">val</span> userId: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> userName: String)<br></code></pre></td></tr></table></figure><p>这段代码编译后生成了好几个 class 文件，如图所示：</p><p><img src="/img/jvm/image-20210501224519606.png" alt="编译生成文件"></p><p>根据上文的分析，通过这些文件名我们就可以猜到这些 class 文件的作用了。</p><ul><li>TestKt.class：由 Test.kt 源码编译而来。</li><li>TestKt$$$main.class：由 Test.kt 中 suspend main Lambda 表达式编译而来，实际是 TestKt.main（非 Java 入口 main 方法）方法的装饰类。</li><li>TestKt$fetchUserInfo$2$1.class：对应 fetchUserInfo 方法中传递给 thread 方法的 block 代码块，实际上是一个Lambda。</li><li>UserInfo.class：由数据类 UserInfo 编译而来。</li></ul><p>其中 TestKt$main$1.class 看命名似乎是由一个匿名内部类生成，它继承自 ContinuationImpl 并且实现了 invokesuspend 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">sukaidev</span>.<span class="hljs-title">fuckingaosp</span>.<span class="hljs-title">CoroutineTestKt</span>$<span class="hljs-title">main</span>$1 <span class="hljs-keyword">extends</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">coroutines</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">internal</span>.<span class="hljs-title">ContinuationImpl</span></span><br></code></pre></td></tr></table></figure><p>我们回过头来看看例子中的 CoroutineTestKt.main 方法，此方法字节码较为复杂，先将完整的贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-number">0</span>: aload_0<br>  1: instanceof    #23                 // class com/sukaidev/fuckingaosp/CoroutineTestKt$main$1<br>  <span class="hljs-number">4</span>: ifeq          <span class="hljs-number">39</span><br>  <span class="hljs-number">7</span>: aload_0<br>  8: checkcast     #23                 // class com/sukaidev/fuckingaosp/CoroutineTestKt$main$1<br> <span class="hljs-number">11</span>: astore        <span class="hljs-number">6</span><br> <span class="hljs-number">13</span>: aload         <span class="hljs-number">6</span><br> 15: getfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br> 18: ldc           #28                 // int -2147483648<br> <span class="hljs-number">20</span>: iand<br> <span class="hljs-number">21</span>: ifeq          <span class="hljs-number">39</span><br> <span class="hljs-number">24</span>: aload         <span class="hljs-number">6</span><br> <span class="hljs-number">26</span>: dup<br> 27: getfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br> 30: ldc           #28                 // int -2147483648<br> <span class="hljs-number">32</span>: isub<br> 33: putfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br> <span class="hljs-number">36</span>: goto          <span class="hljs-number">49</span><br> 39: new           #23                 // class com/sukaidev/fuckingaosp/CoroutineTestKt$main$1<br> <span class="hljs-number">42</span>: dup<br> <span class="hljs-number">43</span>: aload_0<br> 44: invokespecial #31                 // Method com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.&quot;&lt;init&gt;&quot;:(Lkotlin/coroutines/Continuation;)V<br> <span class="hljs-number">47</span>: astore        <span class="hljs-number">6</span><br> <span class="hljs-number">49</span>: aload         <span class="hljs-number">6</span><br> 51: getfield      #35                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.result:Ljava/lang/Object;<br> <span class="hljs-number">54</span>: astore        <span class="hljs-number">5</span><br> 56: invokestatic  #41                 // Method kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED:()Ljava/lang/Object;<br> <span class="hljs-number">59</span>: astore        <span class="hljs-number">7</span><br> <span class="hljs-number">61</span>: aload         <span class="hljs-number">6</span><br> 63: getfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br> <span class="hljs-number">66</span>: tableswitch   &#123; <span class="hljs-comment">// 0 to 2</span><br>                <span class="hljs-number">0</span>: <span class="hljs-number">92</span><br>                <span class="hljs-number">1</span>: <span class="hljs-number">118</span><br>                <span class="hljs-number">2</span>: <span class="hljs-number">179</span><br>          <span class="hljs-keyword">default</span>: <span class="hljs-number">224</span><br>     &#125;<br> <span class="hljs-number">92</span>: aload         <span class="hljs-number">5</span><br> 94: invokestatic  #47                 // Method kotlin/ResultKt.throwOnFailure:(Ljava/lang/Object;)V<br> <span class="hljs-number">97</span>: iconst_0<br> <span class="hljs-number">98</span>: aload         <span class="hljs-number">6</span><br><span class="hljs-number">100</span>: aload         <span class="hljs-number">6</span><br><span class="hljs-number">102</span>: iconst_1<br>103: putfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br>106: invokestatic  #51                 // Method requestUserToken:(ILkotlin/coroutines/Continuation;)Ljava/lang/Object;<br><span class="hljs-number">109</span>: dup<br><span class="hljs-number">110</span>: aload         <span class="hljs-number">7</span><br><span class="hljs-number">112</span>: if_acmpne     <span class="hljs-number">125</span><br><span class="hljs-number">115</span>: aload         <span class="hljs-number">7</span><br><span class="hljs-number">117</span>: areturn<br><span class="hljs-number">118</span>: aload         <span class="hljs-number">5</span><br>120: invokestatic  #47                 // Method kotlin/ResultKt.throwOnFailure:(Ljava/lang/Object;)V<br><span class="hljs-number">123</span>: aload         <span class="hljs-number">5</span><br>125: checkcast     #53                 // class java/lang/String<br><span class="hljs-number">128</span>: astore_1<br>129: new           #55                 // class java/lang/StringBuilder<br><span class="hljs-number">132</span>: dup<br>133: invokespecial #58                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V<br>136: ldc           #60                 // String user token is :<br>138: invokevirtual #64                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br><span class="hljs-number">141</span>: aload_1<br>142: invokevirtual #64                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br>145: invokevirtual #68                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br><span class="hljs-number">148</span>: astore_2<br><span class="hljs-number">149</span>: iconst_0<br><span class="hljs-number">150</span>: istore_3<br>151: getstatic     #74                 // Field java/lang/System.out:Ljava/io/PrintStream;<br><span class="hljs-number">154</span>: aload_2<br>155: invokevirtual #79                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V<br><span class="hljs-number">158</span>: aload_1<br><span class="hljs-number">159</span>: aload         <span class="hljs-number">6</span><br><span class="hljs-number">161</span>: aload         <span class="hljs-number">6</span><br><span class="hljs-number">163</span>: iconst_2<br>164: putfield      #27                 // Field com/sukaidev/fuckingaosp/CoroutineTestKt$main$1.label:I<br>167: invokestatic  #83                 // Method fetchUserInfo:(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;<br><span class="hljs-number">170</span>: dup<br><span class="hljs-number">171</span>: aload         <span class="hljs-number">7</span><br><span class="hljs-number">173</span>: if_acmpne     <span class="hljs-number">186</span><br><span class="hljs-number">176</span>: aload         <span class="hljs-number">7</span><br><span class="hljs-number">178</span>: areturn<br><span class="hljs-number">179</span>: aload         <span class="hljs-number">5</span><br>181: invokestatic  #47                 // Method kotlin/ResultKt.throwOnFailure:(Ljava/lang/Object;)V<br><span class="hljs-number">184</span>: aload         <span class="hljs-number">5</span><br>186: checkcast     #85                 // class com/sukaidev/fuckingaosp/UserInfo<br><span class="hljs-number">189</span>: astore_2<br>190: new           #55                 // class java/lang/StringBuilder<br><span class="hljs-number">193</span>: dup<br>194: invokespecial #58                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V<br>197: ldc           #87                 // String user info is :<br>199: invokevirtual #64                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br><span class="hljs-number">202</span>: aload_2<br>203: invokevirtual #90                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;<br>206: invokevirtual #68                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br><span class="hljs-number">209</span>: astore_3<br><span class="hljs-number">210</span>: iconst_0<br><span class="hljs-number">211</span>: istore        <span class="hljs-number">4</span><br>213: getstatic     #74                 // Field java/lang/System.out:Ljava/io/PrintStream;<br><span class="hljs-number">216</span>: aload_3<br>217: invokevirtual #79                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V<br>220: getstatic     #96                 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit;<br><span class="hljs-number">223</span>: areturn<br>224: new           #98                 // class java/lang/IllegalStateException<br><span class="hljs-number">227</span>: dup<br>228: ldc           #100                // String call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine<br>230: invokespecial #103                // Method java/lang/IllegalStateException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V<br><span class="hljs-number">233</span>: athrow<br></code></pre></td></tr></table></figure><p>为了方便阅读这里我直接翻译为 Java 代码，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">main</span><span class="hljs-params">(Continuation completion)</span> </span>&#123;<br>    Continuation continuation;<br>    label27:<br>    &#123;<br>        <span class="hljs-keyword">if</span> (completion <span class="hljs-keyword">instanceof</span> CoroutineTestKt$main$<span class="hljs-number">1</span>) &#123;<br>            continuation = (CoroutineTestKt$main$<span class="hljs-number">1</span>) completion;<br>            <span class="hljs-keyword">if</span> ((continuation.label &amp; Integer.MIN_VALUE) != <span class="hljs-number">0</span>) &#123;<br>                continuation.label -= Integer.MIN_VALUE;<br>                <span class="hljs-keyword">break</span> label27;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 编译后生成类 CoroutineTestKt$main$1 </span><br>        continuation = <span class="hljs-keyword">new</span> ContinuationImpl(completion) &#123;<br>            Result&lt;Object&gt; result;<br>            <span class="hljs-keyword">int</span> label;<br><br>            <span class="hljs-meta">@Nullable</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object o)</span> </span>&#123;<br>                <span class="hljs-keyword">this</span>.result = result;<br>                <span class="hljs-keyword">this</span>.label |= Integer.MIN_VALUE;<br>                <span class="hljs-keyword">return</span> CoroutineTestKt.main((Continuation) <span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    Object resultValue;<br>    label22:<br>    &#123;<br>        Result result = continuation.result;<br>        Object isSuspended = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>        <span class="hljs-keyword">switch</span> (continuation.label) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                ResultKt.throwOnFailure(result);<br>                continuation.label = <span class="hljs-number">1</span>;<br>                resultValue = requestUserToken(<span class="hljs-number">0</span>, continuation);<br>                <span class="hljs-keyword">if</span> (resultValue == isSuspended) &#123;<br>                    <span class="hljs-keyword">return</span> isSuspended;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                ResultKt.throwOnFailure(result);<br>                resultValue = result;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                ResultKt.throwOnFailure(result);<br>                resultValue = result;<br>                <span class="hljs-keyword">break</span> label22;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>        &#125;<br>        String token = (String) resultValue;<br>        String printContent = <span class="hljs-string">&quot;user token is : &quot;</span> + token;<br>        System.out.println(printContent);<br>        continuation.label = <span class="hljs-number">2</span>;<br>        resultValue = fetchUserInfo(token, continuation);<br>        <span class="hljs-keyword">if</span> (resultValue == isSuspended) &#123;<br>            <span class="hljs-keyword">return</span> isSuspended;<br>        &#125;<br>    &#125;<br>    UserInfo userInfo = (UserInfo) resultValue;<br>    String printContent = <span class="hljs-string">&quot;user info is : &quot;</span> + userInfo;<br>    System.out.println(printContent);<br>    <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面对于 suspend main 的分析，我们知道 CoroutineTestKt.main 方法（下文简称 main 方法）首次调用时传入的 Continuation 对象（即 completion ）是由编译器帮我们构造的，下面我们就来手动跟踪协程的执行过程。</p><ol><li><ul><li>首次进入 main 方法，此时 completion 不是 CoroutineTestKt$main$1 对象，因此跳过第一个if判断。接着会通过匿名内部类的方式创建一个 ContinuationImpl（即CoroutineTestKt$main$1）对象（下文简称 continuation），并将最终的回调 completion 传入。此时状态变量 label <strong>初始值为0</strong>，因此会进入 case 0 中执行 <strong>requestUserToken(userId,continuation)，并将 label 更新为 1</strong>。</li><li>requestUserToken 方法中创建了一个马甲 SafeContinuation，这个类在之前的文章讨论过，主要是用于保证协程只有在真正需要挂起时才会挂起。由于 requestUserToken 挂起了外部协程，此时返回的并不是真正的结果，而是一个挂起标志 <strong>COROUTINE_SUSPENDED</strong>，main 方法中获取到这个挂起标志时将会直接返回这个标志，通知外部协程这里发生了挂起。</li><li>requestUserToken 执行完毕后调用 <strong>continuation.resumeWith</strong> 恢复协程执行，继而调用到 <strong>continuation.invokeSuspend</strong> 方法。invokeSuspend 方法中更新了 requestUserToken 的执行结果，将 <strong>label 更新为 label |= Integer.MIN_VALUE（-2147483647）</strong>，并且重新执行了 CoroutineTestKt.main(this) 方法将自身传入。</li></ul></li><li><ul><li>重新进入 main 方法，此时的 completion 为 CoroutineTestKt$main$1 对象，因此会进入第一个 if 判断中，将 continuation 赋值为 completion，同时执行 continuation.label -= Integer.MIN_VALUE，<strong>label 被还原为1</strong>。</li><li>进入 case 1 代码块中，获取到 requestUserToken 方法执行真正的结果 token的值，接着就会执行源码中后面一行非挂起的代码 ，即 println(“user token is : $token”)。然后**更新状态变量 continuation.label 值为 2，执行 fetchUserInfo(token，continuation)**。</li><li>fetchUserInfo 方法的执行与上面 requestUserToken 方法类似，同样的会先返回挂起标志，使得外部的 main 方法直接返回挂起标志。在 continuation.resumeWith 调用后更新 result 值，和label 的值，label |= Integer.MIN_VALUE（-2147483646），然后执行CoroutineTestKt.main(this) 方法。</li></ul></li><li><ul><li>第三次进入 main 方法，同样的先会<strong>还原 label 的值为 2</strong>。进入 case 2 代码块中获取 fetchUserInfo 方法的真正结果 UserInfo 对象，并且这里会直接跳出 label22 代码块（break label22），避免重复执行。</li><li>执行剩余代码，打印 userinfo。</li></ul></li></ol><p>如果文字不够清晰的话，这里我画了一张图：</p><p><img src="/img/jvm/image-20210509211602377.png" alt="执行流程图"></p><p>使用伪代码简化上面的流程就更容易理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Continuation&lt;Unit&gt; completion)</span> </span>&#123;<br>    ContinuationImpl continuation = <span class="hljs-keyword">new</span> ContinuationImpl(completion) &#123;<br>        Result result;<br>        <span class="hljs-keyword">int</span> label;<br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object result)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.result = (Result) result;<br>            <span class="hljs-keyword">return</span> main(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;;<br>  <br>    <span class="hljs-keyword">if</span> (label == <span class="hljs-number">0</span>) &#123;<br>        continuation.label = <span class="hljs-number">1</span>;<br>        requestUserToken(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> SafeContinuation&lt;String&gt;(continuation) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object result)</span> </span>&#123;<br>                <span class="hljs-keyword">super</span>.resumeWith(result);<br>                <span class="hljs-comment">// continuation.invokeSuspend(result)</span><br><br>                <span class="hljs-keyword">if</span> (label == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">int</span> token = result.value;<br><br>                    System.out.println(<span class="hljs-string">&quot;user token is : &quot;</span> + token);<br><br>                    label = <span class="hljs-number">2</span>;<br>  <br>                    fetchUserInfo(token, <span class="hljs-keyword">new</span> SafeContinuation&lt;UserInfo&gt;(continuation) &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object result)</span> </span>&#123;<br>                            <span class="hljs-keyword">super</span>.resumeWith(result);<br><br>                            <span class="hljs-keyword">if</span> (label == <span class="hljs-number">2</span>) &#123;<br>                                Userinfo userinfo = result.value;<br>                                System.out.println(<span class="hljs-string">&quot;user info is : &quot;</span> + userInfo);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到整个协程的执行实际与我们平时写的回调方式其实是大同小异的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们可以总结一下 Kotlin 协程为何可以解决回调地狱了，主要基于以下几点：</p><ol><li>整个协程是采用了一种<strong>状态机（State Machine）模式</strong>，协程体中所有代码被编译到状态机中，由一个状态变量 label 来判断状态机此时的状态。</li><li>挂起函数在编译后会有一个隐藏的 Continuation 类型参数，它对应我们平时写的 Callback。这个参数中保存了状态变量以及每次执行挂起恢复的结果，当状态机发生状态流转时需要将此参数传递进去。</li><li>每次挂起函数想要恢复协程的执行都需要重新执行状态机，通过更新 label 的值来进行状态机的状态转移，继而能够执行不同的代码块获取执行结果。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin协程核心库1.4.3<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kotlinlang.org/">Kotlin语言官方站</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bytecode</tag>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（六）——从字节码来看Lambda、泛型与协程</title>
    <link href="/2021/04/25/d39e151e/"/>
    <url>/2021/04/25/d39e151e/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章熟悉了字节码的基础指令之后，一些以往难懂的、被编译器隐藏的“黑盒子”知识点就可以尝试通过字节码去分析了。下面尝试分析 Java 8 中 Lambda 表达式与 Kotlin 中 Lambda 表达式的区别、Java 和 Kotlin 中的泛型来加深对 Java 、Kotlin 语言的理解。</p><h2 id="Lambda表达式原理"><a href="#Lambda表达式原理" class="headerlink" title="Lambda表达式原理"></a>Lambda表达式原理</h2><p>Java 在 1.8 版本中引用了一个重要特性——Lambda表达式。该特性允许我们将符合 <strong>SAM（Single Abstract Method）</strong>格式的接口转换为更优雅的 Lambda 表达式，同时也支持在代码中直接使用 Lambda 表达式来替代以往的 SAM 接口。</p><p>同样的，Kotlin在创作时就明确了会支持<strong>函数式编程（Functional Programming）</strong>，同时也对 Lambda 表达式的支持更加灵活，下面就来对比一下这两种语言中对于 Lambda 表达式的实现有何异同。</p><h3 id="Java-中的-Lambda"><a href="#Java-中的-Lambda" class="headerlink" title="Java 中的 Lambda"></a>Java 中的 Lambda</h3><p>Java 8 中只允许将 SAM 接口转换为 Lambda 表达式，例如 Runnable：</p><p><img src="/img/jvm/image-20210426205953036.png" alt="SAM转换为Lambda"></p><p>对于左边的情况相信大家已经熟悉了，javac 会将匿名内部类编译为一个单独的class文件，并且名字也是由规律的：<strong>OuterClassName$n</strong>。例如该例中会生成一个名为 JavaLambda$1.class 的文件。</p><p>而右边采用了JDK 8 中的新特性 Lambda 表达式，直觉告诉我们跟匿名内部类肯定不会是一回事。观察字节码实际上生成了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>       0: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;<br>       <span class="hljs-number">5</span>: astore_1<br>       <span class="hljs-number">6</span>: aload_1<br>       7: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V<br>      <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>                <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>  descriptor: ()V<br>  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: ldc           #5                  // String 123<br>       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>在上一章详细讨论了 invokedynamic 指令，来看看常量池第 2 项：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Constant pool:<br>   #1 = Methodref          #8.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = InvokeDynamic      #0:#30         // #0:run:()Ljava/lang/Runnable;<br>   ··· ···<br>   #30 = NameAndType        #42:#43        // run:()Ljava/lang/Runnable;<br></code></pre></td></tr></table></figure><p>#0是一个特殊查找，指向 BootstrapMethods 中第0行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">BootstrapMethods:<br>  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;<br>    Method arguments:<br>      #28 ()V<br>      #29 invokestatic JavaLambda.lambda$main$0:()V<br>      #28 ()V<br></code></pre></td></tr></table></figure><p>可以看到这是对静态方法 LambdaMetaFactory.metafactory() 的调用，这个类定义在 rt.jar 包中，方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">metafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   String invokedName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType invokedType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType samMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodHandle implMethod,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType instantiatedMethodType)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> LambdaConversionException </span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>caller：MethodHandles.Lookup对象，即 JVM 提供的查找上下文。</li><li>invokedName：调用函数名，本例中为“run”。</li><li>samMethodType：SAM 函数方法签名，本例中为“()void”。</li><li>implMethod：SAM 函数的具体实现方法，即我们编写在 lambda 表达式中，本例中为 invokestatic JavaLambda.lambda$main$0:()V。</li><li>instantiatedMethodType：一般和 samMethodType 相同，或是特例，本例中为“()void”。</li></ul><p>metafactory 方法是整个 Lambda 表达式实现最核心和最复杂的地方。它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">mf = <span class="hljs-keyword">new</span> InnerClassLambdaMetafactory(caller, invokedType,<br>                                     invokedName, samMethodType,<br>                                     implMethod, instantiatedMethodType,<br>                                     <span class="hljs-keyword">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);<br>mf.validateMetafactoryArgs();<br><span class="hljs-keyword">return</span> mf.buildCallSite();<br></code></pre></td></tr></table></figure><p>InnerClassLambdaMetafactory 中使用 ASM 技术动态生成字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClassLambdaMetafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType invokedType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   String samMethodName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType samMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodHandle implMethod,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType instantiatedMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-keyword">boolean</span> isSerializable,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   Class&lt;?&gt;[] markerInterfaces,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType[] additionalBridges)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> LambdaConversionException </span>&#123;<br>    <span class="hljs-keyword">super</span>(caller, invokedType, samMethodName, samMethodType,<br>          implMethod, instantiatedMethodType,<br>          isSerializable, markerInterfaces, additionalBridges);<br>    implMethodClassName = implDefiningClass.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    implMethodName = implInfo.getName();<br>    implMethodDesc = implMethodType.toMethodDescriptorString();<br>    implMethodReturnClass = (implKind == MethodHandleInfo.REF_newInvokeSpecial)<br>            ? implDefiningClass<br>            : implMethodType.returnType();<br>    <span class="hljs-comment">// 返回值类型</span><br>    constructorType = invokedType.changeReturnType(Void.TYPE);<br>    <span class="hljs-comment">// 生成类的类名</span><br>    lambdaClassName = targetClass.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&quot;$$Lambda$&quot;</span> + counter.incrementAndGet();<br>    cw = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);<br>    <span class="hljs-keyword">int</span> parameterCount = invokedType.parameterCount();<br>    <span class="hljs-keyword">if</span> (parameterCount &gt; <span class="hljs-number">0</span>) &#123;<br>        argNames = <span class="hljs-keyword">new</span> String[parameterCount];<br>        argDescs = <span class="hljs-keyword">new</span> String[parameterCount];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterCount; i++) &#123;<br>            argNames[i] = <span class="hljs-string">&quot;arg$&quot;</span> + (i + <span class="hljs-number">1</span>);<br>            argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argNames = argDescs = EMPTY_STRING_ARRAY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可看到这里将生成类的类名定为：<strong>OuterClassName$$Lambda$n</strong> ，具体生成类的实现我们可以通过 java -Djdk.internal.lambda.dumpProxyClasses JavaLambda 来运行 JavaLambda 类，会发现其在运行期间生成了一个新的类，将其反编译后会发现其实现了 Runnable 接口，并且实现了run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaLambda</span>$$<span class="hljs-title">Lambda</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Runnable</span></span><br><span class="hljs-class">  </span><br><span class="hljs-class">  <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">run</span>()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">0</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: invokestatic  #17                 // Method JavaLambda.lambda$main$0:()V<br>         <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>run 方法中调用了 JavaLambda.lambda$main$0 方法，从而执行了我们定义在Lambda表达式中的逻辑。</p><p>总结一下 Java 中的 Lambda表达式：</p><ol><li>Lambda 表达式声明的地方会生成一个 invokedynamic 指令，同时编译器生成一个对应的引导方法（Bootstrap Method）。</li><li>第一次执行 invokedynamic 指令时，会调用对应的引导方法，该引导方法会调用 LambdaMetafactory.metafactory 方法动态生成内部类。</li><li>引导方法会返回一个动态调用 CallSite 对象，这个CallSite 最终调用实现了 Runnable接口的内部类。</li><li>Lambda 表达式中的代码会被编译成静态方法，动态生成的内部类会直接调用该静态方法。</li><li>真正执行 lambda 调用的还是 invokeinterface 指令。</li></ol><h3 id="Kotlin-中的-Lambda"><a href="#Kotlin-中的-Lambda" class="headerlink" title="Kotlin 中的 Lambda"></a><strong>Kotlin 中的 Lambda</strong></h3><p>Kotlin 中的 Lambda 表达式就比 Java 8 中的要强大得多了，几乎可以在任何地方使用 Lambda 表达式，下面同样来看一例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> sum = &#123; a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span> -&gt;<br>        a + b<br>    &#125;<br>    println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 javac 编译后生成了两个文件：</p><p><img src="/img/jvm/image-20210426221656230.png" alt="KotlinLambda"></p><p>根据命名猜测到正是 Lambda 表达式生成的内部类，其命名规律为：<strong>OuterClassName$OuterFunctionName$LambdaExpressionName$n</strong>。先将其反编译，发现这个内部类继承自 kotlin.jvm.internal.Lambda，并且实现了 kotlin.jvm.functions.Function2 接口。</p><p>kotlin.jvm.internal.Lambda 类是 Kotlin 中所有 Lambda 表达式的抽象父类，其实现很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span>&lt;<span class="hljs-type">out R</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> arity: <span class="hljs-built_in">Int</span>) : FunctionBase&lt;R&gt;, Serializable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = Reflection.renderLambdaToString(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>熟悉 Kotlin 的话就知道 FunctionN 这类接口是 Kotlin 用于实现函数式编程而表示函数类型的接口，其签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function2</span>&lt;<span class="hljs-type">in P1, in P2, out R</span>&gt; : <span class="hljs-type">Function</span>&lt;<span class="hljs-type">R</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/** Invokes the function with the specified arguments. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(p1: <span class="hljs-type">P1</span>, p2: <span class="hljs-type">P2</span>)</span></span>: R<br>&#125;<br></code></pre></td></tr></table></figure><p>知道了这个内部类是 Function2 类型的话，那么具体实现只需要看 invoke 函数就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(java.lang.Object, java.lang.Object)</span></span>;<br>  descriptor: (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;<br>  flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: aload_1<br>       2: checkcast     #11                 // class java/lang/Number<br>       5: invokevirtual #15                 // Method java/lang/Number.intValue:()I<br>       <span class="hljs-number">8</span>: aload_2<br>       9: checkcast     #11                 // class java/lang/Number<br>      12: invokevirtual #15                 // Method java/lang/Number.intValue:()I<br>      15: invokevirtual #18                 // Method invoke:(II)I<br>      18: invokestatic  #24                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-number">21</span>: areturn<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br>  descriptor: (II)I<br>  flags: ACC_PUBLIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>       <span class="hljs-number">0</span>: iload_1<br>       <span class="hljs-number">1</span>: iload_2<br>       <span class="hljs-number">2</span>: iadd<br>       <span class="hljs-number">3</span>: ireturn<br></code></pre></td></tr></table></figure><p>可以看到这两个 invoke 方法就是我们的 Lambda 表达式内部的内容了，将两个整型相加。那么是如何调用的呢，回过头来看 KotlinLambdaKt.class 的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>       0: getstatic     #15                 // Field KotlinLambdaKt$main$sum$1.INSTANCE:LKotlinLambdaKt$main$sum$1;<br>       3: checkcast     #17                 // class kotlin/jvm/functions/Function2<br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: iconst_1<br>       9: invokestatic  #23                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-number">12</span>: iconst_2<br>      13: invokestatic  #23                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      16: invokeinterface #27,  3           // InterfaceMethod kotlin/jvm/functions/Function2.invoke:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;<br>      21: checkcast     #29                 // class java/lang/Number<br>      24: invokevirtual #33                 // Method java/lang/Number.intValue:()I<br>      <span class="hljs-number">27</span>: istore_1<br>      <span class="hljs-number">28</span>: iconst_0<br>      <span class="hljs-number">29</span>: istore_2<br>      30: getstatic     #39                 // Field java/lang/System.out:Ljava/io/PrintStream;<br>      <span class="hljs-number">33</span>: iload_1<br>      34: invokevirtual #45                 // Method java/io/PrintStream.println:(I)V<br>      <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>main 方法首先获取了 KotlinLambdaKt$main$sum$1 的静态单例，接着同样使用 invokeinterface 指令来执行接口 Function2中的 invoke 方法，执行 Lambda 表达式内部的操作。</p><p>可以看到 Kotlin 的 Lambda 表达式实现还是比较简单的，它采用了内部类的方式来代理 Lambda 表达式的内容，而 Java 8 则是利用了 invokedynamic 指令，通过 LambdaMetaFactory 来处理，这样做的好处是整个调用流程通过 LambdaMetaFactory 来完成，整个方法分派的流程从编译器转移到了运行时，后续只需调整 LambdaMetaFactory 里面的代码即可改变现有实现。</p><h2 id="泛型与字节码"><a href="#泛型与字节码" class="headerlink" title="泛型与字节码"></a>泛型与字节码</h2><h3 id="Java-中的泛型"><a href="#Java-中的泛型" class="headerlink" title="Java 中的泛型"></a>Java 中的泛型</h3><p>Java 在 JDK 1.5 时引入了<strong>泛型（Generic Type）</strong>的概念，泛型存在使得我们可以更好的使用集合框架，避免了很多强制的类型转换，并且将很多错误暴露在了编译阶段。不过老鸟都知道 Java 为了兼容 1.5 之前的 JDK 版本，并没有真正引入泛型类型，而是采用一种叫<strong>类型擦除</strong>的机制，在编译时将泛型相关的全部擦除为基本类型。例如 List&lt;String&gt; 编译后会被擦除为 List 类型，这也导致了一些问题，例如无法使用泛型类型来做方法重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;Integer&gt; list)</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>当这样编写代码时会编译报错，提示 ”’print(List&lt;String&gt;)’ clashes with ‘print(List&lt;Integer&gt;)’; both methods have same erasure“，因为两个方法编译后的字节码是一模一样的。</p><p>除此之外，泛型还有无法实例化、无法判断泛型类型等缺点，如下面代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">genericMethod</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-comment">// 无法创建对象</span><br>    T newInstance = <span class="hljs-keyword">new</span> T();<br>    <span class="hljs-comment">// 无法创建数组类型</span><br>    T[] array = <span class="hljs-keyword">new</span> T[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 无法获得Class对象</span><br>    Class c = T.class;<br>    List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 无法使用instanceof判断类型</span><br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过如果没有泛型的话，我们操作集合类就比较麻烦了，例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List strings = <span class="hljs-keyword">new</span> ArrayList();<br>strings.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>String value = (String) strings.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>每次从 strings 中获取元素都需要显式的强转为 String 类型才能正常使用，如果使用泛型的话就不需要了，不过虚拟机还是会帮我们进行类型的转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>strings.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>String value = strings.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 字节码中依然需要强转</span><br>INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object; (itf)<br>CHECKCAST java/lang/String<br></code></pre></td></tr></table></figure><h3 id="字节码中留存的泛型信息"><a href="#字节码中留存的泛型信息" class="headerlink" title="字节码中留存的泛型信息"></a>字节码中留存的泛型信息</h3><p>Javac 虽然会在编译时将所有泛型类型擦除，但是它依然在字节码中保留了一些关于泛型的信息，以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Map&lt;String, Integer&gt;&gt; getValue() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 javap 查看 SubClass 的字节码，发现 getValue 方法相比普通无泛型方法多了一条 Signature 信息，而 Signature 中指向的常量池信息刚好是我们的泛型实际类型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.util.List&lt;java.util.Map&lt;java.lang.String, java.lang.Integer&gt;&gt; getValue();<br>  descriptor: ()Ljava/util/List;<br>  flags: ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aconst_null<br>       <span class="hljs-number">1</span>: areturn<br>    LineNumberTable:<br>      line <span class="hljs-number">11</span>: <span class="hljs-number">0</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/sukaidev/fuckingaosp/SubClass;<br>  Signature: #14                          // ()Ljava/util/List&lt;Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/Integer;&gt;;&gt;;<br></code></pre></td></tr></table></figure><p>Signature 指向常量池14号表项，值为  ()Ljava/util/List&lt;Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/Integer;&gt;;&gt;;。同样的，整个 Class 文件也存在一个 Signature：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Signature: #15                          // Lcom/sukaidev/fuckingaosp/SuperClass&lt;Ljava/lang/String;&gt;;<br></code></pre></td></tr></table></figure><p>指向了常量池15号表项，内容为带泛型的父类实际类型。</p><p>现在我们知道字节码中通过附加的签名信息保留的泛型的实际类型，那么在运行时去获取泛型的实际类型就存在理论上的可能了。不过有一点要注意的是，签名可能会被混淆，注意keep住：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-keepattributes Signature<br>-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">Metadata</span> </span>&#123;*;&#125;<br></code></pre></td></tr></table></figure><h3 id="运行时获取泛型实际类型"><a href="#运行时获取泛型实际类型" class="headerlink" title="运行时获取泛型实际类型"></a>运行时获取泛型实际类型</h3><blockquote><p>注意！！！：以下分析是基于 Android SDK 30，源码可能会与主流 JDK（Oracle JDK、OpenJDK等）中有所出入，例如 Class 类中获取泛型签名的方法名就不同，不过原理是一样的。</p></blockquote><p>如果经常使用 Gson 来作为序列化/反序列化 Json 工具的话，一定经常使用这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Type type = <span class="hljs-keyword">new</span> TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType();<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> Gson().fromJson(json, type);<br></code></pre></td></tr></table></figure><p>Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。如果将 type 打印的话，会发现它是我们传入 TypeToken 中的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.List&lt;? extends java.lang.String&gt;<br></code></pre></td></tr></table></figure><p>那么为何通过 TypeToken 可以拿到这个泛型类型呢？看看 TypeToken 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">TypeToken</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 获取超类泛型实际类型</span><br>  <span class="hljs-keyword">this</span>.type = getSuperclassTypeParameter(getClass());<br>  <span class="hljs-keyword">this</span>.rawType = (Class&lt;? <span class="hljs-keyword">super</span> T&gt;) $Gson$Types.getRawType(type);<br>  <span class="hljs-keyword">this</span>.hashCode = type.hashCode();<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeToken 通过 getSuperclassTypeParameter 方法来获取父类的泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> Type <span class="hljs-title">getSuperclassTypeParameter</span><span class="hljs-params">(Class&lt;?&gt; subclass)</span> </span>&#123;<br>  <span class="hljs-comment">// 获取父类泛型类型</span><br>  Type superclass = subclass.getGenericSuperclass();<br>  <span class="hljs-keyword">if</span> (superclass <span class="hljs-keyword">instanceof</span> Class) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing type parameter.&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 强转为参数化类型，即泛型</span><br>  ParameterizedType parameterized = (ParameterizedType) superclass;<br>  <span class="hljs-comment">// 返回第一个泛型实际类型</span><br>  <span class="hljs-keyword">return</span> $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在 getGenericSuperclass 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getGenericSuperclass</span><span class="hljs-params">()</span> </span>&#123;<br>  Type genericSuperclass = getSuperclass();<br>  <span class="hljs-comment">// 没有父类的话直接返回null，例如基本类型，接口，void，和Object</span><br>  <span class="hljs-keyword">if</span> (genericSuperclass == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// getSignatureAttribute是个native方法，用于获取泛型签名</span><br>  String annotationSignature = getSignatureAttribute();<br>  <span class="hljs-keyword">if</span> (annotationSignature != <span class="hljs-keyword">null</span>) &#123;<br>      GenericSignatureParser parser = <span class="hljs-keyword">new</span> GenericSignatureParser(getClassLoader());<br>      parser.parseForClass(<span class="hljs-keyword">this</span>, annotationSignature);<br>      genericSuperclass = parser.superclassType;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Types.getType(genericSuperclass);<br>&#125;<br></code></pre></td></tr></table></figure><p>getSignatureAttribute 是个 Native 方法最终通过 GenericSignatureParser 解析泛型签名而得到我们传给父类的泛型实际类型。</p><p>我们可以总结一下如何获取父类的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ParameterizedType genericType = (ParameterizedType) SubClass.class.getGenericSuperclass();<br>System.out.println(genericType.getActualTypeArguments()[<span class="hljs-number">0</span>].getTypeName());<br><br><span class="hljs-comment">// 控制台输出</span><br>java.lang.String<br></code></pre></td></tr></table></figure><p>同样我们也可以获取方法中的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ParameterizedType methodType = (ParameterizedType) SubClass.class.getMethod(<span class="hljs-string">&quot;getValue&quot;</span>).getGenericReturnType();<br>    System.out.println(methodType.getActualTypeArguments()[<span class="hljs-number">0</span>].getTypeName());<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>java.util.Map&lt;java.lang.String, java.lang.Integer&gt;<br></code></pre></td></tr></table></figure><h3 id="Kotlin-中的泛型特化"><a href="#Kotlin-中的泛型特化" class="headerlink" title="Kotlin 中的泛型特化"></a>Kotlin 中的泛型特化</h3><p>Kotlin 作为一种 JVM 语言，其泛型同样会进行类型擦除。不过 Kotlin 中提供了一个关键字：<strong>reified</strong>，在内联函数中使用该关键字可以实现 Java 中实现不了的效果，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reifiedGeneric(<span class="hljs-string">&quot;hello kotlin.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">reifiedGeneric</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 可以获取Class对象，反射创建对象</span><br>    <span class="hljs-keyword">val</span> newInstance = T::<span class="hljs-keyword">class</span>.java.newInstance()<br>    <span class="hljs-comment">// 可以创建数组</span><br>    <span class="hljs-keyword">val</span> arrayOfT = arrayOf&lt;T&gt;()<br>    <span class="hljs-keyword">val</span> list = ArrayList&lt;T&gt;()<br>    <span class="hljs-comment">// 依然无法使用instanceof判断类型，编译报红</span><br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">is</span> List&lt;String&gt;)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后 main 方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">0</span><br>       0: ldc           #11                 // String hello kotlin.<br>       <span class="hljs-number">2</span>: astore_0<br>       <span class="hljs-number">3</span>: iconst_0<br>       <span class="hljs-number">4</span>: istore_1<br>       5: ldc           #13                 // class java/lang/String<br>       7: invokevirtual #19                 // Method java/lang/Class.newInstance:()Ljava/lang/Object;<br>      <span class="hljs-number">10</span>: astore_2<br>      <span class="hljs-number">11</span>: iconst_0<br>      12: anewarray     #13                 // class java/lang/String<br>      <span class="hljs-number">15</span>: astore_3<br>      <span class="hljs-number">16</span>: nop<br>      <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>原本 main 方法应该直接调用 reifiedGeneric 方法才对，但实际上编译后 reifiedGeneric 方法中的代码完全被编译进了 main 方法内，这其实就是 <strong>inline（内联）</strong>的含义。</p><p>内联方法通过 kotlinc 编译器内联到调用处，其字节码完全合并到调用处中，这也是 kotlin 泛型特化能够实现的原因。内联函数的泛型在编译期编译器就可以通过上下文推导出其实际类型，因此可以获取其 Class 对象，也能进行实例化。</p><h2 id="协程原理"><a href="#协程原理" class="headerlink" title="协程原理"></a>协程原理</h2><p>此部分较为复杂，已发布文章<a href="/2021/05/06/40879c1f/">《深入理解Kotlin协程（六）——从字节码角度理解协程》</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kotlinlang.org/">Kotlin语言官方站</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bytecode</tag>
      
      <tag>Generic</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（五）——字节码基础</title>
    <link href="/2021/04/18/b6905ec7/"/>
    <url>/2021/04/18/b6905ec7/</url>
    
    <content type="html"><![CDATA[<p>上篇文章中了解了虚拟机执行子系统中的栈和栈帧结构，并且学习了一些方法调用相关的字节码指令，对于方法的分派过程有了更深入的理解，接下来这篇文章来了解一下基础的字节码指令。</p><h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>字节码指令主要有<strong>加载和存储指令</strong>、<strong>操作数栈指令</strong>、<strong>运算和类型转换指令</strong>、<strong>控制转移指令</strong>等，这一部分是了解字节码的基础。</p><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p><strong>加载（load）</strong>和<strong>存储（store）</strong>相关的指令是使用得最频繁的指令，分为load类、store类、常量加载这三种。</p><ul><li>load类指令：将局部变量表中的变量加载到操作数栈，比如iload_0将局部变量表中下表为0的int型变量加载到操作数栈上，类似的还有lload、fload、dload、aload，分别表示加载局部变量表中long、float、double、引用类型的变量。</li><li>store类指令：将操作数栈栈顶的数据存储到局部变量表中，比如istore_0将操作数栈顶的元素存储到局部变量表中下表为0的位置，类似的还有lstore、fstore、dstore、astore这些指令。</li><li>常量加载相关的指令，常见的有const类、push类、ldc类。const、push类指令是将常数值直接加载到操作数栈顶，ldc指令是从常量池加载对应的常量到操作数栈顶。</li></ul><p>存储指令列表如下所示。</p><table><thead><tr><th align="center">指  令  名</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">aconst_null</td><td align="center">将null入栈到栈顶</td></tr><tr><td align="center">iconst_m1</td><td align="center">将int类型值-1压栈到栈顶</td></tr><tr><td align="center">iconst_&lt;n&gt;</td><td align="center">将int类型值n（0~5）压栈到栈顶</td></tr><tr><td align="center">lconst_&lt;n&gt;</td><td align="center">将long类型值n（0~1）压栈到栈顶</td></tr><tr><td align="center">fconst_&lt;n&gt;</td><td align="center">将float类型值n（0~2）压栈到栈顶</td></tr><tr><td align="center">dconst&lt;n&gt;</td><td align="center">将double类型值n（0~1）压栈到栈顶</td></tr><tr><td align="center">bipush</td><td align="center">将范围在-128~127的整型值压栈到栈顶</td></tr><tr><td align="center">sipush</td><td align="center">将范围在-32768~32767的整型值压栈到栈顶</td></tr><tr><td align="center">ldc</td><td align="center">将int、float、String类型的常量值从常量池压栈到栈顶</td></tr><tr><td align="center">ldc_w</td><td align="center">作用同ldc，不同的是ldc的操作码是一个字节，ldc_w的操作码是两个字节，即ldc只能寻址255个常量池的索引值，而ldc_w可以覆盖常量池所有的值</td></tr><tr><td align="center">ldc2_w</td><td align="center">将long或double类型的常量值从常量池压栈到栈顶</td></tr><tr><td align="center">&lt;T&gt;load</td><td align="center">将局部变量表中指定位置的int、long、float、double、引用类型、boolean、byte、char、short类型变量加载到栈上</td></tr><tr><td align="center">&lt;T&gt;load_&lt;n&gt;</td><td align="center">将局部变量表中下标为n（0~3）的变量加载到栈上，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;aload</td><td align="center">将指定数组中特定位置的数据加载到栈上，T可以为i、l、f、d、a、b、c、s</td></tr><tr><td align="center">&lt;T&gt;store</td><td align="center">将栈顶数据存储到局部变量表中的特定位置，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;store_&lt;n&gt;</td><td align="center">将栈顶变量数据存储到局部变量表中下标为n（0~3）的位置，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;astore</td><td align="center">将栈顶数据存储到数组的指定位置，T可以为i、l、f、d、a、b、c、s</td></tr></tbody></table><h3 id="操作数栈指令"><a href="#操作数栈指令" class="headerlink" title="操作数栈指令"></a>操作数栈指令</h3><p>常见的操作数栈指令有pop、dup和swap。pop指令用于将栈顶的值出栈，dup指令用来复制栈顶的元素并压入栈顶，swap用于交换栈顶的两个元素，如下图所示。</p><p><img src="/img/jvm/dup_pop_swap.png" alt="dup、pop、swap指令"></p><p>另外还有几个复杂一点的指令，如下操作数栈指令列表所示。</p><table><thead><tr><th align="center">指 令 名</th><th align="center">字 节 码</th><th align="center">描 述</th></tr></thead><tbody><tr><td align="center">pop</td><td align="center">0x57</td><td align="center">将栈顶数据（非long和double）出栈</td></tr><tr><td align="center">pop2</td><td align="center">0x58</td><td align="center">弹出栈顶一个long或double类型的数据或者两个其他类型的数据</td></tr><tr><td align="center">dup</td><td align="center">0x59</td><td align="center">复制栈顶数据并将复制的数据入栈</td></tr><tr><td align="center">dup_x1</td><td align="center">0x5A</td><td align="center">复制栈顶数据并将复制的数据插入到栈顶第二个元素之下</td></tr><tr><td align="center">dup_x2</td><td align="center">0x5B</td><td align="center">复制栈顶数据并将复制的数据插入到栈顶第三个元素之下</td></tr><tr><td align="center">dup2</td><td align="center">0x5C</td><td align="center">复制栈顶两个数据并将复制的数据入栈</td></tr><tr><td align="center">dup2_x1</td><td align="center">0x5D</td><td align="center">复制栈顶两个数据并将复制的数据插入到栈第二个元素之下</td></tr><tr><td align="center">dup2_x2</td><td align="center">0x5E</td><td align="center">复制栈顶两个数据并将复制的数据插入到栈第三个元素之下</td></tr><tr><td align="center">swap</td><td align="center">0x5F</td><td align="center">交换栈顶两个元素</td></tr></tbody></table><h3 id="运算和类型转换指令"><a href="#运算和类型转换指令" class="headerlink" title="运算和类型转换指令"></a>运算和类型转换指令</h3><p>针对Java中的加减乘除相关语法，字节码也有对应的运算指令，如下表示所示。</p><table><thead><tr><th align="center">运算符</th><th align="center">int</th><th align="center">long</th><th align="center">float</th><th align="center">double</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">iadd</td><td align="center">ladd</td><td align="center">fadd</td><td align="center">dadd</td></tr><tr><td align="center">-</td><td align="center">isub</td><td align="center">lsub</td><td align="center">fsub</td><td align="center">dsub</td></tr><tr><td align="center">/</td><td align="center">idiv</td><td align="center">ldiv</td><td align="center">fdiv</td><td align="center">ddiv</td></tr><tr><td align="center">*</td><td align="center">imul</td><td align="center">lmul</td><td align="center">fmul</td><td align="center">dmul</td></tr><tr><td align="center">%</td><td align="center">irem</td><td align="center">lrem</td><td align="center">frem</td><td align="center">drem</td></tr><tr><td align="center">negate(-)</td><td align="center">ineg</td><td align="center">lneg</td><td align="center">fneg</td><td align="center">dneg</td></tr><tr><td align="center">&amp;</td><td align="center">iand</td><td align="center">land</td><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">|</td><td align="center">ior</td><td align="center">lor</td><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">^</td><td align="center">ixor</td><td align="center">lxor</td><td align="center">–</td><td align="center">–</td></tr></tbody></table><p>这里需要注意的是，如果需要进行运算的数据类型不一样，会涉及到类型转换（cast），例如1.0 + 1 对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">fconst_1 <span class="hljs-comment">// 将1.0入栈</span><br>iconst_1 <span class="hljs-comment">// 将1入栈</span><br>fadd  <span class="hljs-comment">// 栈顶两个元素相加</span><br></code></pre></td></tr></table></figure><p>这里fadd指令只支持对两个float类型的数据做相加操作，为了支持这种运算，JVM会先把int类型的数据转为float类型然后再相加，这种类型转换称为<strong>宽化类型转换（widening）</strong>。</p><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>控制转移指令用于有条件和无条件的分支跳转，常见的if-then-else、三目表达式、for循环、异常处理等都属于这个范畴。对应的指令集包括：</p><ul><li>条件转移：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。</li><li>复合条件转移：tableswitch、lookupswitch。</li><li>无条件转移：goto、goto_w、jsr、jsr_w、ret。</li></ul><p>以下面代码为例来分析字节码，它的作用是判断一个整数是否为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iload_1  <span class="hljs-comment">// 将局部变量表中下标为1的int变量加载到操作数栈上</span><br><span class="hljs-number">1</span>: ifle <span class="hljs-number">6</span>   <span class="hljs-comment">// 将操作数栈顶元素出栈与0比较，如果小于等于0则跳转到字节码第六行</span><br><span class="hljs-number">4</span>: iconst_1 <span class="hljs-comment">// 4~5行对应代码”return 1“，这里先将常量1压到栈顶</span><br><span class="hljs-number">5</span>: ireturn  <span class="hljs-comment">// 将栈顶整数1出栈并返回</span><br><span class="hljs-number">6</span>: iconst_0  <span class="hljs-comment">// 将常量0压入栈顶</span><br><span class="hljs-number">7</span>: ireturn  <span class="hljs-comment">// 将栈顶整数0出栈返回</span><br></code></pre></td></tr></table></figure><p>假设n等于20，调用isPositive(20)方法操作数栈的变化情况如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_ispositive.png" alt="isPositive(/img/jvm/jvm_bytecode_ispositive.png)操作数栈变化">所所有控制转移指令如下表所示。</p><table><thead><tr><th align="center">指 令 名</th><th align="center">字 节 码</th><th align="center">描 述</th></tr></thead><tbody><tr><td align="center">ifeq</td><td align="center">0x99</td><td align="center">如果栈顶int型变量等于0，则跳转</td></tr><tr><td align="center">ifne</td><td align="center">0x9A</td><td align="center">如果栈顶int型变量不等于0，则跳转</td></tr><tr><td align="center">iflt</td><td align="center">0x9B</td><td align="center">如果栈顶int型变量小于0，则跳转</td></tr><tr><td align="center">ifge</td><td align="center">0x9C</td><td align="center">如果栈顶int型变量大于等于0，则跳转</td></tr><tr><td align="center">ifgt</td><td align="center">0x9D</td><td align="center">如果栈顶int型变量大于0，则跳转</td></tr><tr><td align="center">ifle</td><td align="center">0x9E</td><td align="center">如果栈顶int型变量小于等于0，则跳转</td></tr><tr><td align="center">if_icmpeq</td><td align="center">0x9F</td><td align="center">比较栈顶两个int型变量，如果相等则跳转</td></tr><tr><td align="center">if_icmpne</td><td align="center">0xA0</td><td align="center">比较栈顶两个int型变量，如果不相等则跳转</td></tr><tr><td align="center">if_icmplt</td><td align="center">0xA1</td><td align="center">比较栈顶两个int型变量，如果小于则跳转</td></tr><tr><td align="center">if_icmpge</td><td align="center">0xA2</td><td align="center">比较栈顶两个int型变量，如果大于等于则跳转</td></tr><tr><td align="center">if_icmpgt</td><td align="center">0xA3</td><td align="center">比较栈顶两个int型变量，如果大于则跳转</td></tr><tr><td align="center">if_icmple</td><td align="center">0xA4</td><td align="center">比较栈顶两个int型变量，如果小于等于则跳转</td></tr><tr><td align="center">if_acmpeq</td><td align="center">0xA5</td><td align="center">比较栈顶两个引用类型变量，如果相等则跳转</td></tr><tr><td align="center">if_acmpne</td><td align="center">0xA6</td><td align="center">比较栈顶两个引用类型变量，如果不相等则跳转</td></tr><tr><td align="center">goto</td><td align="center">0xA7</td><td align="center">无条件跳转</td></tr><tr><td align="center">tableswitch</td><td align="center">0xAA</td><td align="center">switch条件跳转，case值紧凑的情况下使用</td></tr><tr><td align="center">lookupswitch</td><td align="center">0xAB</td><td align="center">switch条件跳转，case值稀疏的情况下使用</td></tr></tbody></table><h3 id="for语句的字节码原理"><a href="#for语句的字节码原理" class="headerlink" title="for语句的字节码原理"></a>for语句的字节码原理</h3><p>下面通过分析一段for循环代码来理解上述字节码指令。</p><p>纵观所有的字节码指令，并没有与for名字相关的指令，那么for循环的实现原理是怎样的呢？</p><p>以下列为例，看看JVM是如何处理高级for循环的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : numbers) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，使用 javac -p 命令编译后，通过javap -c -v -l 来查看字节码：</p><p><img src="/img/jvm/jvm_bytecode_sum.png" alt="sum方法字节码"></p><p>为了方便理解，我们可以把局部变量表画出来，如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_sum_op.png" alt="sum方法局部变量表"></p><p>下面以执行sum(new int[]{0,20,30});为例来逐行分析字节码执行过程。</p><p>第0~1行：把常量0加载到操作数栈上，随后通过istore_2指令将0出栈赋值给局部变量表中下标为2的元素，就是将sum赋值为0。此时的局部变量表和操作数栈如下图所示。</p><p><img src="/img/jvm/image-20210410104512311.png" alt="for循环执行细节（1）"></p><p>第2~9行：初始化循环控制变量，可以使用如下伪代码表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$array = numbers;<br>$len = $array.arraylength<br>$i = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>第2~3行：aload_1指令的作用是加载局部变量表中下标为1的变量（参数numbers），astore_3指令的作用是将栈顶元素存储到局部变量表下标为3的位置上，这里记为$array，如下图所示。</p><p><img src="/img/jvm/image-20210410111449022.png" alt="for循环执行细节（2）"></p><p>第4~6行：计算数据的长度，astore_3加载$array到栈顶，调用arrayLength指令获取数组长度存储到栈顶，随后调用istore 4将数组长度存储到局部变量表的第4个位置，这里记为$len，如下图所示。</p><p><img src="/img/jvm/image-20210410123456070.png" alt="for循环执行细节（3）"></p><p>第8~9行：初始化数组遍历的下标初始值。iconst_0将0加载到操作数栈上，随后istore 5将栈顶的0存储到局部变量表中的第5个位置，这个局部变量是数据变量的下表初始值，这里记为$i，如下图所示。</p><p><img src="/img/jvm/image-20210410123800666.png" alt="for循环执行细节（4）"></p><p>第11~32行是循环体执行过程。</p><p>第11~15行的作用是判断循环能否继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>: iload         <span class="hljs-number">5</span><br><span class="hljs-number">13</span>: iload         <span class="hljs-number">4</span><br><span class="hljs-number">15</span>: if_icmpge     <span class="hljs-number">35</span><br></code></pre></td></tr></table></figure><p>首先通过iload 5和iload 4加载局部变量表中下标5和4的变量到栈顶，参照上图中的局部变量表我们知道下标5和下标4的变量分别是数组下标$i和数组长度$len。</p><p>接着会调用if_icmpge进行条件判断，如果$i &gt;= $len，则直接跳转到第35行指令处，for循环结束，否则继续往下执行。过程如下图所示。</p><p><img src="/img/jvm/image-20210410141322131.png" alt="for循环执行细节（5）"></p><p>第18~22行的作用是把$array[$i]赋值给number。aload_3加载$array到栈上，iload 5加载$i到栈上，然后iaload指令把下标为$i的数组元素加载到操作数栈上，随后istore 6将栈顶元素存储到局部变量表下标为6的位置上，如下图所示。</p><p><img src="/img/jvm/image-20210410145943441.png" alt="for循环执行细节（6）"></p><p>第24~28行：iload_2 和 iload 6指令把sum和number值加载到操作数栈上，然后执行iadd指令进行整数相加，如下图所示。</p><p><img src="/img/jvm/image-20210410164045262.png" alt="for循环执行细节（7）"></p><p>第29行：”iinc 5,1“指令对执行循环后的$i加一。iinc指令比较特殊，它并不依赖于操作数栈，而是直接对局部变量进行自增，再将结果出栈存储到局部变量表，因此效率非常高。</p><p><img src="/img/jvm/image-20210410164642263.png" alt="for循环执行细节（8）"></p><p>第32行：goto 11指令无条件跳转到第11行继续进行循环条件判断。</p><p>经过上述分析，很容易发现所谓”高级”for循环翻译成字节码后实际上与普通的for循环并无差别，只是个语法糖而已。</p><h3 id="swtich-case底层实现原理"><a href="#swtich-case底层实现原理" class="headerlink" title="swtich-case底层实现原理"></a>swtich-case底层实现原理</h3><p>switch-case语法实现原理依赖于tableswitch和lookupswtich两条字节码指令。先来看下面的与其字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseNear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (i) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">101</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">104</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对应字节码</span><br><span class="hljs-number">0</span>: iload_1<br><span class="hljs-number">1</span>: tableswitch   &#123; <span class="hljs-comment">// 100 to 104</span><br>             <span class="hljs-number">100</span>: <span class="hljs-number">36</span><br>             <span class="hljs-number">101</span>: <span class="hljs-number">38</span><br>             <span class="hljs-number">102</span>: <span class="hljs-number">42</span><br>             <span class="hljs-number">103</span>: <span class="hljs-number">42</span><br>             <span class="hljs-number">104</span>: <span class="hljs-number">40</span><br>         <span class="hljs-keyword">default</span>: <span class="hljs-number">42</span><br>    &#125;<br><span class="hljs-number">36</span>: iconst_0<br><span class="hljs-number">37</span>: ireturn<br><span class="hljs-number">38</span>: iconst_1<br><span class="hljs-number">39</span>: ireturn<br><span class="hljs-number">40</span>: iconst_4<br><span class="hljs-number">41</span>: ireturn<br><span class="hljs-number">42</span>: iconst_m1<br><span class="hljs-number">43</span>: ireturn<br></code></pre></td></tr></table></figure><p>这里使用了tableswitch指令，之前说过tableswitch指令在case比较紧凑的情况下使用。这里需要特别注意的是，代码中并没有102和103两个case，字节码中却自动帮我们“补齐”了，实际上是编译器对“紧凑”case的优化：一是使用tableswitch；二是case出现断层时自动补齐为连续的值。这样的好处是由于case是连续的所以可以以O(1)的时间复杂度来进行查找。</p><p>再看一个case比较“稀疏”的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseFar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (i) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对应字节码</span><br><span class="hljs-number">0</span>: iload_1<br><span class="hljs-number">1</span>: lookupswitch  &#123; <span class="hljs-comment">// 3</span><br>               <span class="hljs-number">1</span>: <span class="hljs-number">36</span><br>              <span class="hljs-number">10</span>: <span class="hljs-number">38</span><br>             <span class="hljs-number">100</span>: <span class="hljs-number">41</span><br>         <span class="hljs-keyword">default</span>: <span class="hljs-number">44</span><br>    &#125;<br><span class="hljs-number">36</span>: iconst_1<br><span class="hljs-number">37</span>: ireturn<br><span class="hljs-number">38</span>: bipush        <span class="hljs-number">10</span><br><span class="hljs-number">40</span>: ireturn<br><span class="hljs-number">41</span>: bipush        <span class="hljs-number">100</span><br><span class="hljs-number">43</span>: ireturn<br><span class="hljs-number">44</span>: iconst_m1<br><span class="hljs-number">45</span>: ireturn<br></code></pre></td></tr></table></figure><p>可以看到这种情况case将不会被补齐，而且没有使用tableswitch而是lookupswitch字节码指令，并且case会经过排序，使得lookupswitch可以以二分查找的方式进行case的查找，时间复杂度为O(log n)。</p><h3 id="String的switch-case实现的字节码原理"><a href="#String的switch-case实现的字节码原理" class="headerlink" title="String的switch-case实现的字节码原理"></a>String的switch-case实现的字节码原理</h3><p>上面讨论的两种情况都是基于case是整形数值的情况，Java中支持在Swtich中使用String，那么这是如何实现的呢？</p><p>同样以一段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">stringSwitch</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (name) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Java&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Kotlin&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码如下图：</p><p><img src="/img/jvm/image-20210410173623801.png" alt="对String进行switch对应字节码"></p><p>这里有几个比较关键的点，第5行中调用了String#hashCode()方法，并且选择使用lookupswitch指令，判断case后跳转到对应的行数。</p><p>由于hash值相同的String也有可能是不同字符串，因此随后会调用String#equals()方法来判断是否是相等。这里使用了ifeq指令，ifeq用于判断栈顶数据是否等于0，是则跳转到对应的行数，相当于等于false时跳转。如果相等将会继续执行，使用iconst_0将常量0压入栈顶，表示匹配了case0，或者使用iconst_1将常量1压入栈顶，表示匹配了case1，随后使用istore_3存入局部变量表。</p><p>接着就是第61~96行的处理了。61行拿到刚刚存入的0或者1，通过lookupswitch来判断跳转到不同的字节码行数执行case里面的操作。</p><h3 id="i和i-的字节码源码"><a href="#i和i-的字节码源码" class="headerlink" title="++i和i++的字节码源码"></a>++i和i++的字节码源码</h3><p>在日常开发中我们通常不会使用++i和i++这两种容易让人困惑的自增方式，而使用更加清晰的i = i + 1，不过它们很容易在面试中作为陷阱题出现，例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>        i = i++;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的输出结果是什么呢？答案是0，查看 i = i++ 的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">···<br><span class="hljs-number">10</span>: iload_1<br><span class="hljs-number">11</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">14</span>: istore_1<br>···<br></code></pre></td></tr></table></figure><p>第10行：iload_1把局部变量表slot = 1的变量(i)加载到操作数栈上。</p><p>第11行：“iinc 1,1”对局部变量表slot = 1的变量(i)直接加1，但是这时候栈顶的元素没有变化，还是0.</p><p>第14行：istore_1 将栈顶元素出栈赋值给局部变量表slot = 1的变量，也就是i。此时，局部变量i又被赋值为0，前面的iinc指令对i的加一操作被覆盖。</p><p>整个过程局部变量表和操作数栈的变化如下图所示。</p><p><img src="/img/jvm/image-20210411010713498.png" alt="i = i++ 字节码执行过程"></p><p>如果把上面代码的i = i++替换成 i  = ++i，则可以正常输出打印50。替换后的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">···<br><span class="hljs-number">10</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">13</span>: iload_1<br><span class="hljs-number">14</span>: istore_1<br>···<br></code></pre></td></tr></table></figure><p>与上面i++的字节码不同的是，这里先对局部变量表中第1位变量进行了加一，然后将其加载到操作数栈，随后重新存储到局部变量表中。</p><h3 id="对象相关的字节码指令"><a href="#对象相关的字节码指令" class="headerlink" title="对象相关的字节码指令"></a>对象相关的字节码指令</h3><h4 id="1-lt-init-gt-方法"><a href="#1-lt-init-gt-方法" class="headerlink" title="1.&lt;init&gt;方法"></a>1.&lt;init&gt;方法</h4><p>&lt;init&gt;方法是对象初始化方法，类的构造方法、非静态变量的初始化、对象初始化代码块都会被编译进这个方法中。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Initializer</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 构造器方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Initializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">30</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对象初始化代码块</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Initializer</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: aload_0<br>       <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>       7: putfield      #2                  // Field a:I<br>      <span class="hljs-number">10</span>: bipush        <span class="hljs-number">20</span><br>      <span class="hljs-number">12</span>: istore_1<br>      <span class="hljs-number">13</span>: bipush        <span class="hljs-number">30</span><br>      <span class="hljs-number">15</span>: istore_1<br>      <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>Initializer()方法对应&lt;init&gt;对象初始化方法，其中5<del>7行将成员变量a赋值为10，10</del>12行将b赋值为10，13~15行将c赋值为30。可以看到，虽然我们将变量a和变量b分别放在构造方法外和构造代码块中初始化，实际上也会统一编译到&lt;init&gt;方法里面。</p><h4 id="2-new、dup、invokespecial对象创建三条指令"><a href="#2-new、dup、invokespecial对象创建三条指令" class="headerlink" title="2.new、dup、invokespecial对象创建三条指令"></a>2.new、dup、invokespecial对象创建三条指令</h4><p>Java 中通过 new 关键字来创建对象，字节码中也有一个叫 new 的指令，但两者不是一回事。以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Initializer initializer = <span class="hljs-keyword">new</span> Initializer();<br></code></pre></td></tr></table></figure><p>编译后对应字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">0: new           #3                  // class Initializer<br><span class="hljs-number">3</span>: dup<br>4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">7</span>: astore_1<br></code></pre></td></tr></table></figure><p>出去第 7 行的存储指令，new 关键字经过编译后实际上生成了 new-dup-invokespecial 3行字节码。new指令很容易理解，invokespecial 则是用于调用对象&lt;init&gt;方法来初始化对象，那么中间这个dup指令的作用是什么呢？</p><p>dup指令的含义是复制栈顶的数据并且插入到栈顶，在第0行时通过new指令创建了</p><p>Initializer的一个实例然后加入到栈顶，接着如果直接通过invokespecial调用其构造方法，由于invokespecial会消耗栈顶的类实例引用，会导致操作数栈为空，使得刚刚创建的对象丢失。因此在invokespecial调用前需使用dup复制一份实例，随后就可以通过astore_1指令将其存入局部变量表了。</p><h4 id="3-lt-clinit-gt-方法"><a href="#3-lt-clinit-gt-方法" class="headerlink" title="3.&lt;clinit&gt;方法"></a>3.&lt;clinit&gt;方法</h4><p>&lt;clinit&gt;是类的静态初始化方法，同样的，类静态初始化代码块、静态变量初始化都会被编译进这个方法中。javap输出字节码中的 static{} 表示&lt;cinit&gt;方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bytecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（四）——虚拟机执行子系统</title>
    <link href="/2021/04/10/6e2382e5/"/>
    <url>/2021/04/10/6e2382e5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java 虚拟机的指令由一个操作码（opcode）和紧随其后的可选操作数（operand）组成，占一个字节长度，故称其为“字节码（bytecode）“。</p></blockquote><h2 id="Java虚拟机栈和栈帧"><a href="#Java虚拟机栈和栈帧" class="headerlink" title="Java虚拟机栈和栈帧"></a>Java虚拟机栈和栈帧</h2><p>虚拟机常见的实现方式有两种：<strong>基于栈（Stack based）</strong>和<strong>基于寄存器（Register based）</strong>。Hotspot JVM是一种典型的基于栈的虚拟机，而Android开发者熟知的DalvikVM则是基于寄存器的虚拟机。</p><p>这两种实现方式各有优缺点：</p><ul><li>基于栈的指令集架构的优点是移植性更好、指令更短、实现简单，但是不能随机访问堆栈中的元素，完成相同功能所需的指令数一般比寄存器架构多，需要频繁的入栈出栈，不利于代码优化。</li><li>基于寄存器的指令集架构的优点是速度快，可以充分利用寄存器，有利于程序做运行速度优化，但操作数需要显式指定，指令较长。</li></ul><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，<strong>“栈帧”（Stack Frame）</strong>则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p><p>每一个栈帧中都包含了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回地址</strong>和一些额外的<strong>附加信息</strong>。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><strong>局部变量表（Local Variables Table）</strong>是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的<strong>max_locals</strong>数据项中确定了该方法所需分配的局部变量表的最大容量。</p><p>以下列代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        String temp = <span class="hljs-string">&quot;A&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用javac -p TestClass.java进行编译，然后执行javap -c -v -l TestClass查看字节码，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, java.lang.String)</span></span>;<br>  descriptor: (ILjava/lang/String;)V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">3</span><br>       0: ldc           #2                  // String A<br>       <span class="hljs-number">2</span>: astore_3<br>       <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span><br>    LineNumberTable:<br>      line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">4</span>: <span class="hljs-number">3</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   LTestClass;<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">1</span>    id   I<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>  name   Ljava/lang/String;<br>          <span class="hljs-number">3</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>  temp   Ljava/lang/String;<br></code></pre></td></tr></table></figure><p>可以看到Code属性中有<strong>stack</strong>、<strong>locals</strong>、<strong>args_size</strong>分别对应操作数栈的容量、<strong>局部变量表容量</strong>以及<strong>参数长度</strong>。<strong>LineNumberTable</strong>属性表存放方法的行号信息，<strong>LocalVariableTable</strong>属性表中存放方法的局部变量信息。</p><p>foo方法中只有两个参数，但实际args_size的大小为3，这是因为foo作为实例方法（非静态方法）被调用时，第0个局部变量实际上固定为调用这个实例方法的对象的引用，也就是我们所说的this。</p><p>局部变量表的容量以<strong>变量槽（Variable Slot）</strong>为最小单位，示例中局部变量表容量为4个slot。这里需要注意的是，局部变量表的容量并不等于实际局部变量的个数。这是因为有些局部变量占用的槽位在其作用域结束时可以被复用，例如if-else代码块中声明的变量在if-else执行完毕时占用槽位就可以被复用。另外并不是每一个变量都只会占用一个slot，例如double类型就会占用两个slot。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><strong>操作数栈（Operand Stack）</strong>也常被称为操作栈，它是一个<strong>后入先出（Last In First Out，LIFO）</strong>栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的<strong>max_stacks</strong>数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。例如iadd指令，它要求操作数栈中已经存在两个int型整数，在iadd执行时，两个int数值从操作数栈中出栈，相加求和后将结果入栈，如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_1_plus_2.png" alt="1+2指令执行过程"></p><p>整个JVM指令执行的过程实际上就是局部变量表与操作数栈之间不断加载、存储的过程。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方 调用过程中的<strong>动态连接（Dynamic Linking）</strong>。通过上面文章对于Class文件的解析，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。<strong>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</strong></p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>“正常调用完成”（Normal Method Invocation Completion）</strong>。</p><p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<strong>“异常调用完成（Abrupt Method Invocation Completion）”</strong>。</p><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li><li>… …等等</li></ul><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。<strong>在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</strong></p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>JVM中的方法调用字节码指令都以 “invoke” 开头，一共有5种。</p><ul><li>invokestatic：用于调用静态方法。</li><li>invokevirtual：用于调用非私有实例方法。</li><li>invokespecial：用于调用私有实例方法、构造器方法以及使用 super 关键字调用父类的实例方法等。</li><li>invokeinterface：用于调用接口方法。</li><li>invokedynamic：用于支撑动态类型语言，先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li></ul><p>Java 中将使用 invokestatic 调用的静态方法、使用 invokespecial 调用的私有实例方法、构造器方法和父类实例方法以及使用 invokevirtual 使用的被 final 修饰的不可覆盖方法统称为<strong>”非虚方法（Non-Virtual Method）”</strong>，与之相反，其他方法就被称为<strong>“虚方法”（Virtual Method）</strong>。</p><h3 id="invokestatic指令"><a href="#invokestatic指令" class="headerlink" title="invokestatic指令"></a>invokestatic指令</h3><p>invokestatic用来调用static关键字修饰的方法，即静态方法。静态方法在编译期就已经确定，且运行时不会修改，属于静态绑定。调用 invokestatic 不需要将对象加载到操作数栈，只需要将所需要的参数入栈就可以执行 invokestatic 指令了。</p><h3 id="invokevirtual指令"><a href="#invokevirtual指令" class="headerlink" title="invokevirtual指令"></a>invokevirtual指令</h3><p>invokevirtual 指令用于调用普通实例方法，它调用的目标方法在运行时才能根据对象实际的类型来确定，编译期无法知道，类似于 C++ 中的虚方法。</p><p>在调用 invokevirtual 指令前，需要将<strong>对象的引用</strong>和<strong>方法参数</strong>入栈，调用结束将对象引用和方法参数出栈，如果方法有返回值，返回值会入栈到栈顶。</p><h3 id="invokespecial指令"><a href="#invokespecial指令" class="headerlink" title="invokespecial指令"></a>invokespecial指令</h3><p>invokespecial 用于调用”特殊“的实例方法，包括如下三种：</p><ul><li>实例构造器方法&lt;init&gt;。</li><li>private 修饰的私有实例方法。</li><li>使用 super 关键字调用的父类方法。</li></ul><p>这三种方法的特殊之处在于，其方法调用在编译期就可以确定，所以 JVM 单独使用了 invokespecial 指令来调用者三种实例方法来提升效率。</p><h3 id="invokeinterface指令"><a href="#invokeinterface指令" class="headerlink" title="invokeinterface指令"></a>invokeinterface指令</h3><p>invokeinterface 用于调用接口方法，同 invokevirtual 一样，也是需要在运行时根据对象的类型确定目标方法，以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AutoCloseable autoCloseable;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    autoCloseable.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>foo 方法对应的字节码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> java.lang.Exception</span>;<br>  descriptor: ()V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: getfield      #17                 // Field autoCloseable:Ljava/lang/AutoCloseable;<br>       4: invokeinterface #18,  1           // InterfaceMethod java/lang/AutoCloseable.close:()V<br>       <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>可以看到这里使用了 invokeinterface 指令来调用 close 方法。</p><h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>invokedynamic 是在JDK 7上添加的一个重量级的指令，它为指令多语言在 JVM 上的实现提供了技术支撑。</p><p>invokedynamic与其他四条方法执行指令不同的是，它会先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面 4 条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。具体的细节将在下下节<strong>“动态类型语言支持”</strong>中讨论。</p><h2 id="方法分派"><a href="#方法分派" class="headerlink" title="方法分派"></a>方法分派</h2><p>Java中多态的重要表现包括方法的重载和重写，那么虚拟机是如何确定正确的目标方法的呢？这涉及到一个概念：<strong>方法分派（Method Dispatch）</strong>。</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>所有依赖静态类型来决定方法执行版本的分派动作，都称为<strong>静态分派</strong>。静态分派的最典型应用表现就是方法重载。它在编译期间由编译器来确定应该编写哪个方法的字节码，对于虚拟机来说只需要执行指定的字节码即可，并不存在“分派”行为，因此被称为“静态分派”。来看一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDispatch</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Human guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,human!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Man guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,man!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Woman guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,woman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br>        StaticDispatch dispatch = <span class="hljs-keyword">new</span> StaticDispatch();<br>        dispatch.sayHello(man);<br>        dispatch.sayHello(woman);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hello,human! <br>hello,human!<br></code></pre></td></tr></table></figure><p>实际上如果使用IDEA来编写上面的代码的话，编译器就已经提示了哪个方法被调用了：</p><p><img src="/img/jvm/image-20210416231911611.png" alt="IDEA静态分派提示"></p><p>这充分说明了对于重载方法的分派在编译期就已经确定。</p><p>对于一个对象引用的类型，我们称其为变量的“静态类型”（Static Type），例如上面代码中的 man 和 woman 的静态类型为 Human。而引用指向的具体类型称为“实际类型”（Actual Type），例如上面代码中 man 的实际类型为 Man，woman 的实际类型为 Woman。</p><p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实际类型变化</span><br>Human human = (<span class="hljs-keyword">new</span> Random()).nextBoolean() ? <span class="hljs-keyword">new</span> Man() : <span class="hljs-keyword">new</span> Woman();<br><span class="hljs-comment">// 静态类型变化 </span><br>dispatch.sayHello((Man) human) <br>dispatch.sayHello((Woman) human)<br></code></pre></td></tr></table></figure><p>对象 human 的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行代码的时候才能确定。而 human 的静态类型是 Human，也可以在使用时确定，例如通过<strong>类型强转（Cast）</strong>可以将其强转为 Man 类型或者 Woman类型，但这个改变仍是在编译期可知的，两次 sayHello 的调动都可以在编译期明确类型是 Man 还是 Woman。</p><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p><strong>动态分派</strong>与Java语言多态性的另外一个重要体现——重写（Override）有着很密切的关联。依旧先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;man say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;woman say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br>        man.sayHello();<br>        woman.sayHello();<br>        man = <span class="hljs-keyword">new</span> Woman();<br>        man.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">man say hello <br>woman say hello<br>woman say hello<br></code></pre></td></tr></table></figure><p>这个运行结果相信不出乎意料，依照经验就可以无需运行知道其结果。</p><p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 say Hello() 方法时产生了不同的行为，甚至变量 man 在两次调用中还执行了两个不同的方法。</p><p>要搞懂虚拟机如何判断应该调用哪个方法，我们可以通过 javap 输出字节码来寻找答案。main 方法的字节码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       0: new           #2                  // class DynamicDispatch$Man<br>       <span class="hljs-number">3</span>: dup<br>       4: invokespecial #3                  // Method DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">7</span>: astore_1<br>       8: new           #4                  // class DynamicDispatch$Woman<br>      <span class="hljs-number">11</span>: dup<br>      12: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V<br>      <span class="hljs-number">15</span>: astore_2<br>      <span class="hljs-number">16</span>: aload_1<br>      17: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      <span class="hljs-number">20</span>: aload_2<br>      21: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      24: new           #4                  // class DynamicDispatch$Woman<br>      <span class="hljs-number">27</span>: dup<br>      28: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V<br>      <span class="hljs-number">31</span>: astore_1<br>      <span class="hljs-number">32</span>: aload_1<br>      33: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>0<del>15 行是我们熟悉的对象创建相关的字节码，接下来的16</del>21行是关键部分，16和20行的 aload 指令分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为<strong>接收者（Receiver）</strong>；17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从 invokevirtual 指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。</p><p>invoke 指令的运行解析大致分为以下几步：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</li></ol><p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。<strong>我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</strong></p><h2 id="动态类型语言的支持"><a href="#动态类型语言的支持" class="headerlink" title="动态类型语言的支持"></a>动态类型语言的支持</h2><p>动态类型语言指的是类型检查的主体过程是发生在运行期而不是编译期进行的，例如：Lua，JS，PHP，Python等，相对的C++和Java就是常见的静态类型语言。Kotlin也是静态类型语言的一种，不过Kotlin仍然可以支持<strong>无类型或者弱类型</strong>的调用，这个将在稍后进行演示。</p><p>如何理解这个“动态类型”？以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><p>假设这是一行Java代码，并且变量obj的静态类型为java.io.PrintStream，那么变量obj的实际类型就必须是PrintStream的实现类或子类，否则编译期间就会报错。哪怕obj中确实包含有println(String)方法相同签名方法的类型，但它与PrintStream没有实现或者继承关系，代码依然不会正确运行。</p><p>但如果是相同的代码运行在JS平台，例如Kotlin：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> obj: <span class="hljs-keyword">dynamic</span> = <span class="hljs-literal">null</span><br>obj.println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>obj.whatever(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 实际不存在whatever这个方法</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：dynamic不支持JVM平台。</p></blockquote><p>这段代码可以顺利通过编译，并且只要obj对象中确实存在 println(String)和 whatever(int) 方法，调用便可成功。</p><p>产生这种差别产生的根本原因是 Java 语言在编译期间却已将 println(String) 方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中，例如下面这个样子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br></code></pre></td></tr></table></figure><p>这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。而 JS 等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，变量obj的值才具有类型，所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型 （即方法接收者不固定)。<strong>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</strong></p><h3 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h3><p>为了在 Java 虚拟机层面解决动态类型语言支持的问题，JDK 7时JSR-292提案首次出现了额外的方法调用指令——invokedynamic指令，并且提供了java.lang.invoke包来动态确定目标方法的机制，称为<strong>“方法句柄（Method Handle）”</strong>。</p><p>举个例子，如果我们要实现一个带谓词（谓词就是由外部传入的排序时比较大小的动作）的排序函数，在C/C++中的常用做法是把谓词定义为函数，用函数指针来把谓词传递到排序方法，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>))</span></span><br></code></pre></td></tr></table></figure><p>但在 Java 语言中做不到这一点，没有办法单独把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现这个接口的对象作为参数，例如Java类库中的Collections::sort()方法就是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, Comparator c)</span></span><br></code></pre></td></tr></table></figure><p>不过，使用invoke包中的方法句柄同样可以实现类似的效果了，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodHandleTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object obj = System.currentTimeMillis() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? System.out : <span class="hljs-keyword">new</span> ClassA();<br>        <span class="hljs-comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span><br>        getPrintlnMH(obj).invokeExact(<span class="hljs-string">&quot;sukaidev&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">getPrintlnMH</span><span class="hljs-params">(Object receiver)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// MethodType:代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)和具体参数(methodType()第二个及以后的参数)。</span><br>        MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class);<br>        <span class="hljs-comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span><br>        <span class="hljs-comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者</span><br>        <span class="hljs-comment">// 也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span><br>        <span class="hljs-keyword">return</span> lookup().findVirtual(receiver.getClass(), <span class="hljs-string">&quot;println&quot;</span>, mt).bindTo(receiver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法 getPrintlnMH() 中实际上是模拟了 invokevirtual 指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的 Java 方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了 MethodHandle 就可以写出类似于C/C++那样的函数声明了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, MethodHandle compare)</span></span><br></code></pre></td></tr></table></figure><h3 id="invokedynamic指令-1"><a href="#invokedynamic指令-1" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>前面说到 JDK 7中引入了 Java诞生以来的唯一一条新加入的字节码指令：invokedynamic 指令，不过如果我们把查看上面的 MethodHandle 例子字节码会发现并没有找到 invokedynamic 的影子。那么 invokedynamic 到底有什么应用呢?</p><p>某种意义上可以说 invokedynamic 指令与 MethodHandle 机制的作用是一样的，都是为了解决原有4 条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现， 另一个用字节码和Class中其他属性、常量来完成。</p><p>每一处含有 invokedynamic 指令的位置都被称作<strong>“动态调用点(Dynamically-Computed CallSite)”</strong>， 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 7 时新加入的<strong>CONSTANT_InvokeDynamic_info</strong>常量，从这个新常量中可以得到3项信息：<strong>引导方法</strong> (<strong>Bootstrap Method</strong>，该方法存放在新增的BootstrapMethods属性中)、<strong>方法类型（MethodType）</strong>和方法名称。</p><p>invokedynamic指令的调用流程如下。</p><ol><li>JVM 首次执行 invokedynamic 指令时会调用引导方法（Bootstrap Method）。</li><li>引导方法返回一个 CallSite 对象，CallSite 内部根据方法签名进行目标方法查找。它的 getTarget 方法返回方法句柄（MethodHandle）对象。</li><li>在 CallSite 没有变化的情况下，MethodHandle 可以一直被调用，如果 CallSite 有变化，重新查找即可。</li></ol><p>它们之间的关系如下图所示。</p><p><img src="/img/jvm/image-20210418204411595.png" alt="invokedynamic"></p><p>下面通过一个 Groovy 的例子来模拟这个过程：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> add(a, b)&#123;<br>    <span class="hljs-keyword">new</span> Exception().printStackTrace()<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br>add(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用 groovyc –indy 命令编译后查看字节码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()Ljava/lang/Object;<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: ldc           #44                 // String hello<br>       3: ldc           #46                 // String world<br>       5: invokedynamic #52,  0             // InvokeDynamic #1:invoke:(LTest;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;<br>      <span class="hljs-number">10</span>: areturn<br>        <br>ConstantPool:<br>  #52 = InvokeDynamic      #1:#51         // #1:invoke:(LTest;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;<br>    <br>BootstrapMethods:<br>  ··· ···<br>  1: #34 REF_invokeStatic org/codehaus/groovy/vmplugin/v8/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;<br>    Method arguments:<br>      #48 add<br>      #49 2<br></code></pre></td></tr></table></figure><p>add(“hello”, “world”)这条调用被编译为 invokedynamic 指令，第一个参数是常量池中的#52，又指向了 BootsrapMethods 中的 #1 的元素，调用静态方法 IndyInterface.bootstrap，返回一个 CallSite 对象。最后，这个对象返回给invokedynamic 指令实现对add()方法的调用，invokedynamic 指令的调用过程到此就宣告完成了。可以把上面的过程翻译为 Java 代码，更清楚整个调用过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MethodHandles.Lookup lookup = MethodHandles.lookup();<br>    MethodType mt = MethodType.methodType(Object.class, Object.class, Object.class);<br>    CallSite callSite = IndyInterface.bootstrap(lookup, <span class="hljs-string">&quot;invoke&quot;</span>, mt, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">0</span>);<br>    MethodHandle mh = callSite.getTarget();<br>    mh.invokeExact(obj, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例：调用祖父方法"><a href="#实例：调用祖父方法" class="headerlink" title="实例：调用祖父方法"></a>实例：调用祖父方法</h3><p>invokedynamic指令与此前4条传统的“invoke*”指令的最大区别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。下面通过一个例子来实例我们如何做到改变虚拟机的分派规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;i am grandfather&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;i am father&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 如何调用GrandFather中的thinking()方法？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中Son类的thinking()方法可以通过super关键字很容易的调用到Father中的thinking()方法，但要调用 GrandFather#thinking 的话传统方法就做不到了，因是在Son类的thinking()方法中根本无法获取到一个实际类型是GrandFather的对象引用。不过在拥有方法句柄之后，我们就可以通过 MethodType.Lookup 来找到祖父类中的方法句柄了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class);<br>        Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="hljs-string">&quot;IMPL_LOOKUP&quot;</span>);<br>        lookupImpl.setAccessible(<span class="hljs-keyword">true</span>);<br>        MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="hljs-keyword">null</span>)).findSpecial(GrandFather.class, <span class="hljs-string">&quot;thinking&quot;</span>, mt, GrandFather.class);<br>        mh.invoke(<span class="hljs-keyword">this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行成功输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">i am grandfather<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Execution Subsystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（三）——类加载机制</title>
    <link href="/2021/03/30/d90e9b80/"/>
    <url>/2021/03/30/d90e9b80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。——《深入理解Java虚拟机》</p></blockquote><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载 （Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initializ ation）</strong>、<strong>使用（Using）</strong>和<strong>卸载（Unloading）</strong>七个阶段，其中验证、准备、解析三个部分统称为<strong>连接（Linking）</strong>。这七个阶段的发生顺序如下图所示。</p><p><img src="/img/jvm/jvm_class_loading_process.png" alt="类加载流程"></p><p>需要注意的是，在上述7个阶段中，只有加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，并且是互相交叉地混合式进行。解析阶段在某些情况下可以在初始化阶段之后再开始，直接是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><p>那么什么时候会触发这个流程呢？《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。不过，规范中严格规定了有且只有以下六种情况必须立即对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：    <ul><li>使用new关键字实例化对象时。</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）时。</li><li>调用一个类型的静态方法时。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_p utStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>这六种场景中的行为称为对一个类型进行<strong>主动引用</strong>，那么对应的就存在<strong>被动引用</strong>了，被动引用时将不会触发初始化过程。例如有三个被动引用的场景：</p><ol><li>通过子类引用父类的静态字段，不会导致子类初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>接下来我们详细了解下Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化这五个阶段所执行的具体动作。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>“加载”（Loading）</strong>阶段是整个<strong>“类加载”（Class Loading）</strong>过程中的第一个阶段。</p><p>在加载阶段，Java虚拟机需要完成以下三件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>《Java虚拟机规范》对这三点要求其实是很灵活的，例如第一条规则，它并没有规定二进制字节流必须得从某个Class文件中获取，确切地是说根本没有指明要从哪里获取、如何获取。仅仅这一点就能玩出很多花样，例如：</p><ul><li>从Zip包中获取，例如jar包、aar包、war包等。</li><li>从网络中获取。</li><li>运行时计算生成，这种场景使用的最多就是动态代理，例如我们Android开发者最熟悉的JW大佬的Retrofit，它通过动态代理来生成一个“*$Proxy”的代理类的二进制字节流，通过这个类来真正发起网络请求。</li><li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li><li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li><li>… …</li></ul><p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的<strong>findClass</strong>()或<strong>loadClass</strong>()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p><strong>对于数组类的话，数组类的元素类型本身也需要进行类加载，不过数组类本身并不通过类加载器创建，而是直接由Java虚拟机在内存中动态构造出来。</strong></p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，然后会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口，也是我们能够使用反射的主要原理。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。如果虚拟机验证到输入的字节流如不符合Class文件格式的约束，就应当抛出一个java.lang.VerifyError异常或其子类异常，此阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证</strong>、<strong>元数据验证</strong>、<strong>字节码验证</strong>和<strong>符号引用验证</strong>。</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：此阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）分配内存并设置类变量初始值的阶段。这里需要着重强调的是，首先<strong>这时候进行内存分配的仅包括类变量，而不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。这里的初始化通常情况下指的是初始化为”0值“，例如int的0值为0，long为0L，boolean为false，引用类型为null等。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> intValue = <span class="hljs-number">123</span>;   <span class="hljs-comment">// 初始化为0</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> longValue = <span class="hljs-number">123L</span>;  <span class="hljs-comment">// 初始化为0L</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> booleanValue = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 初始化为false</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Int&gt; value = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">// 初始化为null</span><br></code></pre></td></tr></table></figure><p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：如果类字段 的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定 的初始值，假设上面类变量value的定义修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 上篇文章讲解Class文件格式的时候已经出现过多次，在Class文件中它以<strong>CONSTANT_Class_info</strong>、 <strong>CONSTANT_Fieldref_info</strong>、<strong>CONSTANT_Methodref_info</strong>等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢?</p><ul><li><strong>符号引用（Symbolic References）</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li><li><strong>直接引用（Direct References）</strong>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li></ul><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray 、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的<strong>CONSTANT_Class_info</strong>、<strong>CONSTANT_Fieldref_info</strong>、 <strong>CONSTANT_Methodref_info</strong>、<strong>CONSTANT_InterfaceMethodref_info</strong>、 <strong>CONSTANT_MethodType_info</strong>、<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_Dynamic_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong> 8种常量类型。</p><h4 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1.类或接口的解析"></a>1.类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个 类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。</li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类<br>似“ [Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了， 但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h4 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2.字段解析"></a>2.字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功完成，那把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="3-方法解析"><a href="#3-方法解析" class="headerlink" title="3.方法解析"></a>3.方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ol><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的 方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.Incomp atibleClassChangeError 异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则 返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4.接口方法解析"></a>4.接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p><ol><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那 么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化阶段是类加载过程的最后一个步骤。在进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。<strong>更直接的说，初始化阶段就是执行类构造器<cinit>()方法的过程</strong>。</p><ul><li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li><li><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在J ava虚拟机中第一个被执行的<clinit> ()方法的类型肯定是java.lang.Object 。</li><li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也 一样不会执行接口的<clinit>()方法。</li><li>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，不过在某个线程执行完<clinit>()后，其他线程都不会再执行<clinit>()方法。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载流程中的“加载”阶段被放在了Java虚拟机外部实现，实现这个阶段的工具称为<strong>“类加载器（Class Loader）“</strong>。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。通俗的讲，就是两个类是否”相等“的一个大前提是这两个类是由同一类加载器加载而来，不同类加载器加载出的Class对象一定不是同一个对象。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p><p>站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。这三层类加载器如下：</p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt .jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li><strong>应用程序类加载器（Application Class Loader）</strong>：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>这些类加载器之间的协作关系通常情况下如下图所示：</p><p><img src="/img/jvm/parents_delegate_model.png" alt="双亲委派模型"></p><p>这个模型被称为<strong>”双亲委派模型（Parents Delegation Model）“</strong>。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>以类java.lang.Object为例，它存放在rt .jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委派的代码只有短短十余行，全部集中在java.lang.ClassLoader的loadClass()方法之中，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                   <span class="hljs-comment">// 委派父类加载器加载</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">// 如果父类加载器为空</span><br>                   <span class="hljs-comment">// 使用启动类加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException </span><br>                <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 在父类加载器无法加载时</span><br>                <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 统计</span><br>                PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里要注意的是，实际开发中如果我们需要破坏双亲委派模型，那么我们就需要重写loadClass方法，否则应该重写findClass方法</strong>。</p><h3 id="Android中的类加载器"><a href="#Android中的类加载器" class="headerlink" title="Android中的类加载器"></a>Android中的类加载器</h3><p>Android 和传统的 JVM 是一样的，也需要通过 ClassLoader 将目标类加载到内存，类加载器之间也符合双亲委派模型。但是在 Android 中，ClassLoader 的加载细节有略微的差别。</p><p>在 Android 虚拟机里是无法直接运行 .class 文件的，Android 会将所有的 .class 文件转换成一个 .dex 文件，并且 Android 将加载 .dex 文件的实现封装在 <strong>BaseDexClassLoader</strong> 中，而我们一般只使用它的两个子类：<strong>PathClassLoader</strong> 和 <strong>DexClassLoader</strong>。</p><h4 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h4><p>PathClassLoader 的源码中只有两个构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath  包含.dex文件的jar/apk文件路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, parent);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath  包含.dex文件的jar/apk文件路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> librarySearchPath C/C++ native库的路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-keyword">null</span>, librarySearchPath, parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>PathClassLoader继承自BaseDexClassLoader，BaseDexClassLoader中dexPath受到限制，一般只能是已经安装应用的apk路径。不过PathClassLoader情况比较特殊：</p><ul><li>在Android 4.4以下版本时，PathClassLoader只能加载已安装到系统中的apk/dex文件。</li><li>Android 5.0~Android 8.0，PathClassLoader没有限制必须已安装的apk，并且PathClassLoader中optimizedDirectory固定为null，所以无法进行dex2oat操作，最后会直接加载原始dex，达到了禁用dex2oat以实现加载加速的效果。</li><li>Android 8.1或更高，此时DexClassLoader中optimizedDirectory同样固定传递null，oat输出目录在dex目录/oat/下，此时DexClassLoader与PathClassLoader相同。</li></ul><p>当一个 App 被安装到手机后，apk 里面的 class.dex 中的 class 均是通过 PathClassLoader 来加载的，可以通过如下代码验证：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-keyword">val</span> loader = MainActivity::<span class="hljs-keyword">class</span>.java.classLoader<br>        println(loader.toString())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="/img/jvm/print_path_class_loader.png" alt="打印结果"></p><h4 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h4><p>对比 PathClassLoader 在Android 4.4以下只能加载已经安装应用的 dex 或 apk 文件，<strong>DexClassLoader</strong> 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载。</p><p>DexClassLoader 的源码里面只有一个构造方法，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath 包含 class.dex 的 apk、jar 文件路径 ，多个路径用文件分隔符（默认是“:”）分隔</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> optimizedDirectory 用来缓存优化的 dex 文件的路径，即从 apk 或 jar 文件中提取出来的 dex 文件。该路径不可以为空，且应该是应用私有的，有读写权限的路径。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> DexClassLoader(String dexPath, String optimizedDirectory,<br>        String librarySearchPath, ClassLoader parent) &#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-literal">null</span>, librarySearchPath, parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们尝试使用DexClassLoader来自定义一个类加载器实现热修复。</p><h2 id="类加载器实践案例"><a href="#类加载器实践案例" class="headerlink" title="类加载器实践案例"></a>类加载器实践案例</h2><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>我们尝试使用自己的类加载器来加载本地磁盘上的类文件。</p><p>首先创建一个测试类，并将其复制到磁盘的某一处，这里我创建了一个Test类，编译后将其复制到”~/Downloads”目录下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testPrint</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;This class is load from custom class loader.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，创建一个DiskClassLoader继承自ClassLoader，重写其findClass方法，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加载本地磁盘中的class文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskClassLoader</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> filePath: String) : ClassLoader() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findClass</span><span class="hljs-params">(name: <span class="hljs-type">String</span>?)</span></span>: Class&lt;*&gt; &#123;<br>        <span class="hljs-keyword">val</span> newPath = <span class="hljs-string">&quot;<span class="hljs-variable">$filePath</span><span class="hljs-variable">$name</span>.class&quot;</span><br>        <span class="hljs-keyword">var</span> classBytes: ByteArray? = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">val</span> path: Path<br>        <span class="hljs-keyword">try</span> &#123;<br>            path = Paths.<span class="hljs-keyword">get</span>(URI(newPath))<br>            classBytes = Files.readAllBytes(path)<br>        &#125; <span class="hljs-keyword">catch</span> (e: URISyntaxException) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>        <span class="hljs-comment">// 创建Class对象</span><br>        <span class="hljs-keyword">return</span> defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes?.size ?: <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来尝试使用这个类加载器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> loader = DiskClassLoader(<span class="hljs-string">&quot;file:///User/sukaidev/Downloads/&quot;</span>)<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">val</span> c = loader.loadClass(<span class="hljs-string">&quot;Test&quot;</span>)<br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 反射创建对象</span><br>        <span class="hljs-keyword">val</span> obj = c.newInstance()<br>        <span class="hljs-comment">// 反射调用testPrint()方法</span><br>        c.getDeclaredMethod(<span class="hljs-string">&quot;testPrint&quot;</span>).invoke(obj)<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>    e.printStackTrace()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/img/jvm/image-20210330224020652.png" alt="运行结果"></p><p>类加载器成功加载了路径为”User/sukaidev/Downloads/Test.class”的文件。</p><h3 id="热修复实践"><a href="#热修复实践" class="headerlink" title="热修复实践"></a>热修复实践</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>先来创建一个创建 Android 项目，名字随意，项目结构如下：</p><p><img src="/img/jvm/project_hot_fix_demo.png" alt="项目结构"></p><p>ISay.java 是一个接口，内部只定义了一个方法 saySomething。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String<br>&#125;<br></code></pre></td></tr></table></figure><p>SayException.java 实现了 ISay 接口，但是在 saySomething 方法中，打印“Oops! Something went wrong.”来模拟一个线上的 bug。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayException</span> : <span class="hljs-type">ISay &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Oops! Something went wrong.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在 MainActivity.java 中，当点击 Button 的时候，将 saySomething 返回的内容通过 Toast 显示在屏幕上。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    <span class="hljs-keyword">val</span> say: ISay = SayException()<br>    findViewById&lt;AppCompatButton&gt;(R.id.btn).setOnClickListener &#123;<br>      Toast.makeText(<span class="hljs-keyword">this</span>, say.saySomething(), Toast.LENGTH_SHORT).show()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击按钮模拟线上报错，效果如下。</p><div align=center>  <img src="/img/jvm/online_bug.png" alt="" style="zoom:50%;" /></div><p>接下来尝试对其进行热修复。</p><h4 id="创建热修复补丁"><a href="#创建热修复补丁" class="headerlink" title="创建热修复补丁"></a>创建热修复补丁</h4><p>新建一个Java module用于制作热修复补丁，新建ISay和SayHotFix两个类，注意包名必须保持与上面一致。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String<br>&#125;<br></code></pre></td></tr></table></figure><p>SayHotFix 实现 ISay 接口，并在 saySomething 中返回了新的结果，用来模拟 bug 修复后的结果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayHotFix</span> : <span class="hljs-type">ISay &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Everything is OK.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要build一下项目，就会在模块的build/libs目录下生成jar包。</p><p><img src="/img/jvm/image-20210330225038974.png" alt="build生成jar包"></p><p>这个<strong>hotfix.jar</strong>就是我们需要的补丁包了，但是光有jar包是不行的，DexClassLoader只能加载.dex类型的包，因此接下来通过dx工具将生成的hotfix.jar优化为dex文件。</p><p>dx工具可以在Android Sdk目录下的build-tools目录中找到各版本的dx程序，例如我的电脑可以在版本号为30.0.3的build-tools中找到：</p><p><img src="/img/jvm/image-20210330225744386.png" alt="dx工具"></p><p>使用命令优化jar包：</p><blockquote><p>dx –dex –output=hotfix_dex.jar  hotfix.jar</p></blockquote><p> 这样我们就拿到了最终需要的补丁包<strong>hotfix_dex.jar</strong>。</p><h4 id="加载补丁包"><a href="#加载补丁包" class="headerlink" title="加载补丁包"></a>加载补丁包</h4><p>正常来讲我们的补丁包是通过后端下发，然后客户端使用DexClassLoader来加载的，这里为了方便模拟，直接通过adb命令push到sdk卡中：</p><blockquote><p>adb push hotfix_dex.jar /storage/emulated/0/</p></blockquote><p>接着修改 MainActivity 中的逻辑，使用DexClassLoader加载HotFix patch中的 SayHotFix类，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    <span class="hljs-keyword">var</span> say: ISay<br>    findViewById&lt;AppCompatButton&gt;(R.id.btn).setOnClickListener &#123;<br>      <span class="hljs-keyword">val</span> jarFile =<br>        File(Environment.getExternalStorageDirectory().path + File.separator + <span class="hljs-string">&quot;hotfix_dex.jar&quot;</span>)<br><br>      <span class="hljs-keyword">if</span> (!jarFile.exists()) &#123;<br>        say = SayException()<br>        Toast.makeText(<span class="hljs-keyword">this</span>, say.saySomething(), Toast.LENGTH_SHORT).show()<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@setOnClickListener</span><br>      &#125;<br><br>      <span class="hljs-keyword">val</span> dexClassLoader =<br>        DexClassLoader(jarFile.absolutePath, filesDir.absolutePath, <span class="hljs-literal">null</span>, classLoader)<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> clazz = dexClassLoader.loadClass(<span class="hljs-string">&quot;com.sukaidev.dexclassloaderhotfix.SayHotFix&quot;</span>)<br>        <span class="hljs-keyword">val</span> iSay: ISay = clazz.newInstance() <span class="hljs-keyword">as</span> ISay<br>        Toast.makeText(<span class="hljs-keyword">this</span>, iSay.saySomething(), Toast.LENGTH_SHORT).show()<br>      &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        e.printStackTrace()<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>注意这里需求读取SD卡上的补丁包，API 23以上需要动态申请权限。运行后效果如下：</p><div align=center>  <img src="/img/jvm/image-20210331094356020.png" alt="" style="zoom:50%;" /></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClassLoader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（二）——类文件结构</title>
    <link href="/2021/03/19/233d21b7/"/>
    <url>/2021/03/19/233d21b7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“Class 文件”并非特指某个存在于具体磁盘中的问题，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。</p></blockquote><p>Java 能够实现”一次编译，到处运行”，这其中 class 文件要占大部分功劳。为了让 Java 语言具有良好的跨平台能力，Java 独具匠心的提供了一种可以在所有平台上都能使用的一种中间代码——字节码类文件（.class文件）。有了字节码，无论是哪种平台（如：Mac、Windows、Linux 等），只要安装了虚拟机都可以直接运行字节码。</p><p>有了字节码，也解除了 Java 虚拟机和 Java 语言之间的耦合。Java虚拟机并不一定只能运行Java语言编写的程序，而是只认Class文件，其他语言如Kotlin、Groovy、Scala等都可以只需要编译成符合《Java虚拟机规范》的Class文件都可以运行在Java虚拟机中。如下图所示：</p><p><img src="/img/jvm/language_independence.png" alt="JVM的语言无关性"></p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>Class文件是一组以 8 个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程运行的必要数据，没有空隙存在。当遇到需要占用 8 个字节以上空间的数据项时，则会按照<strong>高位在前（Big-Endian，大端）</strong>的方式分割成若干个 8 个字节进行存储。结构如下图所示。</p><p><img src="/img/jvm/class_file_structure.png" alt="class文件结构"></p><p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符值。</li><li>表示由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以”_info“结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由下表所示的数据项按严格顺序排列构成。</li></ul><table><thead><tr><th align="center">类    型</th><th align="center">字   段   名</th><th align="center">数    量</th><th>名   称</th></tr></thead><tbody><tr><td align="center">u4</td><td align="center">magic</td><td align="center">1</td><td>魔数</td></tr><tr><td align="center">u2</td><td align="center">minor_version</td><td align="center">1</td><td>主版本号</td></tr><tr><td align="center">u2</td><td align="center">major_version</td><td align="center">1</td><td>副版本号</td></tr><tr><td align="center">u2</td><td align="center">constant_pool_count</td><td align="center">1</td><td>常量池大小</td></tr><tr><td align="center">cp_info</td><td align="center">constant_pool</td><td align="center">constant_pool_count-1</td><td>常量池</td></tr><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">1</td><td>访问标志</td></tr><tr><td align="center">u2</td><td align="center">this_class</td><td align="center">1</td><td>当前类索引</td></tr><tr><td align="center">u2</td><td align="center">super_class</td><td align="center">1</td><td>父类索引</td></tr><tr><td align="center">u2</td><td align="center">interfaces_count</td><td align="center">1</td><td>接口索引集合大小</td></tr><tr><td align="center">u2</td><td align="center">interfaces</td><td align="center">interfaces_count</td><td>接口索引集合</td></tr><tr><td align="center">u2</td><td align="center">fields_count</td><td align="center">1</td><td>字段索引集合大小</td></tr><tr><td align="center">field_info</td><td align="center">fields</td><td align="center">fields_count</td><td>字段索引集合</td></tr><tr><td align="center">u2</td><td align="center">methods_count</td><td align="center">1</td><td>方法索引集合大小</td></tr><tr><td align="center">method_info</td><td align="center">methods</td><td align="center">methods_count</td><td>方法索引集合</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td><td>属性索引集合大小</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attribute_count</td><td>属性索引集合</td></tr></tbody></table><p>无符号数和表的关系可以用下图表示：</p><p><img src="/img/jvm/relationship_between_two.png" alt="表和无符号数之间的关系"></p><p>可以看出，在一张表中可以包含其他无符号数和其他表格。伪代码可以如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无符号数</span><br>u1 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span>];<br>u2 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>u4 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];<br>u8 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// 表</span><br>class_table &#123;<br>    <span class="hljs-comment">// 表中可以引用各种无符号数，</span><br>    u1 tag;<br>    u2 index2;<br>    ...<br><br>    <span class="hljs-comment">// 表中也可以引用其它表</span><br>    method_table mt;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们通过编写一个例子来看看这个表中各个数据项的具体含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Cloneable</span></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br> <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>          <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;<br>          num = num + i;<br>          <span class="hljs-keyword">return</span> num;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过 javac 编译下列代码生成 Test.class 字节码文件，然后使用 16 进制编辑器打开 class 文件查看内容：</p><p><img src="/img/jvm/class_file_content.png" alt="class文件内容"></p><p>上图中都是一些 16 进制数字，每两个字符代表一个字节。</p><h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><p>每个Class文件的头 4 个字节被称为<strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。魔数被用作格式标准校验是很常见的行为，Class 文件中的魔数值为 0xCAFEBABE ，跟 Java 的”咖啡豆“含义相互呼应。</p><p><img src="/img/jvm/class_file_magic_number.png" alt="魔数"></p><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节（<strong>0000</strong>）是次版本号，第 7 和第 8 个字节（<strong>0034</strong>）是主版本号。0034 对应的十进制是 52，也就是  <strong>jdk1.8.0</strong> 。</p><p><img src="/img/jvm/class_file_version.png" alt="版本号"></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧跟在版本号之后的是一个叫作<strong>常量池</strong>的表（cp_info）。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中的。</p><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表<strong>常量池容量计数值（constant_pool_count）</strong>。例如本例中常量池大小为 <strong>0x001D</strong> ，即 <strong>29</strong> ，表示常量池中有 <strong>28</strong> 项常量，索引值范围为 <strong>1~28</strong> 。这里将 0 空出来是为了后面有表的索引值为 0 时，可以表达<strong>“不引用任何一个常量池项目”的含义。</strong></p><p><img src="/img/jvm/class_file_constant_pool_size.png" alt="常量池大小"></p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）</strong>。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)</li></ul><p>常量池中的每一项都是一个表，截止至 JDK13 ，常量表中分别有17种不同的项目类型。</p><table><thead><tr><th align="center">类   型</th><th align="center">标   志</th><th align="center">描   述</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8_info</td><td align="center">1</td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">5</td><td align="center">长精度型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">6</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">7</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">8</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">9</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的部分符号引用</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">表示方法类型</td></tr><tr><td align="center">CONSTANT_Dynamic_info</td><td align="center">17</td><td align="center">表示一个动态计算常量</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr><tr><td align="center">CONSTANT_Module_info</td><td align="center">19</td><td align="center">表示一个模块</td></tr><tr><td align="center">CONSTANT_Package_info</td><td align="center">20</td><td align="center">表示一个模块中开放或者导出的包</td></tr></tbody></table><p>这 17 类表都有一个共同的特点，表结构起始的第一位是个 u1 类型的标志位，即上表中的标志，代表着当前常量属于哪种常量类型。下面以<strong>CONSTANT_Class_info</strong> 和 <strong>CONSTANT_Utf8_info</strong> 这两张表为例，来分析一下表结构。</p><p>首先，CONSTANT_Class_info 表具体结构如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">table CONSTANT_Class_info &#123;<br>    u1  tag = <span class="hljs-number">7</span>;<br>    u2  name_index;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>tab：上面说过了是表示表的类型，例如7表示CONSTANT_Class_info类型表，占用一个字节大小。</li><li>name_index：是一个索引值，可以将它理解为一个指针，指向常量池中索引为name_index的常量表。比如name_index = 2，则它指向常量池中第2个常量。</li></ul><p>接下来再看CONSTANT_Utf8_info表具体结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">table CONSTANT_utf8_info &#123;<br>    u1  tag;<br>    u2  length;<br>    u1[] bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释说明：</p><ul><li>tag：值为1，表示是CONSTANT_Utf8_info类型表。</li><li>length：length表示u1[]的长度，比如length=5，则表示接下来的数据是 5 个连续的u1类型数据。</li><li>bytes：u1类型数组，长度为上面第2个参数length的值。</li></ul><p>而我们在java代码中声明的String字符串最终在class文件中的存储格式就是CONSTANT_utf8_info。因此一个字符串最大长度也就是u2所能代表的最大值65536个，但是需要使用2个字节来保存null值，因此<strong>一个字符串的最大长度为 65536 - 2 = 65534</strong>。</p><p>不难看出，在常量池内部的表中也有相互之间的引用。用一张图来理解CONSTANT_Class_info和CONSTANT_utf8_info表格之间的关系，如下图所示：</p><p><img src="/img/jvm/class_file_relationship_of_constant.png" alt="常量表相互引用关系"></p><p>接下来我们继续基于上面的例子分析。上面说到版本号之后就是常量池大小，为0x001D即29，表示常量计数器为28。紧接着就是第一个常量，如下所示：</p><p><img src="/img/jvm/class_file_first_constant.png" alt="第一个常量tag"></p><p>第一个字节表示tag，<strong>0x0a</strong>转化为十进制后为10，通过上面的表格我们知道tag=10时的表类型为<strong>CONSTANT_Methodref_info</strong>，因此第一个常量表结构为方法引用表。其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CONSTANT_Methodref_info &#123;<br>    u1 tag = <span class="hljs-number">10</span>;<br>    u2 class_index;        <span class="hljs-comment">// 指向此方法的所属类</span><br>    u2 name_type_index;    <span class="hljs-comment">// 指向此方法的名称和类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在“0a”之后的2个字节指向这个方法是属于哪个类，紧接的2个字节指向这个方法的名称和类型。它们的值分别是：</p><ul><li>0006：十进制6，表示指向常量池中的第6个常量。</li><li>0015：十进制21，表示指向常量池中的第21个常量。</li></ul><p>由于每个常量表占用字节的长度是不一定的，所以我们必须顺序解析到第6个常量才能知道第6个常量是什么类型，不过这里我们可以利用javap命令来帮助我们查看常量池的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -v Test.class<br></code></pre></td></tr></table></figure><p>命令执行后结果如下：</p><p><img src="/img/jvm/class_file_javap.png" alt="使用javap命令查看常量池"></p><p>正如我们刚才分析的一样，常量池中第一个常量是Methodref类型，指向下标6和下标21的常量。其中下标21的常量类型为<strong>NameAndType</strong>，它对应的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CONSTANT_NameAndType_info&#123;<br>    u1 tag;<br>    u2 name_index;    <span class="hljs-comment">// 指向某字段或方法的名称字符串</span><br>    u2 type_index;    <span class="hljs-comment">// 指向某字段或方法的类型字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而下标在21的NameAndType的name_index和type_index分别指向了13和14，也就是<strong>“<init>”</strong>和<strong>“()V”</strong>。因此最终解析下来常量池中第1个常量的解析过程以及最终值如下图所示：</p><p><img src="/img/jvm/class_file_first_constant_reference.png" alt="第1个常量引用链"></p><p>仔细解析层层引用，最后我们可以看出，Test.class文件中常量池的第1个常量保存的是Object中的默认构造器方法。</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表<strong>访问标志（access_flags）</strong>，如下图所示：</p><p><img src="/img/jvm/class_file_access_flag.png" alt="访问标志"></p><p>这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。具体的标志位以及标志的含义见下表：</p><table><thead><tr><th align="center">标  志  名  称</th><th align="center">标  志  值</th><th align="center">含   义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为public类型</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否被声明为final，只有类可设置</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td align="center">是否允许使用invokespecial字节码指令的新语义，JDK 1.0.2 之后默认为真</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td align="center">标识这是一个接口</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">是否为abstract类型，对于接口或抽象类来说为真</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">标识这个类并非由用户代码产生</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td align="center">标识这是一个注解</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">标识这是一个枚举</td></tr><tr><td align="center">ACC_MODULE</td><td align="center">0x8000</td><td align="center">标识这是一个模块</td></tr></tbody></table><p>我们定义的Test.java是一个普通Java类，不是接口、枚举或注解。并且被public修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它所对应的access_flags为<strong>0021</strong>（0X0001和0X0020相结合）。</p><h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>在访问标志后的 2 个字节就是<strong>类索引（this_class）</strong>，类索引后的 2 个字节就是<strong>父类索引（super_class）</strong>，父类索引后的 2 个字节则是<strong>接口索引计数器（interfaces）</strong>。<strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</strong>由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>在我们的例子中如下图所示：</p><p><img src="/img/jvm/class_file_this_super_class.png" alt="类索引、父类索引、接口索引计数器"></p><p>可以看出类索引指向常量池中的第 5 个常量，父类索引指向常量池中的第 6 个常量，并且实现的接口个数为 2 个。再回顾下常量池中的数据：</p><p><img src="/img/jvm/class_file_interfaces.png" alt="常量池中索引"></p><p>从图中可以看出，第 5 个常量和第 6 个常量均为 CONSTANT_Class_info 表类型，并且代表的类分别是“Test”和“Object”。再看接口计数器，因为接口计数器的值是 2，代表这个类实现了 2 个接口。查看在接口计数器之后的 4 个字节分别为：</p><ul><li>0007：指向常量池中的第7个常量，从图中可以看出第7个常量值为“Serializable”。</li><li>0008：指向常量池中的第8个常量，从图中可以看出第8个常量值为“Cloneable”。</li></ul><p>综上所述，可以得出如下结论：当前类为 Test 继承自 Object 类，并实现了“Serializable”和“Cloneable”这两个接口。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>紧跟在接口索引集合后面的就是<strong>字段表（field_info）</strong>了，字段表用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>同样, 一个类中的变量个数是不固定的，因此在字段表集合之前还是使用一个计数器来表示变量的个数，如下所示：</p><p><img src="/img/jvm/class_file_field_info_count.png" alt="字段表计数器"></p><p><strong>0002</strong> 表示类中声明了 2 个变量（在 class 文件中叫字段），字段计数器之后会紧跟着 2 个字段表的数据结构。</p><p>字段表的具体结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">CONSTANT_Fieldref_info&#123;<br>    u2  access_flags        <span class="hljs-comment">// 字段的访问标志</span><br>    u2  name_index          <span class="hljs-comment">// 字段的名称索引(也就是变量名)</span><br>    u2  descriptor_index    <span class="hljs-comment">// 字段的描述索引(也就是变量的类型)</span><br>    u2  attributes_count    <span class="hljs-comment">// 属性计数器</span><br>    attribute_info attributes <span class="hljs-comment">// 属性表集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字段访问标志放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如下表所示。</p><table><thead><tr><th align="center">标 志 名 称</th><th align="center">标 志 值</th><th align="center">含  义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">字段是否为public</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">字段是否为private</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">字段是否为protected</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">字段是否static</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">字段是否final</td></tr><tr><td align="center">ACC_VOLATILE</td><td align="center">0x0040</td><td align="center">字段是否volatile</td></tr><tr><td align="center">ACC_TRANSIENT</td><td align="center">0x0080</td><td align="center">字段是否transient</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">字段是否synthetic</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">字段是否为enum</td></tr></tbody></table><p>很明显，由于语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最 多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所导致的。</p><p>跟随access_flags标志的是两项索引值：<strong>name_index</strong>和<strong>descriptor_index</strong>。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，如下表所示。</p><table><thead><tr><th align="center">标  识  字  符</th><th align="center">含    义</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">基本类型byte</td></tr><tr><td align="center">C</td><td align="center">基本类型char</td></tr><tr><td align="center">D</td><td align="center">基本类型double</td></tr><tr><td align="center">F</td><td align="center">基本类型float</td></tr><tr><td align="center">I</td><td align="center">基本类型int</td></tr><tr><td align="center">J</td><td align="center">基本类型long</td></tr><tr><td align="center">S</td><td align="center">基本类型short</td></tr><tr><td align="center">Z</td><td align="center">基本类型boolean</td></tr><tr><td align="center">V</td><td align="center">特殊类型void</td></tr><tr><td align="center">L</td><td align="center">对象类型，如Ljava/lang/Object;</td></tr></tbody></table><p><strong>对于数组类型，每一维度将使用一个前置的“ [”字符来描述，如一个定义为“ jav-a.lang.String[][]”类型的二维数组将被记录成“ [[Ljava/lang/String;”，一个整型数组“ int []”将被记录成“ [I”。</strong></p><p>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String;”，方法int indexOf(char[]so-urce，int sourceOffset，int sourceCount，char[] target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p><p>继续解析 Text.class 中的字段表，其结构如下图所示：</p><p><img src="/img/jvm/class_file_field_info.png" alt="Text.class中的字段表"></p><p>图中的访问标志的值为 <strong>0002</strong>，代表它是 private 类型。变量名索引指向常量池中的第 9 个常量，变量名类型索引指向常量池中第 10 个常量。第 9 和第 10 个常量分别为“num”和“I”，如下所示：</p><p><img src="/img/jvm/class_file_field_info_name_index.png" alt="字段名称和描述符"></p><p>因此可以得知类中有一个名为 num，类型为 int 类型的变量。对于第 2 个变量的解析过程也是一样，就不再过多介绍。</p><p>注意事项：</p><ul><li><p>字段表集合中不会列出从父类或者父接口中继承而来的字段。</p></li><li><p>内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></li></ul><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引）（name_index）、描述符索引（descrip tor_index）、属性表集合（attributes）几项，如下所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">CONSTANT_Fieldref_info&#123;<br>    u2  access_flags        <span class="hljs-comment">// 字段的访问标志</span><br>    u2  name_index          <span class="hljs-comment">// 字段的名称索引(也就是变量名)</span><br>    u2  descriptor_index    <span class="hljs-comment">// 字段的描述索引(也就是变量的类型)</span><br>    u2  attributes_count    <span class="hljs-comment">// 属性计数器</span><br>    attribute_info attributes <span class="hljs-comment">// 属性表集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为volatile关键字和transient 关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了<strong>ACC_SYNCHRONIZED</strong>、 <strong>ACC_NATIVE</strong>、<strong>ACC_STRICTFP</strong>和<strong>ACC_ABSTRACT</strong>标志。</p><table><thead><tr><th align="center">标 志 名 称</th><th align="center">标 志 值</th><th align="center">含  义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">方法是否为public</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">方法是否为private</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">方法是否为protected</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">方法是否static</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">方法是否final</td></tr><tr><td align="center">ACC_SYNCHRONIZED</td><td align="center">0x0020</td><td align="center">方法是否synchronized</td></tr><tr><td align="center">ACC_BRIDGE</td><td align="center">0x0040</td><td align="center">方法是否是由编译器产生的桥接方法</td></tr><tr><td align="center">ACC_VARARGS</td><td align="center">0x0080</td><td align="center">方法是否接收不定参数</td></tr><tr><td align="center">ACC_NATIVE</td><td align="center">0x0100</td><td align="center">方法是否是native方法</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">方法是否是abstract</td></tr><tr><td align="center">ACC_STRICT</td><td align="center">0x0800</td><td align="center">方法是否为strictfp</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">方法是否由编译器自动产生</td></tr></tbody></table><p>我们主要来看下 add 方法，具体如下：</p><p><img src="/img/jvm/class_file_method_add.png" alt="add方法"></p><p>从图中我们可以看出 add 方法的以下字段的具体值：</p><ol><li>access_flags = 0x0001 也就是访问权限为 public。</li><li>name_index = 0x0011  指向常量池中的第 17 个常量，也就是“add”。</li><li>type_index = 0x0012   指向常量池中的第 18 个常量，也即是 (I)。这个方法接收 int 类型参数，并返回 int 类型参数。</li></ol><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在之前解析字段和方法的时候，在它们的具体结构中我们都能看到有一个叫作 attributes_info 的表，这就是属性表。</p><p>属性表并没有一个固定的结构，各种不同的属性只要满足以下结构即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CONSTANT_Attribute_info&#123;<br>    u2 attribute_name_index;          <span class="hljs-comment">// 属性名</span><br>    u2 attribute_length length;       <span class="hljs-comment">// 属性值长度</span><br>    u1[] info;                        <span class="hljs-comment">// 属性值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JVM 中预定义了很多属性表，这里重点讲一下 <strong>Code 属性表</strong>。</p><p>Java程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示。</p><table><thead><tr><th align="center">类  型</th><th align="center">名  称</th><th align="center">数  量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">attribute_name_index</td><td align="center">1</td></tr><tr><td align="center">u4</td><td align="center">attribute_length</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">max_stack</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">max_locals</td><td align="center">1</td></tr><tr><td align="center">u4</td><td align="center">code_length</td><td align="center">1</td></tr><tr><td align="center">u1</td><td align="center">code</td><td align="center">code_length</td></tr><tr><td align="center">u2</td><td align="center">exception_table_length</td><td align="center">1</td></tr><tr><td align="center">exception_info</td><td align="center">exception_table</td><td align="center">exception_table_length</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attributes_count</td></tr></tbody></table><p>下面分别解释一下这些属性：</p><ul><li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，<strong>由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</strong></li><li>max_stack代表了操作数栈(Operand Stack)深度的最大值。</li><li>max_locals代表了局部变量表所需的存储空间。</li><li>code_length和code用来存储Java源程序编译后生成的字节码指令。</li></ul><p>关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p><p>我们可以接着刚才解析方法表的思路继续往下分析：</p><p><img src="/img/jvm/class_file_attr_count.png" alt="属性计数和类型索引"></p><p>可以看到，在方法类型索引之后跟着的就是“add”方法的属性。0X0001 是属性计数器，代表只有一个属性。0X000f 是属性表类型索引，通过查看常量池可以看出它是一个 Code 属性表，如下所示：</p><p><img src="/img/jvm/class_file_attr_index_15.png" alt="索引15为Code"></p><p>通过 javap -v Test.class 之后，可以看到方法的字节码，如下图显示的是 add 方法的字节码指令：</p><p><img src="/img/jvm/class_file_attr_codebyte.png" alt="add方法字节码指令"></p><p>JVM 执行 add 方法时，就通过这一系列指令来做相应的操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Class File</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（一）——自动内存管理</title>
    <link href="/2021/03/12/132bcd6f/"/>
    <url>/2021/03/12/132bcd6f/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><p>对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”， 又是从事最基础工作的劳动人民——既拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。</p><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对 的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问 题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如下所示。</p><p><img src="/img/jvm/jvm_run_time_data_areas.png" alt="JVM Run-time data areas"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个技术记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则应为空（Undefined）。此内存区是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，<strong>Java虚拟机栈（Java Virtual Machine Stack）</strong>也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧（Stack Frame）</strong>用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（<strong>boolean</strong>、<strong>byte</strong>、<strong>char</strong>、<strong>short</strong>、<strong>int</strong>、 <strong>float</strong>、<strong>long</strong>、<strong>double</strong>）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈（Native Method Stacks）</strong>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于Java应用程序来说，<strong>Java堆（Java Heap）</strong>是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域存在的唯一目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的内存区域，因此有些资料也称其为<strong>”GC堆“（Garbage Collected Heap）</strong>。</p><p>从回收内存的角度看，现代垃圾收集器通常在<strong>逻辑上</strong>将Java堆分为<strong>”新生代“</strong>、<strong>”老年代“</strong>、<strong>”永久代“</strong>、”<strong>Eden空间“</strong>、<strong>”From Survivor空间“</strong>等区域，但这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，也与《Java虚拟机规范》无关。</p><p>从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB）</strong>，以提升对象分配时的效率。不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。如果堆中内有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在《Java虚拟机规范》中把方法区描述为<strong>堆的一个逻辑部分</strong>，为了与Java堆区分，通常把它叫做<strong>”非堆（Non-Heap）“</strong>。</p><p>方法区的内存使用超过限制会抛出OutOfMemory异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说<strong>，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</strong></p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK 1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMe-moryError异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>接下来我们以最常见的虚拟机HotSpot和内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p><p>先看一张图：</p><p><img src="/img/jvm/jvm_java_object_creation.png" alt="Java Object Creation"></p><p>我们来分析一下这个流程。</p><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。Java堆中有两种内存分配方式，分别是<strong>”指针碰撞“</strong>和<strong>”空闲列表“</strong>。</p><ul><li><strong>指针碰撞（Bump The Pointer）：</strong>已分配内存和空闲内存之间放置一个作为分界点的指示器，通过移动这个指示器来调整空闲空间的大小实现对象的内存分配。这种分配方式适合内存绝<strong>对规整</strong>的情况。</li><li><strong>空闲列表（Free List）：</strong>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有<strong>空间压缩整理（Compact）</strong>的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p><p>除了划分可用内存空间之外，对象的创建实际上还会有线程安全的问题：可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。要解决这个问题有两种可选方案：</p><ol><li>对分配内存空间的动作进行同步处理。实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间之中进行。这种情况需要每个线程预先在堆上分配一小块内存，称为本地线程分配缓冲<strong>（Thread Local Allocation Buffer，TLAB）</strong>，哪个线程要分配内存，就先到它的TLAB中分配，只有TLAB满了，分配新的缓存区时才需要同步锁定。</li></ol><p>分配完内存之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</p><p>接下来JVM需要对对象进行必要的设置，例如接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的<strong>对象头(Object Header)之中</strong>。</p><p>完成上面的工作之后，在虚拟机看来实际上一个新的对象已经产生了。不过从程序角度来看，还需要调用构造函数来初始化对象的资源和状态。因此new指令之后接着会执行Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。如下图所示。</p><p><img src="/img/jvm/HotSpot_object_storage_distribution.png" alt="HotSpot虚拟机对象存储分布"></p><p>其中MarkWord是一个有着动态定义的数据结构，在未开启指针压缩的情况，在32位和64位虚拟机上的长度分别为32个比特和64个比特。</p><p>例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><table><thead><tr><th align="center">存储内容</th><th align="center">标志位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象哈希码、分代年龄</td><td align="center">01</td><td align="center">未锁定</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">00</td><td align="center">轻量级锁定</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">10</td><td align="center">膨胀（重量级锁定）</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">01</td><td align="center">可偏向</td></tr></tbody></table><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li>使用句柄访问时，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自具体的地址信息，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_handles.png" alt="通过句柄访问对象"></p><ul><li>使用直接指针访问时，Java堆中对象的内存布局就必须考虑如何放置访问数据类型的相关信息，reference中存储的直接就是对象地址。如果只是访问对象本身的话，就不需要额外的间接访问开销了，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_pointer.png" alt="通过直接指针访问对象"></p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p><strong>垃圾收集简称GC（Garbage Collection）</strong>，它主要需要完成三件事：</p><ul><li>那些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>上面介绍了Java内存运行时区域的各个部分，我们知道线程私有的区域可以随着线程的销毁而进行内存的清理工作，而Java堆和方法区是线程共享的部分，这部分内存的分配和回收是动态的，所以是垃圾收集器重点关注的区域，本文讨论的也是这两个区域。</p><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>在Java堆中存放这Java世界中几乎所有的对象实例，垃圾收集器在堆堆进行GC钱，第一件事就是要确认哪些对象的实例”活着“，哪些对象已经”死亡“需要被回收。</p><p>目前主流的判断对象存活的算法有两种：</p><ul><li><strong>引用计数法</strong></li><li><strong>可达性分析法</strong></li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数：<strong>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</strong></p><p>此算法简单且高效，只需要占用一些额外的内存空间来进行计数，但主流的JVM都没有选用这个算法来管理内存，主要原因是：这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><p>这也是常说的”循环引用“问题，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &lt;-- 背景 --&gt;</span><br><span class="hljs-comment">// 对象objA 和 objB 都有字段 name</span><br><span class="hljs-comment">// 两个对象相互进行引用，除此之外这两个人对象没有任何引用</span><br>objA.name = objB；<br>objB.name = objA；<br><br><span class="hljs-comment">// &lt;-- 问题 --&gt;</span><br><span class="hljs-comment">// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收</span><br><span class="hljs-comment">// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象</span><br></code></pre></td></tr></table></figure><p>当出现循环引用时，两个对象已经”死亡“，但实际上由于引用计数器不为0而无法被回收引起泄露。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。</p><p>可达性分析（Reachability Analysis）：<strong>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</strong></p><p><img src="/img/jvm/reachablity_analysis_process.png" alt="可达性分析法"></p><p>如上图所示，与GC Root不存在引用链的对象将会被判为“死亡”对象，在下一次GC时进行回收。</p><p>Java中固定可作为GC Root的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象，即栈帧中的本地变量表，里面存放了各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，例如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</li></ul><p>除了上述固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如发生局部回收（Partial GC）时，如果只针对Java堆中某一块区域发起垃圾收集，这个区域里的对象完全有可能被区域外部的其他对象引用，例如下图中的B对象。此时A对象会被一并加入到GC Roots集合中，充当临时的GC Root，才能保证可达性分析的准确性。</p><p><img src="/img/jvm/partial_gc_reachability.png" alt="局部GC"></p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>一个对象要真正被垃圾回收器回收，除了要在可达性分析判断为不可达对象外，还要经历至少两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<strong>finalize</strong>方法。如果对象没有复写finalize方法或者finalize方法已经被调用过一次了，那么这两种情况都被视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<strong>F-Queue</strong>的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，<strong>但并不承诺一定会等待它运行结束</strong>。 不承诺它一定结束的原因是，finalize()方法可能会很耗时或者存在死循环导致其他对象无法正常执行finalize()。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>圾收集算法可以划分为“<strong>引用计数式垃圾收集”（Reference Counting GC）</strong>和<strong>“追踪式垃圾收集”（Tracing GC）</strong>两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。本文主要探讨追踪式垃圾收集。</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，它建立在两个假说之上：</p><ol><li><strong>弱分代假说（Weak Generational Hypothesis）</strong>：绝大多数对象都是朝生夕灭的。</li><li><strong>强分代假说（Strong Generational Hypothesis）</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>基于这两个假说，垃圾收集器可以将 Java堆划分为不同的区域，根据对象的年龄将其分配到不同区域中，在不同的区域中采用不同的垃圾收集频率和算法。例如虚拟机中可能存在下列几种算法：</p><ul><li><strong>部分收集（Partial GC）</strong>：指目标不是完整收集整个Java堆的垃圾收集。<ul><li><strong>新生代收集（Minor GC/Young GC）</strong>：指目标只是新生代的垃圾收集。</li><li><strong>老年代收集（Major GC/Old GC）</strong>：指目标只是老年代的垃圾收集。</li><li><strong>混合收集（Mixed GC）</strong>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><strong>整堆收集（Full GC）</strong>：收集整个Java堆和方法区的垃圾收集。</li></ul><p>例如我们可以将Java堆粗略的分为<strong>新生代（Young Generation）</strong>和<strong>老年代（Old Generation）</strong>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>我们可以在新生代和老年代分别进行GC操作，这就引申出一个问题：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p><ul><li><strong>跨代引用假说（Intergenerational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>依据这条假说，我们只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-Sweep）算法是最早出现也是最基础的垃圾收集算法，它分为“标记”和“清除”两个阶段：</p><ul><li><strong>标记（Mark）</strong>：标记所有需要清除或者保留的对象。</li><li><strong>清除（Sweep）</strong>：回收所有被标记或者未被标记的对象。</li></ul><p>标记-清除算法是最基础的收集算法，后续的收集算法大多都是基于它改进产生的。为什么需要改进呢，是因为它有两个比较明显的缺点：</p><ul><li>执行效率不稳定：标记和清除两个过程的执行效率随着对象数量增长而降低。</li><li>内存空间碎片化：标记、清除之后会产生大量不连续的内存碎片，会导致后续需要分配大对象例如数组的时候无法找到连续内存而发生OOM。</li></ul><p>标记-清除算法的执行过程如下图所示。</p><p><img src="/img/jvm/mark_sweep_process.png" alt="标记-清除算法执行过程"></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记-复制（Mark-Copy）算法常被简称为复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完的时候，就将这块内存上存活的对象复制到另一块内存中，最后将之前那块内存一次清理掉。</p><p>标记-复制算法可以解决标记-清除中内存碎片过多的问题，但缺点也是显而易见的：将可用内存缩小为了原来的一半。</p><p>标记-复制算法执行过程如下图所示。</p><p><img src="/img/jvm/mark_copy_process.png" alt="标记-复制算法执行过程"></p><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，但并不按照1：1的比例来划分新生代的内存空间，而是把新生代划分为<strong>一块较大的Eden空间和两块较小的Survivor空间</strong>，每次分配内存只考虑Eden空间和其中的一块Survivor。当发生GC时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是说将原先标记-复制算法浪费一半空间的问题缩小到了10%。当然这个算法也有一个问题，就是只预留10%的新生代空间，有可能会存在这10%空间不足以将存活的对象复制过去的问题，所以实际中发生这个问题时还会有老年代参与进来接收这些不足够存放的对象。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>我们前面讨论了新生代要如何进行分区进行标记-复制算法的问题。新生代中对象“朝生夕灭”，每次GC只需要复制少量的对象即可完成算法过程。但老年代中对象存活率较高，如果需要频繁的进行复制操作，效率将会很低，因此老年代中一般不会采用标记-复制算法。</p><p>标记-整理（Mark-Compact）算法与标记清除-算法类似，不同的是在标记后不会立即进行清理，而是先进行让所有存活的对象都向内存空间的一端进行移动，即”整理“，然后直接清除掉边界以外的内存。步骤如下：</p><ol><li><strong>标记阶段</strong>：标记出所有需要回收的对象；</li><li><strong>整理阶段</strong>：让所有存活的对象都向一端移动</li><li><strong>清除阶段</strong>：统一清除（回收）端以外的对象。</li></ol><p>算法执行过程如下图所示。</p><p><img src="/img/jvm/mark_compat_process.png" alt="标记-整理算法执行过程"></p><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.jianshu.com/p/0269237a229d">JVM：这是一份全面 &amp; 详细的 （GC）垃圾收集算法 讲解攻略</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://www.liuguangli.win/archives/500">Java对象之死</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（五）——官方框架</title>
    <link href="/2021/02/28/c18f109d/"/>
    <url>/2021/02/28/c18f109d/</url>
    
    <content type="html"><![CDATA[<h2 id="协程框架概述"><a href="#协程框架概述" class="headerlink" title="协程框架概述"></a>协程框架概述</h2><p>Kotlin协程的官方框架kotlin.coroutines是一套独立于标准库之外的以生产为目的的框架，框架本身提供了丰富的API来支撑生产环境中异步程序的设计和实现。主要包含以下几个部分：</p><ul><li>core：框架的核心逻辑，包含前两篇文章实现的内容和Channel、Flow等特性。</li><li>ui：包含android、javafx、swing三个库，用于提供各平台的UI调度器和一些特有的逻辑。</li><li>reactive：提供对各种响应式编程框架的协程支持。<ul><li>reactive：提供对<a href="http://www.reactive-streams.org/">Reactive Streams</a>的协程支持。</li><li>reactor：提供对<a href="https://projectreactor.io/">Reactor</a>的协程支持。</li><li>rx2：提供对<a href="https://github.com/ReactiveX/RxJava">RxJava 2.x</a>版本的协程支持。</li></ul></li><li>integration：提供与其他框架的异步回调的集成。<ul><li>jdk8：提供对CompletableFuture的协程API的支持。</li><li>guava：提供对ListenableFuture的协程API的支持。</li><li>slf4j：提供MDCContext作为协程上下文的元素。</li><li>play-services：提供对Google Play服务中的Task的协程API的支持。</li></ul></li></ul><p><img src="/img/kotlinx_coroutines_framework.png" alt="官方协程框架的结构"></p><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>kotlin官方协程框架中协程的启动多了一个start参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></td></tr></table></figure><p>启动模式总共有4种。</p><ul><li>DEFAULT ：协程创建后，立即开始调度，在调度前如果被取消则进入取消相应的状态。</li><li>ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点前不响应取消。</li><li>LAZY：只有协程主调调用start、join或者await等函数时才会开始调度，如果调度前被取消将进入异常结束状态。</li><li>UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个挂起点。</li></ul><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>官方框架中预置了4个调度器，我们可以通过Dispatchers对象访问它们。</p><ul><li>Default：默认调度器，适合处理后台计算，是一个CPU密集型任务调度器。</li><li>IO：IO调度器，适合执行IO相关操作，是一个IO密集型任务调度器。</li><li>Main：UI调度器，根据平台不同会被初始化为对应的UI线程的调度器，例如ANdroid平台的主线程（UI线程）。</li><li>Unconfined：未定调度器，不要求协程执行在特定的线程上。如果协程的调度器是Unconfined，那么它在挂起点恢复执行时后续代码会在恢复所在的线程上直接执行。</li></ul><p>如果内置的调度器无法满足需求，也可以自定义调度器，只需要实现CoroutineDispatcher接口即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDispatcher</span> : <span class="hljs-type">CoroutineDispatcher</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>      ... ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多的时候我们将自己定义好的线程池转成调度器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Executors.newSingleThreadExecutor()<br>    .asCoroutineDispatcher()<br>    .use &#123; dispatcher -&gt;<br>        <span class="hljs-keyword">val</span> result = withContext(dispatcher) &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-string">&quot;Hello World.&quot;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里用到了<strong>asCoroutineDispatcher</strong>和<strong>withContext</strong>两个扩展函数。asCoroutineDispatcher实际上也就是把线程池转为CoroutineDispatcher接口的实现，withContext函数会将参数中的Lambda表达式调度到对应的调度器上，返回值为Lambda表达式的值，它的作用等价于async{ … }.await()，且内存开销更低，因此对于async之后立即await的情况都可以用withContext来提高性能。</p><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>官方框架中支持全局的异常处理器，在根协程（顶级协程）未设置异常处理器时，未捕获异常会优先传递给全局异常处理器处理，之后再交给线程的UncaughtExceptionHandler。</p><p>定义一个全局异常处理器与普通的异常处理器没有区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineExceptionHandler &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Global Coroutine exception:<span class="hljs-variable">$exception</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 关键在于我们需要在classpath目录下创建META-INF/services目录，在其中创建一个名为kotlinx.coroutines.CoroutineExceptionHandler的文件，文件的内容是全局异常处理器的全类名。</p><h3 id="取消检查"><a href="#取消检查" class="headerlink" title="取消检查"></a>取消检查</h3><p>协程中挂起函数可以通过suspendCancellableCoroutine来响应所在协程的取消转台，那么没有挂起点的话如何取消呢？例如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyTo</span><span class="hljs-params">(<span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>, bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    <span class="hljs-keyword">var</span> bytesCopied: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">val</span> buffer = ByteArray(bufferSize)<br>    <span class="hljs-keyword">var</span> bytes = read(buffer)<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, bytes)<br>        bytesCopied += bytes<br>        bytes = read(buffer)<br>    &#125;<br>    <span class="hljs-keyword">return</span> bytesCopied<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以效仿线程的取消，在while循环内设置一个状态监听，这里我们可以监听父协程的存活状态来判断是否取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@OptIn(InternalCoroutinesApi::class)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyToSuspend</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">val</span> job = coroutineContext[Job]<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        job?.let &#123; it.takeIf &#123; it.isActive &#125; ?: <span class="hljs-keyword">throw</span>  job.getCancellationException() &#125;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这里还有更简便的方法，那就是<strong>yield</strong>函数。yield函数内部会调用CoroutineContext#checkCompletion函数来检查协程是否存活：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()  <span class="hljs-comment">// 检查协程是否存活</span><br>    <span class="hljs-keyword">val</span> cont = uCont.intercepted() <span class="hljs-keyword">as</span>? DispatchedContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">if</span> (!cont.dispatcher.isDispatchNeeded(context)) &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-keyword">if</span> (cont.yieldUndispatched()) COROUTINE_SUSPENDED <span class="hljs-keyword">else</span> <span class="hljs-built_in">Unit</span><br>    &#125;<br>    cont.dispatchYield(<span class="hljs-built_in">Unit</span>)<br>    COROUTINE_SUSPENDED<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineContext.<span class="hljs-title">checkCompletion</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">get</span>(Job)<br>    <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) <span class="hljs-keyword">throw</span> job.getCancellationException()<br>&#125;<br></code></pre></td></tr></table></figure><p>这点与线程的yield函数不同，线程的yield函数仅让出线程的执行权，并不会进行中断状态检查。</p><h3 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h3><p>官方提供了两个api用于超时取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> user = withTimeout(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时抛出取消异常</span><br>        getUserSuspend()<br>    &#125;<br>    <span class="hljs-keyword">val</span> userOrNull = withTimeoutOrNull(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时返回null</span><br>        getUserSuspend()<br>    &#125;<br>    println(user)<br>    println(userOrNull)<br>&#125;.join()<br></code></pre></td></tr></table></figure><h3 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h3><p>官方框架提供一个名为NonCancellable的上下文实现用于禁止作用范围内的协程被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">yield()<br>withContext(NonCancellable) &#123; <span class="hljs-comment">// 禁止被取消</span><br>    delay(<span class="hljs-number">10000L</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="热数据通道Channel"><a href="#热数据通道Channel" class="headerlink" title="热数据通道Channel"></a>热数据通道Channel</h2><p>Channel用于连接协程实现协程间的通信，它实际上就是一个并发安全的队列，用法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><br><span class="hljs-keyword">val</span> producer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        channel.send(i++)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = channel.receive()<br>        println(element)<br>    &#125;<br>&#125;<br>producer.join()<br>consumer.join()<br></code></pre></td></tr></table></figure><p>这里使用channel实现了一个简单的生产消费者模式，producer中每隔1s向Channel发送一个数字，而consumer一直在读取Channel来读取这个数字并打印。channel.receive必然是挂起的，那么channel.send一定是个挂起函数吗？</p><h3 id="Channel的容量"><a href="#Channel的容量" class="headerlink" title="Channel的容量"></a>Channel的容量</h3><p>前面说了channel本质是个队列，那么队列是有空间的，一但空间不足就可能会出现两种情况，阻塞或者直接抛异常。send在发送消息时，队列的缓冲区也可能会满，满了之后send就需要挂起协程等待外部调用receive取走元素了。来看下Channel缓冲区的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> <span class="hljs-title">Channel</span><span class="hljs-params">(capacity: <span class="hljs-type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =<br>    <span class="hljs-keyword">when</span> (capacity) &#123;<br>        RENDEZVOUS -&gt; RendezvousChannel()<br>        UNLIMITED -&gt; LinkedListChannel()<br>        CONFLATED -&gt; ConflatedChannel()<br>        BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY)<br>        <span class="hljs-keyword">else</span> -&gt; ArrayChannel(capacity)<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据传入的容量值不同，这里创建了四种不同的Channel：</p><ul><li><strong>RendezvousChannel</strong>：缓冲区大小为0或者说没有缓冲区的Channel。这意味着send调用后会马上挂起直到receive被调用，receive调用后也会马上挂起协程直到另一个协程调用send。</li><li><strong>LinkedListChannel</strong>：缓冲区是一个的LinkedList，它的send永远不会挂起协程，同时offer总是返回true，这意味着它“来者不拒”，这点跟LinkedBlockingQueue有点类似。</li><li><strong>ConflatedChannel</strong>：缓冲区仅保留最近send过来的一个元素。send函数不会挂起协程，但仅保留最近的send的一个元素，这意味这如果receive调用时机晚了会丢失早先send的数据。</li><li><strong>ArrayChannel</strong>：接收一个值作为缓冲区大小，效果类似于ArrayBlockingQueue，缓冲区满了Sender挂起，缓冲区空了Receiver挂起。</li></ul><h3 id="迭代Channel"><a href="#迭代Channel" class="headerlink" title="迭代Channel"></a>迭代Channel</h3><p>Channel重写的Iterator操作符，因此可以进行迭代。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> iterator = channel.iterator()<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">val</span> element = iterator.next()<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> channel) &#123;<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="produce和actor"><a href="#produce和actor" class="headerlink" title="produce和actor"></a>produce和actor</h3><p>可以使用produce或者actor快速构建一个生产者或者消费者协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer: ReceiveChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.produce &#123;<br>    repeat(<span class="hljs-number">100</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        send(it)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer: SendChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.actor &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = receive()<br>        println(element)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ReceiveChannel和SendChannel是Channel的父接口，分别定义了receive和send方法。produce构造除了ProducerCoroutine对象，该类是Job的实现类之一，主要工作是在协程结束或被取消时关闭Channel，send同理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerCoroutine</span>&lt;<span class="hljs-type">E</span>&gt;</span>(<br>    parentContext: CoroutineContext, channel: Channel&lt;E&gt;<br>) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="hljs-literal">true</span>), ProducerScope&lt;E&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">super</span>.isActive<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">(value: <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        _channel.close()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>, handled: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> processed = _channel.close(cause)<br>        <span class="hljs-keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Channel的关闭"><a href="#Channel的关闭" class="headerlink" title="Channel的关闭"></a>Channel的关闭</h3><p>Channel存在关闭的概念，所以被称为<strong>热数据流</strong>。当我们调用Channel的close方法时，它会立即停止接收元素，这个时候它的<strong>isClosedForSend</strong>会立即返回true，该属性表示发送端已经关闭。当Channel缓冲区的所有元素都被读取后，<strong>isClosedForReceive</strong>会返回true，表示接收端也已经关闭。</p><p>跟I/O流一样，我们需要在合适的时候关闭Channel，如果不关闭则会导致接收端一直处于挂起等待状态。对于单向通信的Channel，由发送端处理关闭较为合适；对于双向通信的Channel则协商关闭。</p><h3 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h3><p>前面的Channel发送端和接收端可能存在一对多的情况，不过同一元素只会被一个接收端接收到。不过<strong>BroadcastChannel</strong>中多个接收者不存在互斥行为。可以通过BroadcastChannel方法来构建一个BroadcastChannel对象，再通过这个对象来获取ReceiveChannel。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建BroadcastChannel</span><br><span class="hljs-keyword">val</span> broadcastChannel = BroadcastChannel&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// 获取一个ReceiveChannel</span><br><span class="hljs-keyword">val</span> receiveChannel = broadcastChannel.openSubscription()<br></code></pre></td></tr></table></figure><p>或者可以使用普通的channel转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><span class="hljs-keyword">val</span> broadcastChannel = channel.broadcast(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>Channel.broadcast方法实际就是读取原Channel的元素然后再通过广播发送。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> ReceiveChannel<span class="hljs-type">&lt;E&gt;</span>.<span class="hljs-title">broadcast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    capacity: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.LAZY</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: BroadcastChannel&lt;E&gt; =<br>    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;<br>        <span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span><span class="hljs-symbol">@broadcast</span>) &#123; <span class="hljs-comment">// 读取原Channel</span><br>            send(e)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>有一点需要注意的是，由于这里读取了原Channel，所以如果有其他协程也在读取这个Channel，可能会存在互斥的情况。</p><h3 id="Channel的内部结构"><a href="#Channel的内部结构" class="headerlink" title="Channel的内部结构"></a>Channel的内部结构</h3><p>支持Channel胜任并发场景的是其内部数据结构。本节来探讨缓冲区是<strong>链表</strong>和<strong>数组</strong>的版本。链表版本的定义主要是在<strong>AbstractSendChannel</strong>中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSendChannel</span>&lt;<span class="hljs-type">E</span>&gt; : <span class="hljs-type">SendChannel</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> queue = LockFreeLinkedListHead()<br>    ··· ···<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LockFreeLinkedListHead</strong>本身是一个双向链表的节点，Channel把它收尾相连形成循环链表，这个queue作为哨兵节点，当有新的节点插入时就插入到queue的前面，相当于在整个链表的最后插入元素。该链表节点的关键结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockFreeLinkedListNode</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _next = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed | OpDescriptor</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed</span><br></code></pre></td></tr></table></figure><p><strong>_next</strong> 和 <strong>_prev</strong>表示节点的向前引用和向后引用，其使用atomic包裹仅能进行原子操作。不过CAS操作通常只能修改一个引用，对于需要同时修改前后节点引用的情形是不适用的。当我们在单链表中插入节点时，也会存在并发问题，如下图所示。</p><p><img src="/img/singly_linked_list_concurrently_insert.png" alt="单链表并发插入问题"></p><p>而无锁链表LockFreeLinked的实现是引入一个prev来辅助完成。A被移除时不会像单链表一样直接断开指针， 而是现将A.next和A.prev标记为Removed，指向的节点不变，因此即便同时有另一个线程插入一个节点X，链表同样有机会在后续通过CAS算法实现前后节点引用的修复。具体实现参照LockFreeLinkedListNode在JVM上的实现。</p><p>而对于数组版本，ArrayChannel相对就比较简单了，其内部维护了一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = ReentrantLock()<br><span class="hljs-comment">// 缓冲区大于8时会先分配大小为8的数组，之后再进行扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p>对这个数组的读写操作都会使用可重入锁ReentrantLock进行加锁。</p><h2 id="冷数据流Flow"><a href="#冷数据流Flow" class="headerlink" title="冷数据流Flow"></a>冷数据流Flow</h2><p>我们现在大多数App都使用了RxJava作为异步框架，而RxJava的核心就是响应式编程模型。Flow就是Kotlin协程与响应式编程模型结合的产物。</p><h3 id="认识Flow"><a href="#认识Flow" class="headerlink" title="认识Flow"></a>认识Flow</h3><p>先来使用flow创建发送序列，这里对比一下官方的序列生成器<strong>sequence</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intsSeq = sequence &#123;  <span class="hljs-comment">// 不支持设置协程上下文</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        yield(it)<br>        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 编译报红</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>        delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 可调用外部挂起函数</span><br>    &#125;<br>&#125;<br>intFlow.flowOn(Dispatchers.IO)  <span class="hljs-comment">// 指定在IO线程生成</span><br></code></pre></td></tr></table></figure><p>我们知道，sequence不支持传入协程上下文，因而无法对协程进行线程调度。而受<strong>SequenceScope</strong>的<strong>RestrictsSuspension</strong>注解的影响，其内部也无法调用外部的的挂起函数。这其中其实是有个因果关系的，假设sequence支持调用delay，由于sequence本身不支持调度，所以会导致delay执行后会有切换线程的副作用。而Flow则没有这么多限制了，我们可以内部使用emit发送元素，可调用外部的挂起函数，同时也可以使用flowOn函数进行线程调度。</p><h3 id="Flow的线程切换"><a href="#Flow的线程切换" class="headerlink" title="Flow的线程切换"></a>Flow的线程切换</h3><p>Flow的线程切换使用<strong>Flow.flowOn</strong>方法，这个方法与RxJava的subscribeOn和observeOn切换协程的方式十分类似，下面是对比代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123; e -&gt;<br>        it.onNext(e)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>    it.onComplete()<br>&#125;<br>    .subscribeOn(Schedulers.io())  <span class="hljs-comment">// 第一次有效</span><br>    .subscribeOn(Schedulers.computation())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe &#123;<br>        println(it)  <span class="hljs-comment">// Android主线程</span><br>    &#125;<br><br>flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO) <span class="hljs-comment">// 第一次有效</span><br>    .flowOn(Dispatchers.Default)<br>    .collect &#123; <br>        println(it)  <span class="hljs-comment">// 与所在协程调度器一致</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到flowOn方法与RxJava的subscribeOn方法十分类似，都是会只会影响其之前的代码，而且都是只有第一次调用是有效的，这个其实跟collect或者subscribe的逆序调用执行有关，代码顺序中第一次调用flowOn或者subscribeOn其实是最后才执行，所以它们是有效的，这里不深究了。另外区别是RxJava中可以使用observeOn方法来调度subscribe回调的执行线程，看起来似乎Flow的collect没有类似的调度方法，其实不然，Flow的collect是个挂起函数，其调度线程跟外部的协程调度在哪个线程是一致的。</p><h3 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h3><p>与RxJava类似，Flow的生产总是在消费被调用后才会执行，并且多次调用会多次生产。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO)<br>    .flowOn(Dispatchers.Default)<br><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p>所谓的冷数据流，就是只有消费时才会生产的数据流，这一点与Channel刚好相反。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Flow异常处理比较简单直接，直接调用catch函数即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">flow &#123;<br>    emit(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">&quot;Div 0&quot;</span>)  <span class="hljs-comment">// 抛出一个异常</span><br>&#125;.<span class="hljs-keyword">catch</span> &#123; t: Throwable -&gt;<br>    println(<span class="hljs-string">&quot;caught error : <span class="hljs-variable">$t</span>&quot;</span>)<br>&#125;.onCompletion &#123; <span class="hljs-comment">// Flow完成后回调</span><br>    println(<span class="hljs-string">&quot;onCompletion.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用catch函数捕获flow中抛出的异常，这里需要注意的是catch<strong>只能捕获上游的异常</strong>，如果没有catch，则会在消费时抛出。</p><p><strong>onCompletion</strong>方法的作用类似于RxJava中Subscriber的OnComplete，作为整个Flow完成的回调使用，无论是否存在未捕获的异常都会被调用。</p><h3 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h3><p>前面我们使用了collect来消费Flow的数据，像这种包含消费含义的操作符称为<strong>末端操作符</strong>。Flow的末端操作符大体可以分为两类：</p><ul><li>集合类型转换操作符，包括toList、toSet等。</li><li>聚合操作符，包括将Flow规约到单值的reduce、fold等操作；还有获得单个元素的操作符，包括single、singleOrNull、first等。</li></ul><h3 id="分离Flow的消费和触发"><a href="#分离Flow的消费和触发" class="headerlink" title="分离Flow的消费和触发"></a>分离Flow的消费和触发</h3><p>我们除了可以在collect处消费Flow的元素之外，还可以通过onEach来消费元素，而collect只需要作为触发点就可以。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .onEach &#123; println(it) &#125;  <span class="hljs-comment">// onEach中消费</span><br><br>intFlow.collect()  <span class="hljs-comment">// collect触发生产和消费</span><br></code></pre></td></tr></table></figure><p>另外Flow中还提供了一个launchIn方法指定一个协程作用域，使其消费在指定的协程中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch &#123; intFlow.collect() &#125;<br>intFlow.launchIn(GlobalScope) <span class="hljs-comment">// 两种方法是一样的</span><br></code></pre></td></tr></table></figure><h3 id="Flow的取消"><a href="#Flow的取消" class="headerlink" title="Flow的取消"></a>Flow的取消</h3><p>Flow不存在取消的概念，因为其依托于外部协程的生命周期，所以要想取消一个Flow只需要取消其外部协程即可。</p><h3 id="其他Flow的创建方式"><a href="#其他Flow的创建方式" class="headerlink" title="其他Flow的创建方式"></a>其他Flow的创建方式</h3><p>之前我们使用了flow{…}来创建一个Flow，这种方式的缺点是当中无法随意切换调度器，如果在当中使用调度器会报错，因为emit函数不是线程安全的。如果需要在生成元素时切换调度器可以使用ChannelFlow，通过channelFlow{…}来创建。</p><h3 id="Flow的背压"><a href="#Flow的背压" class="headerlink" title="Flow的背压"></a>Flow的背压</h3><p>只要是响应式编程就会有背压问题，即生产者生产元素的速率远高于消费者的处理速率时，消费者还未处理上一个数据新数据就已经到达的情况。</p><p>为了保证数据不丢失，我们可以为Flow添加缓冲区。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;.buffer() <span class="hljs-comment">// 可以指定容量</span><br></code></pre></td></tr></table></figure><p>不过如果只是单纯添加缓冲，缓冲区迟早也会出现数据积压，只是治标不治本。</p><p>要从根本上解决背压问题，除了直接优化消费者的性能外，还可以采用一些取舍手段。</p><p>第一种是<strong>conflate</strong>。与Channel中的Conflate模式一直，新数据会覆盖老数据，使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .conflate()<br>    .collect &#123;<br>        println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$it</span>&quot;</span>)<br>        delay(<span class="hljs-number">100</span>)<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> collected&quot;</span>)<br>    &#125;<br><br><span class="hljs-comment">// 输出</span><br>Collecting <span class="hljs-number">0</span><br><span class="hljs-number">0</span> collected<br>Collecting <span class="hljs-number">99</span><br><span class="hljs-number">99</span> collected<br></code></pre></td></tr></table></figure><p>上述代码快速发送了100个元素，最后接收到的只有2个。</p><p>第二种是<strong>collectLasted</strong>，作用是只处理最新的数据。看起来似乎与conflate是一样的，其实不然，collectLasted不会进行数据的覆盖，而是在当前数据还未处理完而新的数据来的时候，当前数据的处理逻辑会被取消，转而处理新数据。</p><p>除了collectLasted之外，还有<strong>mapLastest</strong>、<strong>flatMapLatest</strong>等。</p><h3 id="Flow的变换"><a href="#Flow的变换" class="headerlink" title="Flow的变换"></a>Flow的变换</h3><p>Flow与RxJava的Observable一样，可以使用map、flattenConcat等函数来进行变换。</p><h2 id="select表达式"><a href="#select表达式" class="headerlink" title="select表达式"></a>select表达式</h2><p>select在Java NIO里很常见，Kotlin协程中的select用于同时等待多个挂起函数，并可以选择第一个恢复的gaug挂起。</p><h3 id="复用多个await"><a href="#复用多个await" class="headerlink" title="复用多个await"></a>复用多个await</h3><p>假设我们有个常见是分别从本地和网络获取数据，哪个先返回就用哪个，那么如何做到这一点呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromApi</span><span class="hljs-params">(login: <span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    gitHubServiceApi.getUserSuspend(login)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromLocal</span><span class="hljs-params">(login:<span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="hljs-keyword">class</span>.java) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用select来同时启动这两个挂起函数，并最终返回先恢复的那个挂起函数返回的数据，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> localDeferred = getUserFromLocal(login)<br>    <span class="hljs-keyword">val</span> remoteDeferred = getUserFromApi(login)<br><br>    <span class="hljs-keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;<br>        localDeferred.onAwait &#123; Response(it, <span class="hljs-literal">true</span>) &#125;<br>        remoteDeferred.onAwait &#123; Response(it, <span class="hljs-literal">false</span>) &#125;<br>    &#125;<br>    ...<br>&#125;.join()<br></code></pre></td></tr></table></figure><p>我们没有直接调用await，而是使用<strong>Deferred#onAwait</strong>方法在select中注册了回调，select总是会立即调用最先返回的事件的回调。</p><h3 id="复用多个Channel"><a href="#复用多个Channel" class="headerlink" title="复用多个Channel"></a>复用多个Channel</h3><p>对于多个Channel的情况，也比较类似：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">val channels = List(<span class="hljs-number">10</span>) &#123; Channel<span class="hljs-params">&lt;Int&gt;</span>() &#125;<br><br>select<span class="hljs-params">&lt;Int?&gt;</span> &#123;<br>    channels.<span class="hljs-class">forEach </span>&#123; channel -&gt;<br>        channel.<span class="hljs-class">onReceive </span>&#123; it &#125;<br>        <span class="hljs-comment">// OR</span><br>        channel.<span class="hljs-class">onReceiveOrNull </span>&#123; it &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 onReceive，如果Channel被关闭，select会直接抛出异常；而对于 onReceiveOrNull如果遇到Channel被关闭的情况，it的值就是null。</p><h3 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h3><p>如何知道哪些事件可以被select呢？实际上所有能够被select的事件都是SelectClauseN类型，包括：</p><ul><li><p>SelectClause0：对应事件没有返回值，例如join没有返回值，那么onJoin就是SelectClauseN类型。使用时，onJoin的参数是一个无惨函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    job.onJoin &#123; println(<span class="hljs-string">&quot;Join resumed!&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SelectClause1：对应事件有返回值，前面的onAwait和onReceive都是此类情况。</p></li><li><p>SelectClause2：对应事件有返回值，此外还需要一个额外的参数作为回调，例如Channel.onSend有两个参数，第一个表示即将发送的值，第二个是发送成功的回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">List(<span class="hljs-number">100</span>) &#123; element -&gt;<br>    select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>        channels.forEach &#123; channel -&gt;<br>            channel.onSend(element) &#123; sentChannel -&gt;<br>                println(<span class="hljs-string">&quot;send on  <span class="hljs-variable">$sentChannel</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>综上，如果想要确认挂起函数是否支持select，只需要查看其是否存在对应的SelectClauseN类型可回调即可。</p><h3 id="使用Flow实现多路复用"><a href="#使用Flow实现多路复用" class="headerlink" title="使用Flow实现多路复用"></a>使用Flow实现多路复用</h3><p>多数情况下，我们可以通过构造何时的Flow来实现多路复用的效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> login = <span class="hljs-string">&quot;...&quot;</span><br>    listOf(::getUserFromApi, ::getUserFromLocal)  <span class="hljs-comment">// list中存放函数引用</span><br>        .map &#123; function -&gt;<br>            function.call(login)  <span class="hljs-comment">// 调用函数，得到返回值</span><br>        &#125;<br>        .map &#123; deferred -&gt;<br>            flow &#123; emit(deferred.await()) &#125;  <span class="hljs-comment">// 创建Flow，发送deferred.await的返回结果</span><br>        &#125;<br>        .merge() <span class="hljs-comment">// 多个Flow合并成一个Flow</span><br>        .onEach &#123; user -&gt; <span class="hljs-comment">// 使用onEach来消费</span><br>            println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$user</span>&quot;</span>)<br>        &#125;.launchIn(<span class="hljs-keyword">this</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的关键之处在于，我们为每一个deferred都创建了一个单独的Flow，并在Flow内部发送了deferred.await()返回的结果，最后再通过<strong>merge</strong>函数合并成一个Flow来进行处理。</p><p><img src="/img/flow_merge.png" alt="使用merge合并Flow"></p><h2 id="协程的并发工具"><a href="#协程的并发工具" class="headerlink" title="协程的并发工具"></a>协程的并发工具</h2><p>协程框架提供了一些并发安全的工具，包括：</p><ul><li><p><strong>Channel</strong>：并发安全的消息通道。</p></li><li><p><strong>Mutex</strong>：轻量级锁，在获取不到锁时不会阻塞线程而是挂起等待锁的释放。代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> mutex = Mutex()<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        mutex.withLock &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></td></tr></table></figure></li><li><p>Semaphore：轻量级信号量，信号量可以有多个，协程在获取到信号量后即可执行并发操作。当Semaphore的参数为1时，效果等价于Mutex，代码示例如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> semaphore = Semaphore(<span class="hljs-number">1</span>)<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        semaphore.withPermit &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（四）——Kotlin协程框架初探（二）</title>
    <link href="/2021/02/21/dd192d66/"/>
    <url>/2021/02/21/dd192d66/</url>
    
    <content type="html"><![CDATA[<p>本篇继续探讨协程的取消、异常处理以及作用域问题。</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><p>协程的取消本质是协作式的取消，这点跟线程的中断一致，除了自身状态置为取消外，也需要协程体的执行逻辑能够检查状态的变化来响应取消。</p><h3 id="完善协程的取消逻辑"><a href="#完善协程的取消逻辑" class="headerlink" title="完善协程的取消逻辑"></a>完善协程的取消逻辑</h3><p>我们的Job目前还有两个函数空着没有实现，分别是cancle和invokeOnCancel。后者的实现与doOnCompleted类似，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CancellationHandlerDisposable(<span class="hljs-keyword">this</span>, onCancel)<br><br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Cancelling)?.let &#123; onCancel() &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellationHandlerDisposable</span></span>(<span class="hljs-keyword">val</span> job: Job, <span class="hljs-keyword">val</span> onCancel: OnCancel) : Disposable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cancel函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> preState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Cancelling()<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preState <span class="hljs-keyword">is</span> CoroutineState.Incomplete) &#123;<br>        preState.notifyCancellation()<br>        preState.clear()<br>    &#125;<br>    parentCancelDisposable?.disposable()<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里使用了getAndUpdate来流转状态，也就是说我们拿到的是旧状态，旧状态如果是Incomplete则一定发生了状态流转，调用notifyCancellation来通知取消事件。</p><h3 id="支持取消的挂起函数"><a href="#支持取消的挂起函数" class="headerlink" title="支持取消的挂起函数"></a>支持取消的挂起函数</h3><p>通常来讲，一个发生了事实上挂起的挂起函数如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nonCancellableFunction</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br><br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br><br>    completableFuture.thenApply &#123;<br>        continuation.resume(it)<br>    &#125;.exceptionally &#123;<br>        continuation.resumeWithException(it)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，及时所在的协程被取消，我们也无法取消内部的异步任务CompletableFuture。为了能够取消内部的异步任务，我们需要Continuation提供一个取消状态和回调，在协程取消，回调被通知时取消掉CompletableFuture，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancellableFunction</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br>    continuation.invokeOnCancellation &#123;<br>        completableFuture.cancel(<span class="hljs-literal">true</span>)<br>    &#125;<br>   ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个<strong>suspendCancellableCoroutine</strong>要如何实现呢？我们可以参考官方框架中的<strong>suspendCoroutine</strong>实现来做一点修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-meta">@InlineOnly</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutine</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;<br>    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;<br>        <span class="hljs-keyword">val</span> safe = SafeContinuation(c.intercepted())<br>        block(safe)<br>        safe.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>suspendCoroutineUninterceptedOrReturn的参数是一个函数，这个函数有一个参数Continuation，实际上就是我们前面文章说的编译后生成的匿名内部类的实例。SafeContinuation的作用是确保传入的Continuation对象的恢复调用只被执行一次。如何确保的呢？当block(safe)执行过程中调用了Continuation的恢复调用时，safe.getOrThrow就会获取到结果，而不是<strong>COROUTINE_SUSPENDED</strong>，这样协程就不会真正挂起了。</p><p>那么我们要对 Continuation进行改造使其支持取消的话，就要替换到SafeContinuation了，即需要实现一下效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: T = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> cancellable = CancellableContinuation(continuation.intercepted())<br>    block(cancellable)<br>    cancellable.getResult()<br>&#125;<br></code></pre></td></tr></table></figure><p>关键就是CancellableContinuation的实现了。</p><h3 id="CancellableContinuation的实现"><a href="#CancellableContinuation的实现" class="headerlink" title="CancellableContinuation的实现"></a>CancellableContinuation的实现</h3><p>CancellableContinuation需要具备以下能力：</p><ul><li>支持通过invokeOnCancellation注册取消回调</li><li>支持监听对应协程的取消状态</li><li>具备SafeContinuation的功能</li></ul><p>这样的话，CancellableContinuation必然是有状态的，同样我们先给出状态的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelState</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> InComplete : CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelHandler</span></span>(<span class="hljs-keyword">val</span> onCancel: OnCancel): CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CancelState()<br>    <span class="hljs-keyword">object</span> Cancelled : CancelState()<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelDecision</span> </span>&#123;<br>    UNDECIDED, SUSPENDED, RESUMED<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的状态定义跟协程的状态时一致的，这里不多说。CancelDecision枚举用于标记对应的挂起函数是否同步返回了。</p><p>CancellableContinuation需要包装一个Continuation，这里我们直接使用接口代理即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CancelState&gt;(CancelState.InComplete)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> decision = AtomicReference(CancelDecision.UNDECIDED)<br><br>    <span class="hljs-keyword">val</span> isCompleted: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            CancelState.InComplete,<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; <span class="hljs-literal">true</span><br>        &#125;<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>先看invokeOnCancellation的实现，如果当前是Incomplete状态，那么就可以注册回调，如果是Cancelled状态就直接调用回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancellation</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            CancelState.InComplete -&gt; CancelState.CancelHandler(onCancel)<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;It&#x27;s prohibited to register multiple handlers.&quot;</span>)<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newState <span class="hljs-keyword">is</span> CancelState.Cancelled) &#123;<br>        onCancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来尝试去监听对应协程的取消事件，可以通过协程上下文来获取对应协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installCancelHandler</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">val</span> parent = continuation.context[Job] ?: <span class="hljs-keyword">return</span> <span class="hljs-comment">// 获取协程</span><br>    parent.invokeOnCancel &#123;<br>        doCancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>取消回调中通过doCancel方法来完成状态的流转。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> prevState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>            CancelState.InComplete -&gt; &#123;<br>                CancelState.Cancelled<br>            &#125;<br>            CancelState.Cancelled,<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (prevState <span class="hljs-keyword">is</span> CancelState.CancelHandler) &#123;<br>        prevState.onCancel()<br>        resumeWithException(CancellationException(<span class="hljs-string">&quot;Cancelled.&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于两种未完成的状态，流转为Cancelled，如果刘赚钱有回调注册，就调用回调通知取消事件。</p><p>由于挂起点发生了真正的挂起后注册回调才有意义，因此无需急于注册取消回调，在getResult中注册即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    installCancelHandler()  <span class="hljs-comment">// 注册取消回调</span><br>    <span class="hljs-keyword">if</span>(decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.SUSPENDED))<br>        <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>        CancelState.InComplete -&gt; COROUTINE_SUSPENDED<br>        CancelState.Cancelled -&gt; <span class="hljs-keyword">throw</span> CancellationException(<span class="hljs-string">&quot;Continuation is cancelled.&quot;</span>)<br>        <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>            (currentState <span class="hljs-keyword">as</span> CancelState.Complete&lt;T&gt;).let &#123;<br>                it.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: it.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先注册了协程的取消回调，接着通过CAS操作判断当前decision是否为<strong>UNDECIDED</strong>，如果是UNDECIDED则表示结果还未就绪，将其设置为<strong>SUSPENDED</strong>并返回挂起标志位<strong>COROUTINE_SUSPENDED</strong>。否则decision只可能为RESUMED，即挂起函数没有真正挂起并且结果已经可以获取，那么就会在Complete分支返回结果，如果未完成则会返回挂起标志COROUTINE_SUSPENDED。</p><p>接着是resumeWith的实现。该函数被调用表示挂起函数恢复执行，此时如果dicision为<strong>UNDECIDED</strong>，表示挂起函数同步返回了，后面通过getResult来获取结果，否则只能为dicision只能为<strong>SUSPENDED</strong>，即已挂起。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> &#123;<br>        decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是UNDECIDED，则不用考虑并发安全问题</span><br>            state.<span class="hljs-keyword">set</span>(CancelState.Complete(result.getOrNull(), result.exceptionOrNull()))<br>        &#125;<br>        decision.compareAndSet(CancelDecision.SUSPENDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是SUSPENDED，使用updateAndGet来更新状态并获取结果</span><br>            state.updateAndGet &#123; prev -&gt;<br>                <span class="hljs-keyword">when</span> (prev) &#123;<br>                    <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed.&quot;</span>)<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        CancelState.Complete(result.getOrNull(), result.exceptionOrNull())<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复delegate</span><br>            continuation.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CancellableContinuation的状态转移如下图。</p><p><img src="/img/cancellation_state_transfer.png" alt="CancellableContinuation的状态转移"></p><h3 id="改造挂起函数"><a href="#改造挂起函数" class="headerlink" title="改造挂起函数"></a>改造挂起函数</h3><p>我们之前定义的挂起函数都是使用suspendCoroutine函数来实现挂起，若要响应协程的取消，需要将其替换成上面实现好的suspendCancellableCoroutine。</p><p>以delay函数为例，改造后的delay函数如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(time: <span class="hljs-type">Long</span>, unit: <span class="hljs-type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    suspendCancellableCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> future = executor.schedule(&#123; continuation.resume(<span class="hljs-built_in">Unit</span>) &#125;, time, unit)<br>        continuation.invokeOnCancellation &#123; future.cancel(<span class="hljs-literal">true</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程的异常处理"><a href="#协程的异常处理" class="headerlink" title="协程的异常处理"></a>协程的异常处理</h2><p>异常处理是异步程序需要解决的关键问题。</p><h3 id="处理协程的未捕获异常"><a href="#处理协程的未捕获异常" class="headerlink" title="处理协程的未捕获异常"></a>处理协程的未捕获异常</h3><p>先定义一个异常处理器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>要处理协程的未捕获异常，我们需要在AbstractCoroutine中定义一个子类可见的函数，提供给子类复写，返回值为true表示异常已处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>我们以AbstractCoroutine子类StandaloneCoroutine为例，StandaloneCoroutine由launch启动，协会本身没有返回结果。我们虚妄它能够在遇到未捕获异常时，调用自身的异常处理器进行处理，如果没有异常处理器就抛出给所在线程的uncaughtExceptionHandler来处理，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">super</span>.handleJobException(e)<br>    context[CoroutineExceptionHandler]?.handleException(context, e) ?: Thread.currentThread()<br>        .let &#123; it.uncaughtExceptionHandler.uncaughtException(it, e) &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取消异常的特别处理"><a href="#取消异常的特别处理" class="headerlink" title="取消异常的特别处理"></a>取消异常的特别处理</h3><p>协程的取消类似于线程的中断，取消时通过抛出取消异常来实现对取消状态的相应，因此上节的未捕获异常不应该包含取消异常。只需要定义一个函数来分发异常即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span>(e)&#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; handleJobException(e)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着在resumeWith中添加异常处理逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    ··· ···<br>    (newState <span class="hljs-keyword">as</span> CoroutineState.Complete&lt;T&gt;).exception?.let(<span class="hljs-keyword">this</span>::tryHandleException)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程的作用域"><a href="#协程的作用域" class="headerlink" title="协程的作用域"></a>协程的作用域</h2><p>协程作用域用来描述协程的作用范围，作用域既有约束作用又可以提供额外的能力。</p><h3 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h3><p>官方框架中作用域包括以下三种：</p><ol><li><strong>顶级作用域</strong>：没有父协程的协程所在的作用域。</li><li><strong>协同作用域</strong>：协程中启动新的协程，新协程未所在协程的子协程，这种情况下子协程所在的作用域默认为协同作用域。子协程抛出的未捕获异常都将传递给父协程处理，同时父协程也会被取消。</li><li><strong>主从作用域</strong>：与协程作用域在协程的父子关系一致，区别是子协程的未捕获异常将不会向上传递给父协程。</li></ol><p>父子协程之间还存在以下规则：</p><ul><li>父协程被取消，所有子协程都会被取消。</li><li>父协程需要等待子协程执行完毕才会最终进入完成状态。</li><li>子协程会继承父协程的协程上下文中的元素，如果自身有相同Key的成员，将会覆盖该Key。</li></ul><p>前面几篇文章我们已经熟悉了如何去创建一个作用域了，通常我们会将协程的启动函数定义在作用域中，同时让协程的描述类来实现作用域充当Receiver的角色，基于这两点来改造下launch函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义为CoroutineScope的扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion, completion) <span class="hljs-comment">// 带Receiver的方式启动协程</span><br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="建立父子关系"><a href="#建立父子关系" class="headerlink" title="建立父子关系"></a>建立父子关系</h3><p>前面说了，父协程取消之后，子协程也需要被取消，因此我们要对AbstractCoroutine稍加改造，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> parentJob = context[Job]<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> parentCancelDisposable : Disposable? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">init</span> &#123;<br>    ··· ···<br>    parentCancelDisposable = parentJob?.invokeOnCancel &#123; <br>        cancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过协程上下文来获取父协程，如果父协程存在，那么就需要注册一个取消回调，当父协程取消时取消掉当前协程。</p><h3 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h3><p>我们对launch函数进行改造之后，需要一个作用域来调用launch函数才能启动一个协程，但作用域又是在创建协程过程中产生的。针对这个问题，我们需要一个特殊的作用域，这个作用域不需要依赖父作用域来产生，这个作用域就叫做<strong>顶级作用域</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> scopeContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br><br>GlobalScope.launch&#123;<br>  ··· ···<br>&#125;<br></code></pre></td></tr></table></figure><p>由于协程描述类AbstractCoroutine本身实现了CoroutineScope，因此由GlobalScope.launch启动的协程体内部我们可以直接创建新的子协程。</p><h3 id="实现异常传播"><a href="#实现异常传播" class="headerlink" title="实现异常传播"></a>实现异常传播</h3><p>接下来考虑一下子协程如何将异常向上传递。按照现有的实现，我们已经将该异常处理传递到tryHandleException中，对于非取消异常的情况都交给了handleJobException来处理。按照协同作用域的设计，协程遇到未捕获的异常时应当优先向上传播，如果没有父协程才自行处理。因此我们添加一个函数<strong>handleChildException</strong>用于接收子协程的异常，改造一下tryHandleException：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    cancel()  <span class="hljs-comment">// 取消父协程</span><br>    <span class="hljs-keyword">return</span> tryHandleException(e) <span class="hljs-comment">// 继续向上传递或者自己处理</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span> (e) &#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; (parentJob <span class="hljs-keyword">as</span>? AbstractCoroutine&lt;*&gt;)?.handleChildException(e) <span class="hljs-comment">// 交给父协程处理</span><br>        ?.takeIf &#123; it &#125;<br>        ?: handleJobException(e)  <span class="hljs-comment">// 没有父协程 自行处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注释已经很完善了，当出现未捕获异常时，先尝试调用父协程的handleChildException来处理，否则自行处理。父协程也优先调用父协程的父协程来处理。</p><h3 id="主从作用域"><a href="#主从作用域" class="headerlink" title="主从作用域"></a>主从作用域</h3><p>协同作用域的效果就是父子协程绑定，父取消则子取消，子异常则父连坐。而主从作用域则可以避免子协程出现异常而导致父协程取消的情况。</p><p>我们只需要将上面的<strong>handleChildException</strong>方法返回false即可避免子协程将异常传递给父协程，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(context: CoroutineContext, continuation: Continuation&lt;T&gt;) :<br>    ScopeCoroutine&lt;T&gt;(context, continuation) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也很容易去创建这样一个作用域，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">supervisorScope</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: R = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> coroutine = SupervisorCoroutine(continuation.context, continuation)<br>    block.startCoroutine(coroutine, coroutine)<br>&#125;<br></code></pre></td></tr></table></figure><p>主从作用域的应用场景多见于子协程为独立对等的任务实体的情况，例如Android平台的Jetpack开发包中ViewModel内置的viewModelScope就是主从作用域实现。</p><h3 id="完整的异常处理流程"><a href="#完整的异常处理流程" class="headerlink" title="完整的异常处理流程"></a>完整的异常处理流程</h3><p>引入作用域后完整的异常处理流程如下如所示。</p><p><img src="/img/complete_exception_handle.png" alt="完整的异常处理流程"></p><h3 id="父协程等待子协程完成"><a href="#父协程等待子协程完成" class="headerlink" title="父协程等待子协程完成"></a>父协程等待子协程完成</h3><p>作用域要求父协程必须等待子协程执行完才可以进入完成状态，因此父协程的resumeWith执行完成后需要检查子协程是否完成，未完成则需要注册完成回调，等待所有子协程状态流转为完成状态父协程才能触发完成回调并且流转为完成态。我们只需要新增一个等待的状态即可，状态流转如下所示。</p><p><img src="/img/scope_state_transfer.png" alt="完整的异常处理流程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——Kotlin协程框架初探（一）</title>
    <link href="/2021/02/16/b912c613/"/>
    <url>/2021/02/16/b912c613/</url>
    
    <content type="html"><![CDATA[<p>前面四篇文章我们了解了如何使用<strong>createCoroutine</strong>和<strong>startCoroutine</strong>这两个API来创建和启动简单协程，并且可以使用它们来构造复合协程。但客观的说，这两个API并不太适合直接在业务开发中使用，所以Kotlin协程为开发者提供了一些更贴近业务的复合协程API，即官方协程框架<a href="https://github.com/Kotlin/kotlinx.coroutines"><strong>kotlinx.coroutines</strong></a>。后面几篇文章我们就来尝试窥探一下这个庞大的框架的一角。</p><h2 id="协程的描述"><a href="#协程的描述" class="headerlink" title="协程的描述"></a>协程的描述</h2><p>对于协程的创建，官方框架中根据不同的目的提供了不同的构造器。</p><h3 id="协程的描述类"><a href="#协程的描述类" class="headerlink" title="协程的描述类"></a>协程的描述类</h3><p>Java中提供了线程的Java描述类Thread，通过调用<strong>Thread#start</strong>方法我们就可以通知系统启动一个线程，我们也知道<strong>Thread#run</strong>方法即为线程的执行代码，同时Thread也提供了类型join、interrupt、isAlive等方法来方便我们操作线程。类似的，我们也需要这样一个类来描述协程，按照官方框架的做法把它命名为Job，API设计如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;<br>        <span class="hljs-keyword">get</span>() = Job<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断协程是否扔在执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程取消回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程完成回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnCompelete</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取消协程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 与[Thread.join]类似，挂起外部协程直到当前协程完成</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>我们对协程的状态进行封装，让其状态管理更加简便。主要是<strong>未完成</strong>、<strong>已取消</strong>、<strong>已完成</strong>这三种状态。状态的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Incomplete</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cancelling</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CoroutineState()<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步解释下这三种状态：</p><ul><li>Incomplete：协程启动后立即进入该状态，直到完成或者被取消。</li><li>Cancelling：协程执行中被取消后进入该状态。进入该状态后，要等待协程体内部的挂起函数调用相应取消，相应后协程成功被取消或者抛出CancellationException取消，最终会流转为Complete状态。</li><li>Complete：协程执行完成进入该状态。</li></ul><h3 id="支持回调的状态"><a href="#支持回调的状态" class="headerlink" title="支持回调的状态"></a>支持回调的状态</h3><p>注册回调时，需要根据当前状态的不同采取不同的处理方式，回调注册的操作也必须是原子操作，否则会有状态不一致问题。跟上篇文章相同，我们在状态流转时采用元子类来处理原子操作，比加锁性能会有较大提升。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-comment">// 返回新状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用updateAndGet，在Lambda表达式中返回新的状态，内部会采用CAS操作来更新新状态，如果更新不成功，Lambda表达式会重复调用。</p><p>用于存放回调的数据结构也必须支持并发安全。这里我们提供一个递归列表，它具有不变形，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposableList</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> Nil : DisposableList()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span></span>(<br>        <span class="hljs-keyword">val</span> head: Disposable,<br>        <span class="hljs-keyword">val</span> tail: DisposableList<br>    ) : DisposableList()<br>&#125;<br></code></pre></td></tr></table></figure><p>通过递归来实现对该列表的访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: DisposableList &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>        DisposableList.Nil -&gt; <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (head == disposable) tail<br>            <span class="hljs-keyword">else</span> DisposableList.Cons(head, tail.remove(disposable))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">forEach</span><span class="hljs-params">(action: (<span class="hljs-type">Disposable</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    DisposableList.Nil -&gt; <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>        action(<span class="hljs-keyword">this</span>.head)<br>        <span class="hljs-keyword">this</span>.tail.forEach(action)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Disposable&gt;</span> DisposableList.<span class="hljs-title">loopOn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> =<br>    forEach &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> T -&gt; action(it)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们把这个不变列表添加到状态中，在状态发生变化时，上一个状态的回调可以传递给新状态，确保已注册的回调不丢失。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> disposableList: DisposableList = DisposableList.Nil<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拿到上一个状态的所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">from</span><span class="hljs-params">(state: <span class="hljs-type">CoroutineState</span>)</span></span>: CoroutineState &#123;<br>        disposableList = state.disposableList<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">with</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = DisposableList.Cons(disposable, disposableList)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">without</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = <span class="hljs-keyword">this</span>.disposableList.remove(disposable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清除所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>        disposableList = DisposableList.Nil<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程的初步实现"><a href="#协程的初步实现" class="headerlink" title="协程的初步实现"></a>协程的初步实现</h3><p>定义好状态后，接下来要为状态机输入事件，定义一个Job的抽象子类如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> context: CoroutineContext) : Job, Continuation&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子状态机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br><br>    <span class="hljs-keyword">val</span> isCompleted<br>        <span class="hljs-keyword">get</span>() = state.<span class="hljs-keyword">get</span>() <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;,<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">true</span><br>        &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        state.<span class="hljs-keyword">set</span>(CoroutineState.Incomplete()) <span class="hljs-comment">// 初始化为Incomplete状态</span><br>        <span class="hljs-keyword">this</span>.context = context + <span class="hljs-keyword">this</span><br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractCoroutine同时实现了<strong>Continuation</strong>接口，这个我们已经熟悉了，是为了能够传入作为completion在启动时传入协程，以监听协程的完成事件。</p><h2 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h2><p>我们在协程的描述中定义好了协程应该具备哪些能力，接下来要考虑如何封装协程的创建。</p><h3 id="无返回值的launch"><a href="#无返回值的launch" class="headerlink" title="无返回值的launch"></a>无返回值的launch</h3><p>如果协程的返回值是为Unit，那我们可以认为它<strong>无返回值</strong>，对于这种协程只需要启动它即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">launch &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>launch的实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">launch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(context: CoroutineContext) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(context)<br></code></pre></td></tr></table></figure><h3 id="实现invokeOnCompletion"><a href="#实现invokeOnCompletion" class="headerlink" title="实现invokeOnCompletion"></a>实现invokeOnCompletion</h3><p>用launch创建的协程可以立即运行起来，如果我们知道它什么时候结束，可以通过注册OnComplete回调来做到这一点。我们需要做两件事：</p><ol><li>将回调注册到协程中。</li><li>在协程完成时通知回调。</li></ol><p>Job接口中定义的OnComplete实际只是一个函数，声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> OnComplete = () -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>这里并没有携带任何参数，因为协程执行完成的结果我们有更好的方式去获取，这里的OnComplete仅仅用于通知协程执行结束。但对于协程内部来说，我们需要获取结果来进行状态流转，所以这里定义一个doOnCompleted函数在注册获取结果的回调，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnComplete</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">return</span> doOnCompleted &#123; _ -&gt; onComplete() &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnCompleted</span><span class="hljs-params">(block: (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CompletionHandlerDisposable(<span class="hljs-keyword">this</span>, block)<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Complete&lt;T&gt;)?.let &#123;<br>        block(<br>            <span class="hljs-keyword">when</span> &#123;<br>                it.value != <span class="hljs-literal">null</span> -&gt; Result.success(it.value)<br>                it.exception != <span class="hljs-literal">null</span> -&gt; Result.failure(it.exception)<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Won&#x27;t happen.&quot;</span>)<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompletionHandlerDisposable</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> job: Job,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> OnComplete: (Result&lt;T&gt;) -&gt; <span class="hljs-built_in">Unit</span><br>) : Disposable &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，<strong>除了Complete状态时我们可以直接回调OnComplete，其它状态的流转我们都需要构造一个新的状态对象来确保并发安全</strong>。</p><p>注册回调的过程分为以下三步：</p><ol><li>构造一个CompletionHandlerDisposable对象。它有一个disposable函数，用于将对应的回调移除。</li><li>检查状态，并将回调添加到状态中。</li><li>在状态流转成功后，获得最终的状态，如果是Complete状态则立即回调OnComplete。</li></ol><p>Job的remove函数还未实现，来看看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现与doOnCompleted刚好相反。</p><p>接下来思考下如何通知回调。想一下如何知道协程执行完毕呢，没错就是当<strong>AbstractCoroutine#resumeWith</strong>函数调用时，协程执行完毕。因此我们只需要在AbstractCoroutine#resumeWith函数中将协程流转为完成状态，并且通知此前注册的完成回调即可。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Complete(result.getOrNull(), result.exceptionOrNull()).from(prev)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed!&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知完成回调</span><br>    newState.notifyCompletion(result)<br>    newState.clear()<br>&#125;<br><br>[CoroutineState.kt]<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">notifyCompletion</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.disposableList.loopOn&lt;CompletionHandlerDisposable&lt;T&gt;&gt; &#123;<br>        it.onComplete(result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里Cancelling会流转为Complete的关键是，协程被取消后并不会立即停止执行，而是要等待内部的挂起点相应，这个我们后面再详细讨论。</p><h3 id="实现join"><a href="#实现join" class="headerlink" title="实现join"></a>实现join</h3><p>join是一个挂起函数，它被调用时会有两种情况：</p><ul><li>被等待的协程已经完成，join不会挂起而是立即返回。</li><li>被等待的协程未完成，join立即挂起，直到协程完成。</li></ul><p>由于上面已经实现了完成回调，因此join只需要判断是否挂起，以及在挂起后被等待协程完成时回调中使用resume恢复挂起即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-keyword">return</span> joinSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt;<br>        continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有返回值的async"><a href="#有返回值的async" class="headerlink" title="有返回值的async"></a>有返回值的async</h3><p>现在我们已经知道如何启动协程并等待协程执行完成，不过很多时候我们更想拿到协程的返回值，因此我们基于Job再定义一个接口Deferred如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deferred</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Job &#123;</span></span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T<br>&#125;<br></code></pre></td></tr></table></figure><p>这里多了一个泛型参数T，T表示返回值类型，通过它的await函数也可以拿到这个返回值，await的作用主要是：</p><ol><li>在协程已经执行完成时，立即返回协程的结果，或者异常。</li><li>如果协程未完成，则挂起直到当前协程执行完成。</li></ol><p>该方法与join类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (currentState) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; awaitSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>            currentState.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: (currentState.value <span class="hljs-keyword">as</span> T)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt; continuation.resumeWith(result) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来可以写出有返回值的async函数的实现了，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Deferred&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> completion = DeferredCoroutine&lt;T&gt;(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">val</span> deferred = async &#123;<br>    getValue()<br>&#125;<br><span class="hljs-keyword">val</span> result = deferred.await()<br>println(result)<br></code></pre></td></tr></table></figure><p>这与我们前几篇实现的async/await仅有细节的差别。</p><h2 id="协程的调度"><a href="#协程的调度" class="headerlink" title="协程的调度"></a>协程的调度</h2><p>我们已经大致实现了一个比较完整的复合协程，不过还要一个问题，如何指定协程的运行线程，或者说如何对协程进行线程调度？</p><h3 id="协程的调度位置"><a href="#协程的调度位置" class="headerlink" title="协程的调度位置"></a>协程的调度位置</h3><p>协程在挂起点位置可能需要进行调度，为什么说可能，前几篇文章已经说过了，只有发生了事实上的异步行为时，才需要调度。我们再来回顾一下什么是事实上的异步：</p><ul><li>挂起点对应的挂起函数内部切换了线程，并在该线程内部调用Continuation#resume来恢复。</li><li>挂起函数内部通过事件循环机制将Continuation的恢复调用转移到了新的线程调用栈上，例如Android平台上的Handler#post。</li><li>挂起函数内部将Continuation实例白村，在后续某个时间再恢复调用。</li></ul><p>综上所述，只有恢复和挂起不在同一个函数调用栈执行的情况，我们才有机会实现调度，而实现调度需要使用协程的<strong>拦截器</strong>。</p><h3 id="协程的调度器设计"><a href="#协程的调度器设计" class="headerlink" title="协程的调度器设计"></a>协程的调度器设计</h3><p><strong>调度的本质是利用拦截器将协程的恢复调用转移到一个特定的线程上</strong>，由此可以写出下列代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContext</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatcherContinuation(continuation, dispatcher)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> delegate: Continuation&lt;T&gt;, <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = delegate.context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        dispatcher.dispatch &#123;<br>            delegate.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于线程池的调度器"><a href="#基于线程池的调度器" class="headerlink" title="基于线程池的调度器"></a>基于线程池的调度器</h3><p>我们最常见的调度场景就是制定代码的执行线程，而在Java平台上使用线程池是比较好的做法，官方调度器也是如此。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DefaultDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadGroup = ThreadGroup(<span class="hljs-string">&quot;DefaultDispatcher&quot;</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadIndex = AtomicInteger(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executor =<br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>) &#123; runnable -&gt;<br>            Thread(<br>                threadGroup,<br>                runnable,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;threadGroup.name&#125;</span>-worker-<span class="hljs-subst">$&#123;threadIndex.getAndDecrement()&#125;</span>&quot;</span><br>            ).apply &#123; isDaemon = <span class="hljs-literal">true</span> &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        executor.submit(block)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-keyword">val</span> Default <span class="hljs-keyword">by</span> lazy &#123;<br>        DispatcherContext(DefaultDispatcher)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们创建了一个CPU密集型线程池，并且线程全部设置为守护线程。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">launch(Dispatchers.Default) &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">2000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>println(1)和println(2)都将运行在Default调度器对应线程上。</p><h3 id="基于UI事件循环的调度器"><a href="#基于UI事件循环的调度器" class="headerlink" title="基于UI事件循环的调度器"></a>基于UI事件循环的调度器</h3><p>Android开发者比较关心如何将协程调度到主线程上。这个比较简单，直接使用Handler#post即可将协程体发送到主线程消息循环中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidMainDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = Handler(Looper.getMainLooper())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——复合协程</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将基于简单协程实现几种复合协程。</p><h2 id="序列生成器"><a href="#序列生成器" class="headerlink" title="序列生成器"></a>序列生成器</h2><h3 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h3><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums: (<span class="hljs-built_in">Int</span>) -&gt; Generator&lt;<span class="hljs-built_in">Int</span>&gt; = generator &#123; start: <span class="hljs-built_in">Int</span> -&gt;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) &#123;<br>        yield(start + i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> gen: Generator&lt;<span class="hljs-built_in">Int</span>&gt; = nums(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> gen) &#123;<br>    println(j)<br>&#125;<br><br><span class="hljs-comment">// 运行结果 </span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt; = GeneratorIterator(block, parameter)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建一个序列生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReady</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : State()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ready</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, <span class="hljs-keyword">val</span> nextValue: T) : State()<br>    <span class="hljs-keyword">object</span> Done : State()<br>&#125;<br></code></pre></td></tr></table></figure><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取下一个元素</span><br><span class="hljs-comment"> * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程</span><br><span class="hljs-comment"> * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; &#123;<br>            resume()<br>            <span class="hljs-keyword">return</span> next()<br>        &#125;<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;<br>            state = State.NotReady(currentState.continuation)<br>            (currentState <span class="hljs-keyword">as</span> State.Ready&lt;T&gt;).nextValue<br>        &#125;<br>        State.Done -&gt; &#123;<br>            <span class="hljs-keyword">throw</span>  IndexOutOfBoundsException(<span class="hljs-string">&quot;No value left.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用suspendCoroutine挂起当前协程</span><br><span class="hljs-comment"> * 并将当前状态流转为[State.Ready]状态，返回value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    state = <span class="hljs-keyword">when</span> (state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;cannot yield while ready.&quot;</span>)<br>        <span class="hljs-keyword">is</span> State.Done -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;cannot yield while done.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    resume()<br>    <span class="hljs-keyword">return</span> state != State.Done<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动或者恢复协程</span><br><span class="hljs-comment"> * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建协程的completion回调</span><br><span class="hljs-comment"> * 协程执行完成后回调</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    state = State.Done<br>    println(result.getOrThrow())<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; block(parameter) &#125;<br>    <span class="hljs-comment">// 带Receiver的方式创建协程</span><br>    <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 初始化状态</span><br>    state = State.NotReady(start)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorIterator</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : GeneratorScope&lt;T&gt;, Iterator&lt;T&gt;, Continuation&lt;Any?&gt;<br></code></pre></td></tr></table></figure><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h3 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h3><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sequence = sequence &#123;<br>        yield(<span class="hljs-number">1</span>)<br>        yield(<span class="hljs-number">2</span>)<br>        yield(<span class="hljs-number">3</span>)<br>        yieldAll(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>&#125;<br><br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">in</span> sequence) &#123;<br>    println(num)<br>&#125;<br></code></pre></td></tr></table></figure><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fibonacci = sequence &#123;<br>    yield(<span class="hljs-number">1L</span>)<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">var</span> next = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        yield(next)<br>        next += current<br>        current = next - current<br>    &#125;<br>&#125;<br><br>fibonacci.take(<span class="hljs-number">10</span>).forEach(::println) <span class="hljs-comment">// 使用take(10)获取前10个元素</span><br></code></pre></td></tr></table></figure><h2 id="Promise-模型"><a href="#Promise-模型" class="headerlink" title="Promise 模型"></a>Promise 模型</h2><p>Promise模型又叫async/await，是目前最常见也最容易理解和上手的协程实现。</p><p>async/await的设计可以在async函数内部对复合Promise协议的异步回调进行await，使得异步逻辑变成了同步代码。这是目前主流的协程实现，它的关键在于将函数分为两种：</p><ul><li>普通函数：只能够调用普通函数，不存在协程的挂起和恢复逻辑。</li><li>async函数：既可以调用普通函数，也可以调用async函数，且可以将回调通过await同步化。</li></ul><p>async和wait各司其职，分别实现协程的挂起和恢复的逻辑，上手几乎没有成本。</p><h3 id="仿JavaScript的async-await实现"><a href="#仿JavaScript的async-await实现" class="headerlink" title="仿JavaScript的async/await实现"></a>仿JavaScript的async/await实现</h3><p>利用kotlin协程实现一个async/await的复合协程，效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">async &#123;<br>    <span class="hljs-keyword">val</span> user = await &#123; gitHubApi.getUserCallback(<span class="hljs-string">&quot;sukaidev&quot;</span>) &#125;<br>    println(user)<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>User(userName=sukaidev, blog=https:<span class="hljs-comment">//www.sukaidev.top, location=GuangZhou,China, bio=Focus on Jetpack)</span><br></code></pre></td></tr></table></figure><p>先思考下async如何实现。async接收一个函数作为参数，这个函数即协程体，必然是个挂起函数。async创建成功后协程即启动，并且内部可以使用await方法来挂起协程。async函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">AsyncScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> completion = AsyncCoroutine(context)<br>    block.startCoroutine(completion, completion)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCoroutine</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext) :<br>    Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, AsyncScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        result.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于async启动的协程不需要返回值，所以作为completion存在的AsyncCoroutine没有泛型参数。</p><p>await函数定义在AsyncScope中，使得它可以在async构造的协程中调用，它主要的作用就是将网络请求的回调转为协程，使用suspendCoroutine实现即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncScope</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">await</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> call = block()<br>        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                    response.body()?.let(continuation::resume)<br>                        ?: continuation.resumeWithException(NullPointerException())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                continuation.resumeWithException(HttpException(response))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                continuation.resumeWithException(t)<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>async/await的状态比较简单，只有挂起以及被封装的回调完成状态，状态之间的流转由await单独来完成，因此不需要额外的状态机实现。当我们引入了协程的取消处理、异常处理等逻辑后，状态机的存在就至关重要了。</p><h2 id="Luna风格的协程API"><a href="#Luna风格的协程API" class="headerlink" title="Luna风格的协程API"></a>Luna风格的协程API</h2><p>我们在使用Kotlin协程时，总是说创建了一个协程，不像创建线程会有一个对应的类或者对象。在之前的复合协程中，我们总是把协程的状态机封装在协程的完成回调Continuation实例competition中，由于这个实例提供了各种的协程能力，所以我们一般它当做复合协程本身。</p><p>使用Luna API创建协程与创建线程一样，只需提供一个函数，返回一个协程的控制类来控制协程的执行，我们可以基于Kotlin的简单协程来实现这样的一套API。</p><h3 id="非对称API实现"><a href="#非对称API实现" class="headerlink" title="非对称API实现"></a>非对称API实现</h3><p>非对称协程的主要特点就是在协程挂起时，协程控制权返回给了调用者，我们先看下实现效果，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer = Coroutine.create&lt;<span class="hljs-built_in">Unit</span>, <span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        println(<span class="hljs-string">&quot;send <span class="hljs-variable">$i</span>&quot;</span>)<br>        yield(i)<br>    &#125;<br>    <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = Coroutine.create&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Unit</span>&gt; &#123; parameter: <span class="hljs-built_in">Int</span> -&gt;<br>    println(<span class="hljs-string">&quot;start <span class="hljs-variable">$parameter</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">val</span> value = yield(<span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;receive <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive) &#123;<br>    <span class="hljs-keyword">val</span> result = producer.resume(<span class="hljs-built_in">Unit</span>)<br>    consumer.resume(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Coroutine的伴生对象来创建协程，参数为协程体，协程体的参数类型和返回值类型由泛型参数指定。create的返回值用来控制协程的执行，结合前面几篇文章，我们知道这个返回值其实就是封装了协程状态机的实例，与SafeContinuation的作用十分类似，我们也习惯于将这个实例作为协程的完成回调，即competition。yield函数类似于序列生成器中的yield的作用，将当前协程挂起并将它的参数作为协程这一次resume调用的返回值。</p><p>状态机的状态设计是关键点，有如下几个状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Created</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yielded</span>&lt;<span class="hljs-type">P</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;P&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resumed</span>&lt;<span class="hljs-type">R</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;R&gt;) : Status()<br>    <span class="hljs-keyword">object</span> Dead : Status()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Created：</strong>协程处于刚刚被创建状态，需要等待resume函数的调用来启动协程。</li><li><strong>Yielded：</strong>协程内部调用yield函数后挂起，泛型参数P表示协程的参数类型。</li><li><strong>Resumed：</strong>协程外部调用resume函数之后协程恢复执行，泛型参数R表示协程的返回值类型。</li><li><strong>Dead：</strong>表示协程已经执行完毕。</li></ul><p>状态之间的转移如下所示。</p><p><img src="/img/state_transfer_02.png" alt="状态流转图"></p><p>创建一个CoroutineScope来约束yield的调用范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span>&lt;<span class="hljs-type">P, R</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">val</span> parameter: P?   <span class="hljs-comment">// 协程体启动时的参数</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Coroutine的对象需要返回给调用者，所以我们这里不能让Coroutine来直接实现CoroutineScope，而是在内部创建了一个CoroutineScope的匿名内部类。协程描述类的部分代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coroutine</span>&lt;<span class="hljs-type">P, R</span>&gt; <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.(P) -&gt; R<br>) : Continuation&lt;R&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P, R&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>&lt;<span class="hljs-type">P</span>, R&gt;.(P)</span></span> -&gt; R<br>        ): Coroutine&lt;P, R&gt; &#123;<br>            <span class="hljs-keyword">return</span> Coroutine(context, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = <span class="hljs-keyword">object</span> : CoroutineScope&lt;P, R&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> parameter: P? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>          ... ...<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: AtomicReference&lt;Status&gt;<br>  <br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>      <span class="hljs-keyword">get</span>() = status.<span class="hljs-keyword">get</span>() != Status.Dead<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.() -&gt; R = &#123; block(parameter!!) &#125;<br>        <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(scope, <span class="hljs-keyword">this</span>)<br>        status = AtomicReference(Status.Created(start))<br>    &#125;<br>  ... ....<br>&#125;<br></code></pre></td></tr></table></figure><p>代码结构与之前的序列生成器的迭代器类似，不过有两点区别：</p><ol><li>提供了一个工厂方法create函数，用于手动创建Coroutine对象，同时返回该对象，使得外部可以控制Coroutine对象的恢复逻辑。</li><li>状态机status我们使用了AtomicReference<Status>，这是为了确保状态机的流转在多线程情况下仍然能够保证原子性。</li></ol><p>我们再来看下yield的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)  <span class="hljs-comment">// 恢复外部协程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>yield函数使用<strong>suspendCoroutine</strong>来挂起函数，这个我们已经很熟悉了。与序列生成器的yield实现不同的是，这里yield是有返回值的，为P类型也就是协程的入参类型，这使得yield同时也可以作为消费者来使用。</p><p>status.getAndUpdate接收一个参数为上一个状态，并要求返回新的状态，这个函数可能会被执行多次。当previousStatus确实是Resumed，就调用它的continuation.resume来<strong>恢复此前恢复执行当前协程的协程</strong>，这里有点绕，其实就是恢复外部协程的执行，外部协程指我们创建producer和consumer的协程。外部协程为什么会挂起跟我们的resume函数实现有关，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;  <span class="hljs-comment">// 挂起外部协程</span><br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; &#123;<br>                scope.parameter = value<br>                Status.Resumed(continuation)<br>            &#125;<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; Status.Resumed(continuation)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already resumed!&quot;</span>)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (previousStatus) &#123;  <span class="hljs-comment">// 恢复当前协程</span><br>        <span class="hljs-keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>        <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="hljs-keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当外部调用resume恢复该协程时，当前状态可能为：</p><ul><li>Created，协程只是创建，并未启动。</li><li>Yielded，协程已执行处于挂起状态。</li></ul><p>resume函数的作用是挂起外部协程，并且启动或恢复当前协程的执行。外部协程挂起后，我们将其continuation实例存入到状态机中，当当前协程yield函数被调用时，又会将外部协程恢复，使得外部协程可以继续执行后续工作，例如调用另一个协程的resume函数。文字说起来可能比较抽象，这里画了一个时序图，如下。</p><p><img src="/img/asymmetric_api.png" alt="非对称API时序图"></p><p>最后就是resumeWith的实现了，它的调用表示该协程已经执行完毕，需要将状态流转为State.Dead，同时不要忘记恢复外部协程执行，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Dead<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Lua风格的非对称协程API完成。</p><h3 id="对称API实现"><a href="#对称API实现" class="headerlink" title="对称API实现"></a>对称API实现</h3><p>对称协程意味着协会可以任意、平等地传递调度权。在传递过程过，调度权转出的协程需要提供目标协程的对象及参数，目标协程应处于挂起状态等待接收调度权，中间应当有一个控制中心来协助完成调度权的转移。控制中心需要具备以下能力：</p><ul><li>在当前协程挂起时接收调度权。</li><li>根据目标协程对象来完成调度权的最终转移。</li></ul><p>这个控制中心显然是一个可以恢复（当前协程挂起）和挂起（传递调度权给目标协程）的协程，实际上我们之前的非对称API中的外部协程已经具备了一些控制中心的能力，我们只需要对其进行改造即可。效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SymCoroutines &#123;<br>    <span class="hljs-keyword">val</span> coroutine0: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; params: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-0 <span class="hljs-variable">$params</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine2, <span class="hljs-number">0</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(SymCoroutine.main, <span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine1: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-1 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> result = transfer(coroutine0, <span class="hljs-number">1</span>)<br>        println(<span class="hljs-string">&quot;coroutine-1 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine2: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-2 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine1, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(coroutine0, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 2 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br>SymCoroutine.main &#123;<br>    println(<span class="hljs-string">&quot;main 0&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="hljs-number">3</span>)<br>    println(<span class="hljs-string">&quot;main end <span class="hljs-variable">$result</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用<strong>SymCoroutine.create</strong>创建了多个协程，并且使用<strong>SymCoroutine.main</strong>创建了一个外部协程，这个外部协程就是控制中心，后文简称为 Main协程。Main协程通过<strong>transfer</strong>函数将调度权转移给coroutine2，从而开始了对称协程的调度权转移过程。</p><p><img src="/img/sym_coroutine_sequence_diagram.png" alt="调度权转移时序图"></p><p>与之前一样，我们定义一个作用域接口来提供transfer函数，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，泛型参数T为对称协程的参数类型，而transfer函数的泛型参数P表示目标协程的参数类型，对称协程自身的定义决定了它不存在返回值，这点与非对称协程不同。</p><p>接下来就是协程描述类SymCoroutine以及它的create和main函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> main: SymCoroutine&lt;Any?&gt;<br><br>        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">Any</span>?&gt;.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span> &#123;<br>            SymCoroutine&lt;Any?&gt; &#123;<br>                block()<br>            &#125;.also &#123;<br>                main = it<br>            &#125;.start(<span class="hljs-built_in">Unit</span>)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: SymCoroutine&lt;T&gt; = SymCoroutine(context, block)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        ... ...<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> isMain: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span> == main<br>    ... ... <br>&#125;<br></code></pre></td></tr></table></figure><p>main函数的作用是创建Main协程，同时会将其赋值给伴生对象属性main，方便其他协程将调度权归还给控制中心。</p><p>接下来我们思考下当前协程如何将调度权转出。<strong>由于当前协程本质上是由Main协程启动的协程，因此只要调用内部的非对称协程的yield函数将自身挂起，调度权自然就交回到了Main协程手中</strong>。Main协程只需要读取它自己的resume的返回值即可得到目标协程对象及参数。因此yield的参数类型定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameter</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="hljs-keyword">val</span> value: T)<br></code></pre></td></tr></table></figure><p>SymCoroutin内部的非对称协程的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    ... ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coroutine = Coroutine.create&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;<br>        Parameter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>, <span class="hljs-keyword">suspend</span> &#123;<br>            block(body, it)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) <span class="hljs-built_in">Unit</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>        &#125;() <span class="hljs-keyword">as</span> T)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        coroutine.resume(value)<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于内部的非对称协程而言，yield函数的参数类型**Parameter<T>**自然就是它的返回值类型，因此我们看到携程体内构造了一个Parameter的实例。不过我们在传入Parameter参数的时候，应传入目标协程和目标协程的参数，但这里我们传入了this，这是为什么呢？因为这是协程执行完后的最后一行代码，由于对称协程在执行完成之前必须交出调度权，所以这段代码只会被特权协程执行。第二个参数也是如此，创建了一个Lambda表达式并且理解调用了它，并在其中执行了block触发协程体的执行，普通的对称协程在block内部就会通过调用transfer交出调度权。</p><p>接下来是最关键的transfer函数的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">tailrec</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transferInner</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">            value: <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) &#123; <span class="hljs-comment">// Main协程在转移调度权</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (symCoroutine.isMain) &#123;<br>                    value <span class="hljs-keyword">as</span> T  <span class="hljs-comment">// ... ③</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="hljs-keyword">as</span> P)  <span class="hljs-comment">// ... ①</span><br>                    transferInner(parameter.coroutine, parameter.value)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 对称协程转移调度权到其他协程或者Main协程</span><br>                coroutine.run &#123;<br>                    <span class="hljs-keyword">return</span> yield(Parameter(symCoroutine, value <span class="hljs-keyword">as</span> P))  <span class="hljs-comment">// ... ②</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T &#123;<br>            <span class="hljs-keyword">return</span> transferInner(symCoroutine, value)<br>        &#125;<br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们按照之前代码的执行逻辑来分析一下transfer的调用逻辑。</p><ul><li>程序开始执行时，调度权最开始在特权协程手中，调用transfer将调度权转给coroutine2，transferInner入参symCoroutine为coroutine2，在①处调用coroutine2的resume挂起Main协程，coroutine2开始执行。</li><li>接下来coroutine2调用transfer函数转给coroutine1时，先将调度权交出，实际上就是在②处调用yield将自己挂起，此时接收调度权的Main协程在①处的resume函数返回，parameter中携带的其实就是coroutine1和它的参数。</li><li>此时Main协程中递归调用transferInner并再次进入①处挂起自己，由于coroutine1尚未启动，因此直接开始执行，直到调用transfer转给coroutine0。</li><li>最终，在coroutine()中将调度权归还给Main协程，transferInner落入③处分支直接返回。</li></ul><p>至此，基于非对称协程API实现的对称协程API原理分析完毕。</p><h2 id="复合协程的实现模式"><a href="#复合协程的实现模式" class="headerlink" title="复合协程的实现模式"></a>复合协程的实现模式</h2><p>结合本篇几个案例的实现，我们可以把<strong>复合协程实现模式</strong>归纳如下。</p><ul><li><strong>协程的构造器</strong>。我们总是需要一套更好更简便的API来创建协程，例如async{ … }或者Coroutine.create{ … }。</li><li><strong>协程的返回值</strong>。协程可以有返回值，这一点主要是由协程完成时对completion的调用来保证的。</li><li><strong>协程的状态机</strong>。在Kotlin协程的基础设施中，协程本身已经存在创建、执行、挂起、完成等状态了，我们通常需要对这些状态进行管理以控制协程的执行逻辑。状态流转过程在并发环境下需要考虑并发安全问题，我们可以在状态流转时通过加锁来确保这一点，也可以采用更高效的CAS算法来确保状态流转的原子性。</li><li><strong>协程的作用域</strong>。作用域主要用作协程体的Receiver，从而令协程体能够方便地获得协程自身的信息或者调用协程体专属的函数（例如yield）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念与原理</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p><strong>Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现</strong>。不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br> SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></td></tr></table></figure><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)<br>    <span class="hljs-string">&quot;return value.&quot;</span><br>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><br><br><span class="hljs-comment">// 控制台输出：</span><br>Coroutine Start.<br>Coroutine End : Success(<span class="hljs-keyword">return</span> value.)<br></code></pre></td></tr></table></figure><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br> createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)<br></code></pre></td></tr></table></figure><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br></code></pre></td></tr></table></figure><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(value.toString())<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)<br>        print(<span class="hljs-number">1000</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        hashCode(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们<strong>main</strong>函数可以直接被声明为suspend：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.result = result<br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    continuation.resume(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即连续传递样式变换。CPS是一种编程风格，用来将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者，这就将它的程序流程显式的暴露给程序员。而CPS变换就是将原本不是CPS风格的代码转变为CPS风格，通常由编译器来对代码进行优化，<strong>而Kotlin协程能够采用同步的方式书写异步代码的原理正是由于编译器使用了CPS变换</strong>。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend</strong>函数发现，<strong>notSuspend</strong>函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，就是<strong>CPS变换</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));<br>   Continuation continuation = (Continuation)var4;<br>   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;<br>   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;<br>   Companion var10 = Result.Companion;<br>   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;<br>   continuation.resumeWith(Result.constructor-impl(var8));<br>   Object var10000 = var4.getOrThrow();<br>   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>      DebugProbesKt.probeCoroutineSuspended($completion);<br>   &#125;<br>   <span class="hljs-keyword">return</span> var10000;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span><br>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;<br>        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;<br>        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span><br>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception<br>        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">launch &#123;<br>    <span class="hljs-keyword">val</span> deferred = async &#123;<br>        <span class="hljs-comment">// 发起了一个网络请求</span><br>        ......<br>    &#125;<br>    <span class="hljs-comment">// 做了一些操作</span><br>    ......<br>    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span><br>    <span class="hljs-comment">// 后续的一些操作</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br></code></pre></td></tr></table></figure><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span><br>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span><br></code></pre></td></tr></table></figure><p>我们来看下协程上下文中的元素类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element<br></code></pre></td></tr></table></figure><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :<br>    AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)<br>coroutineContext += CoroutineExceptionHandler&#123;<br>    <span class="hljs-comment">//  ... ...</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        println(context[CoroutineName]?.name)<br>        result.onFailure &#123;<br>            context[CoroutineExceptionHandler]?.onError(it)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :<br>    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br></code></pre></td></tr></table></figure><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));<br></code></pre></td></tr></table></figure><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></td></tr></table></figure><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识总结</title>
    <link href="/2021/01/15/b3287aa2/"/>
    <url>/2021/01/15/b3287aa2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图片源自本人两年前校招时写的计算机网络脑图</p></blockquote><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="计算机网络"></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2020/12/22/789195ba/"/>
    <url>/2020/12/22/789195ba/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口可以解决子结构中求最值问题，例如：</p><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76.最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></li><li><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a></li></ul><p>解决滑动窗口问题包含几个步骤：</p><ol><li>确定窗口大小</li><li>移动右指针使得窗口最大，更新结果</li><li>移动左指针缩小窗口，使得窗口保持最大，更新结果</li></ol><p>要理解滑动窗口不难，难点在于如何正确的把所有细节都写出来，以<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/"> 无重复字符的最长子串</a>为例：</p><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><p>这类问题是找求最大的窗口大小，难度不高，不过要注意是<strong>不含重复字符</strong>的，因此我们可以一个HashSet来实时存储当前窗口中的无重复字符。</p><p>何时移动右指针增大窗口？当HashSet中不存在当前字符时，增大窗口。</p><p>何时移动左指针缩小窗口？当HashSet中存在当前字符时，缩小窗口。</p><p>每一次遍历，我们都需要更新最大窗口的值，遍历完之后得到的最大窗口值即为结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(right);<br><br>            <span class="hljs-keyword">if</span> (!set.contains(c)) &#123;<br>                set.add(c);<br>                right++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 将left指针指向的字符移出Set中</span><br>                set.remove(s.charAt(left));<br>                left++;<br>            &#125;<br><br>            maxLen = Math.max(maxLen, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>一般看到有序就要考虑二分，通常不会直接让你写二分查找，大部分都是变形题。</p><h3 id="正常的二分查找"><a href="#正常的二分查找" class="headerlink" title="正常的二分查找"></a>正常的二分查找</h3><p>二分查找的原理很简单，但细节很多，这里有几个需要注意的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 注意</span><br><br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果把右边界定为<code>数组长度 - 1</code>，那么循环的进入条件就是 <code>left &lt;= right</code>。</p><p>对于mid的算法，使用<code>left + (right - left) / 2</code>的方式可以防止<code>left + right</code>可能溢出的问题，当然如果题目给出的数据范围是不可能溢出的话正常写就行 。</p><h3 id="求左右边界"><a href="#求左右边界" class="headerlink" title="求左右边界"></a>求左右边界</h3><p>一般来说算法中不会直接让我们直接套二分查找，而是要求我们利用二分查找来寻找重复数据的左右边界。</p><p>对于左边界，只需要对上面的代码一些小改动即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearchLeftBound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left == nums.length || nums[left] != target) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">return</span> left;  <span class="hljs-comment">// 注意</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了寻找左边界，当我们发现mid对应的数等于target时，我们不能直接返回，而是缩小搜索区域为mid左边，即<code>right = mid - 1</code>。</p><p>这里有几点需要特别注意：</p><ol><li><p>第一点，搜索结束时，应该返回left而不是right。</p><p>为什么返回left，只需要考虑最后一次循环即可快速理解。最后一次循环时，left、mid、right三者相等，此时将会进入第一个if分支中，<code>right = mid - 1</code>，使得right会小于我们所求的边界，因此left才是最终答案。</p></li><li><p>第二点，如果搜索不到对应的target时，需要考虑越界问题。</p><p>如果target不在待搜索数组中，有三种情况：</p><ul><li>target小于数组中的所有数</li><li>target小于数组中的部分数，大于数组中的另一部分数</li><li>target大于数组中的所有数</li></ul><p>对于第一种和第二种情况，当循环结束时，left都不会越界，因此只需要考虑nums[left]与target是否相等就知道target存不存在数组中。</p><p>对于第三种情况，经过最后一次循环时，left将会被赋值为mid + 1，导致最终left为数组长度，此时使用nums[left]将会有越界问题，所以需要单独判断。</p><p>最终通过<code>left == nums.length || nums[left] != target)</code>这个表达式我们可以判断出数组中是否是不存在target的。</p></li></ol><p>对于右边界，代码与左边界是类似的，如下所示，这里不再赘述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearchRightBound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 注意</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法即<strong>带有撤销操作的DFS算法</strong>，用于处理需要求出所有可能的结果的问题。</p><p>算法基本逃不出这个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><p>难点在于如何去除重复项，即剪枝。</p><p>剪枝要考虑清除题目要求的不可重复项，例如组合2中要求不出现重复的数字，而子集2中要求不能出现重复的子集。</p><p>对于无法确定的要先画出决策树，再考虑应该减去同一层重复的还是同一路径重复的。</p><p>对于同一路径去重，即组合2问题，只需要对源数据进行排序后，判断前后数字是否相同即可。</p><p>对于同一层去重，即子集2问题，需要引入一个visited的boolean标志位数组，选择当前数字后，在撤销选择时将其visited[i]标记为true，表示此层使用此数字完成了一此回溯选择，同一层的重复数字遇到此标记位为true时就可以不用继续了，因为必定重复。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BinarySearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio金丝雀版更新  原生View Binding要来了？</title>
    <link href="/2019/09/12/d497a59/"/>
    <url>/2019/09/12/d497a59/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天Android Studio推特放出了<a href="https://androidstudio.googleblog.com/2019/09/android-studio-36-canary-11-available.html">Android Studio 3.6 Canary 11的更新日志</a>，终于是在IDE层面支持了<em>View Binding</em>。</p><p>View Binding大家肯定都用过，常用的有Data Binding、ButterKnife和Kotlinx，一般来说Java项目中ButterKnife用的多，kotlin项目的话kotlinx synthetic用起来更快、更方便。那这个IDE支持的<em>View Binding</em>有何优势呢？待会说，先看看它怎么使用吧。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先需要在模块中启用View Binding，这个跟Data Binding类似，毕竟都是官方支持的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    viewBinding &#123;<br>        enabled = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话编译器就会为这个module中的每个xml文件生成一个<em>binding class</em>，例如<em>activity_main.xml文</em>件会自动生成<em>ActivityMainBinding.java</em>文件。每个<em>binding class</em>会持有根视图的引用，并且会为每个View生成一个ID（除非这个View没有设置ID）。</p><p>例如我写一个<em>result_profile.xml</em>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">...</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/name&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">android:cropToPadding</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/rounded_button&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>IDE会自动生成一个叫<em>ResultProfileBinding.java</em>的文件，文件中有两个属性：名为name的TextView和名为button的Button，ImageView因为没有设置ID所以不会引用到文件中。除此之外还提供一个getRoot()方法，返回根视图，这里的话就返回LineaLayout对象。</p><p>有人说那我有的xml文件不需要用、不想用怎么办呢？也行，让tools：viewBindingIgnore = true就行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;LinearLayout<br>        ...<br>        tools:viewBindingIgnore=&quot;true&quot; &gt;<br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来就是要到Activity中去使用它了，<em>setContentView</em>中肯定不能直接使用xml文件Id了，应该传入一个根视图。要获取这个根视图的话，首先要拿到<em>ResultProfileBinding</em>类的对象，我们可以通过其静态方法*inflate()*来获取对象。这样的话代码就应该这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ResultProfileBinding<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    binding = ResultProfileBinding.inflate(layoutInflater)<br>    setContentView(binding.root)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以这样访问视图控件了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">binding.name.text = viewModel.name<br>binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;<br></code></pre></td></tr></table></figure><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>ResultProfileBinding类由Android Studio自动帮我们生成，通过编译器的全局搜索功能我们可以在<code>app/build/generated/data_binding_base_class_source_out/debug/out</code>+我们的Activity对应包名路径+databinding目录下找到此文件。</p><p>生成的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Generated by view binder compiler. Do not edit!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResultProfileBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewBinding</span> </span>&#123;<br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinearLayout rootView;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Button button;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TextView name;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ResultProfileBinding</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LinearLayout rootView, <span class="hljs-meta">@NonNull</span> Button button,</span></span><br><span class="hljs-function"><span class="hljs-params">                               <span class="hljs-meta">@NonNull</span> TextView name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.rootView = rootView;<br>    <span class="hljs-keyword">this</span>.button = button;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> LinearLayout <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> rootView;<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResultProfileBinding <span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> inflate(inflater, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResultProfileBinding <span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater,</span></span><br><span class="hljs-function"><span class="hljs-params">                                             <span class="hljs-meta">@Nullable</span> ViewGroup parent, <span class="hljs-keyword">boolean</span> attachToParent)</span> </span>&#123;<br>    View root = inflater.inflate(R.layout.result_profile, parent, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">if</span> (attachToParent) &#123;<br>      parent.addView(root);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bind(root);<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResultProfileBinding <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View rootView)</span> </span>&#123;<br>    <span class="hljs-comment">// The body of this method is generated in a way you would not otherwise write.</span><br>    <span class="hljs-comment">// This is done to optimize the compiled bytecode for size and performance.</span><br>    <span class="hljs-keyword">int</span> id;<br>    missingId: &#123;<br>      id = R.id.button;<br>      Button button = rootView.findViewById(id);<br>      <span class="hljs-keyword">if</span> (button == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">break</span> missingId;<br>      &#125;<br><br>      id = R.id.name;<br>      TextView name = rootView.findViewById(id);<br>      <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">break</span> missingId;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResultProfileBinding((LinearLayout) rootView, button, name);<br>    &#125;<br>    String missingId = rootView.getResources().getResourceName(id);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;Missing required view with ID: &quot;</span>.concat(missingId));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到原理还是很简单的，生成的这个类内部持有了我们在xml中定义的所有节点View，并且也是通过调用findViewById来获取这个实例。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>有人问：Java我有ButterKnife，Kotlin我有Kotlin Synthetic，这东西现在放出来有啥用？</p><p>这东西对比findViewById，优势肯定是很明显的，首先控件都是从自动生成的java文件中取出的，不会因为写错了R文件ID而出现空指针问题。其次类型也是确定的不会有类型转换异常。</p><p>但对于ButterKnife和kotlinx用习惯的人来说，看起来这新功能并不如前两者。但事实呢？来看一张图：</p><p><img src="/img/2019092000250621-1024x576.jpeg" alt="如何优雅的访问视图控件"></p><p>上图列出了访问视图控件的五种方式的对比。除了最后一个，其他四种方式或多或少都有自己的劣势。例如ButterKnife是基于注解和注解处理器来实现视图绑定的，它的劣势就在于无法保证编译期安全，写错一个视图控件的R文件Id就可能导致程序崩溃，一旦项目大了注解写的多了，就会极大的影响项目构建速度。而kotlinx虽然不会影响项目构建，但也无法保证编译期安全，有时候相同ID的控件多了导包都要看半天，生怕导错了包然后运行报错。</p><p>对于 why kotlin doesn’t better 这个问题，Jake Wharton是这么回答的：</p><p><img src="/img/2019091308523152.png" alt="Jake Wharton推特截图"></p><p>看来巨佬跟我一样烦kotlinx的导包问题，嗯，总算找到点共识。</p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View Binding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android性能优化之OOM</title>
    <link href="/2019/03/20/f803055f/"/>
    <url>/2019/03/20/f803055f/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OOM全称为Out Of Memory，内存溢出，指的是请求的内存超过了剩余内存的容量。在Android中，App中已经使用的内存加上新申请的内存大于Android系统分配给App进程的最大内存时，就会发生OOM，导致程序直接崩溃，使得我们的App的用户体验非常糟糕。因此如何避免OOM就成了Android内存优化中比较关键的一点， 这篇文章就是关于内存优化中如何避免OOM的总结性概要文章。</p><h2 id="5R法则"><a href="#5R法则" class="headerlink" title="5R法则"></a>5R法则</h2><p>在网上看了一篇腾讯大佬写的关于Android中的内存优化的文章，文章中根据他的经验总结出了一个内存优化的“5R法则”，如下所示：</p><p><img src="/img/20190407220651.png" alt="内存优化5R法则"></p><p>这个5R法则标明了内存优化需要注意的5种情况，下面就这5种情况来进行分析。</p><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>缩减，就是要减小对象的内存占用，避免OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。</p><h3 id="使用更小的资源图片"><a href="#使用更小的资源图片" class="headerlink" title="使用更小的资源图片"></a>使用更小的资源图片</h3><p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p><h3 id="资源按需加载"><a href="#资源按需加载" class="headerlink" title="资源按需加载"></a>资源按需加载</h3><p>使用按需加载的方式来加载资源是内存优化中很重要的一环，例如我们常用的ListView中，当数据量特别大的时候，保证只有显示区域的item被加载到内存中，移出显示区域的item被销毁是非常重要的。</p><h3 id="对Bitmap对象进行内存优化"><a href="#对Bitmap对象进行内存优化" class="headerlink" title="对Bitmap对象进行内存优化"></a>对Bitmap对象进行内存优化</h3><p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p><ul><li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li><li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li></ul><h3 id="避免使用枚举类型"><a href="#避免使用枚举类型" class="headerlink" title="避免使用枚举类型"></a>避免使用枚举类型</h3><p>枚举是我比较喜欢使用的一种类型，枚举的使用方便、可读性强，无需考虑线程安全的问题而且还能自定义方法。不得不说枚举确实好用，但是如果你看过枚举类型字节码反编译出的代码的话，就知道其实枚举就是一个普通的类。那么我们使用枚举类型的时候需要将枚举类加载到内存中，这个过程至少会占用24字节的内存。而我们使用 public static final int 来定义一个整型的话，它只占用整型的4字节内存。Android官方提到过一句话：</p><blockquote><p><strong>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</strong> </p></blockquote><p>因此我们应该避免在Android里面使用到枚举。</p><h3 id="使用更加轻量级的数据结构"><a href="#使用更加轻量级的数据结构" class="headerlink" title="使用更加轻量级的数据结构"></a>使用更加轻量级的数据结构</h3><p>在Java中，当需要存放键值对象的时候，我们通常会想到HashMap。HashMap底层数据结构基于哈希数组和单链表，并且在必要的时候单链表可以转化为红黑树来提高性能，这就使得HashMap在插入和查询时的性能表现相当优异。</p><p>但是HashMap也有不少的缺点，例如当Key或Value为基本类型时，由于Java中泛型的特点，使得HashMap在存储过程中需要频繁的进行装箱和拆箱操作，非常浪费性能。而在Android中使用最大的问题就是HashMap的内存浪费问题。HashMap默认数组大小为16，若为空，那么这个HashMap就占用了16个Entry对象的内存。HashMap每次扩容都是2倍，当数据越来越多的时候，每次扩若所产生的unused对象就越多，导致HashMap占用大量内存。</p><p>为了解决HashMap自动装拆箱的问题，Android提供了性能更强的<a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/android/util/SparseArray.java">SparseArray</a>。SparseArray将Map中的key值直接规定为整型，这样的话直接就解决了Key为Integer时的装拆箱开销。SparseArray内部采用两个数组分别存储key和Value的形式存储数组，同时为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据。</p><p>关于稀疏数组中的压缩，借用网上的一张图片：</p><p><img src="/img/sparse_array.png" alt="稀疏数组的压缩策略"></p><p>从图中可以看出，SparseArray使用两个数组的方式，由原来的63缩小18，极大的减少了内存的开销。</p><p>而为了解决HashMap更占内存的弊端，Android也提供了内存效率更高的<a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/android/util/ArrayMap.java">ArrayMap</a>。ArrayMap的内部也是使用两个数组进行工作的，其中一个数组记录Key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value，那么首先我们就想到ArrayMap是有序的。ArrayMap支持缩容，当元素被移除时以0.5被进行缩容。同时其内部维护了一些小数组，当元素特别少的场景时，无需额外申请内存空间，直接复用这些小数组，采用池的思想解决了内存浪费的问题。</p><p>ArrayMap在查找时，会先计算输入key的hash值，然后对key数组进行二分查找寻找对应的index，然后通过这个index可以直接访问到另一个数组中需要的键值对（当然也会存在hash碰撞）。这跟HashMap不同，HashMap在获取到key的hash值后，先要获取通过(hash&amp;n-1)的方式到对应数组中的index，然后再进行链表或者红黑树的遍历。这样来看ArrayMap的查找性能虽然不差，但还是远不如HashMap的，而且当数据越多，hash冲突越频繁时，其性能还会大幅度下降。</p><p>那么在删除和插入的时候呢？其实这个问题不用想就知道是肯定比HashMap差远了，毕竟使用的是两个数组。Google官方这样描述ArrayMap的删除和插入操作：</p><p><img src="/img/arraymap_deletion_and_insertion.png" alt="ArrayMap的删除和插入"></p><p>很明显，ArrayMap的插入与删除的效率是不够高的，它其实是在内存和效率之间做的一个平衡。但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。</p><p>那么如何使用“合适”的数据结构呢？这里我画了一张图：</p><p><img src="/img/%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="使用合适的数据结构"></p><p>按照图中的方法去选择合适的数据结构，避免在代码阶段就隐藏了OOM的风险。</p><h2 id="Reuse"><a href="#Reuse" class="headerlink" title="Reuse"></a>Reuse</h2><p>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p><h3 id="复用系统自带资源"><a href="#复用系统自带资源" class="headerlink" title="复用系统自带资源"></a>复用系统自带资源</h3><p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p><h3 id="在ListView-GridView中对ConvertView复用"><a href="#在ListView-GridView中对ConvertView复用" class="headerlink" title="在ListView/GridView中对ConvertView复用"></a>在ListView/GridView中对ConvertView复用</h3><p><img src="/img/1916953-acf949d643ece848.jpeg" alt="复用ConvertView"></p><h3 id="Bitmap对象的缓存和复用"><a href="#Bitmap对象的缓存和复用" class="headerlink" title="Bitmap对象的缓存和复用"></a>Bitmap对象的缓存和复用</h3><p>在ListView与RecyclerView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap，也就是我们常说的图片三级缓存。</p><h3 id="避免在onDraw方法里面创建对象"><a href="#避免在onDraw方法里面创建对象" class="headerlink" title="避免在onDraw方法里面创建对象"></a>避免在onDraw方法里面创建对象</h3><p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p><h2 id="Recycle"><a href="#Recycle" class="headerlink" title="Recycle"></a>Recycle</h2><p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p><p>监控内存泄漏常用的工具有LeakCanary、MAT和Android 3.0 新出的 Android Profiler。</p><h3 id="注意Activity的泄露"><a href="#注意Activity的泄露" class="headerlink" title="注意Activity的泄露"></a>注意Activity的泄露</h3><p>通常来说，Activity的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏： </p><h4 id="内部类引用导致Activity的泄露"><a href="#内部类引用导致Activity的泄露" class="headerlink" title="内部类引用导致Activity的泄露"></a>内部类引用导致Activity的泄露</h4><p>最典型的就是Handler了，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。 </p><h4 id="Activity-Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。"><a href="#Activity-Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。" class="headerlink" title="Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。"></a>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</h4><p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意。我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p><h3 id="Context引发的内存泄漏"><a href="#Context引发的内存泄漏" class="headerlink" title="Context引发的内存泄漏"></a>Context引发的内存泄漏</h3><p>典型的Context引发的内存泄漏就是单例中传入了Activity Context，使得Activity被引用到全局的单例中无法得到回收。</p><p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p><h3 id="集合类中的内存泄漏"><a href="#集合类中的内存泄漏" class="headerlink" title="集合类中的内存泄漏"></a>集合类中的内存泄漏</h3><p>有时候，我们为了提高对象的复用性把某些对象放到缓存容器中，可是如果这些对象没有及时从容器中清除，也是有可能导致内存泄漏的。</p><h3 id="及时回收临时的Bitmap对象"><a href="#及时回收临时的Bitmap对象" class="headerlink" title="及时回收临时的Bitmap对象"></a>及时回收临时的Bitmap对象</h3><p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p><h3 id="及时注销监听器"><a href="#及时注销监听器" class="headerlink" title="及时注销监听器"></a>及时注销监听器</h3><p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。</p><h3 id="及时关闭资源对象"><a href="#及时关闭资源对象" class="headerlink" title="及时关闭资源对象"></a>及时关闭资源对象</h3><p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p><h2 id="Refactor"><a href="#Refactor" class="headerlink" title="Refactor"></a>Refactor</h2><p>当我们需要对整个App进行内存优化分析时，需要在不同的角度思考如何对代码重构达到优化的效果。</p><h3 id="使用优化后的数据结构"><a href="#使用优化后的数据结构" class="headerlink" title="使用优化后的数据结构"></a>使用优化后的数据结构</h3><p>这个上面已经说过了，根据需求选择ArrayMap和SparseArray来代替HashMap，同时也有注意尽量少使用枚举类型。</p><h3 id="优化布局，减少内存消耗"><a href="#优化布局，减少内存消耗" class="headerlink" title="优化布局，减少内存消耗"></a>优化布局，减少内存消耗</h3><p>过渡绘制的界面不仅非常占内存，还会导致界面卡顿，考虑使用merge、include、viewStub来优化布局。</p><h2 id="Revalue"><a href="#Revalue" class="headerlink" title="Revalue"></a>Revalue</h2><p>重审是我们思考对App中使用一些技术是否有必要、是否权衡了利弊的过程。</p><h3 id="谨慎使用large-heap"><a href="#谨慎使用large-heap" class="headerlink" title="谨慎使用large heap"></a>谨慎使用large heap</h3><p>Android设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的Heap限制阈值。你可以通过调用 getMemoryClass() 来获取应用的可用Heap大小。在一些特殊的情景下，你可以通过在 manifest 的 application 标签下添加 largetHeap = true 的属性来为应用声明一个更大的heap空间。然后，你可以通过 getLargeMemoryClass() 来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行 getMemoryClass() 来检查实际获取到的heap大小。 </p><h3 id="谨慎使用多进程"><a href="#谨慎使用多进程" class="headerlink" title="谨慎使用多进程"></a>谨慎使用多进程</h3><p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p><p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p><h3 id="谨慎使用第三方库"><a href="#谨慎使用第三方库" class="headerlink" title="谨慎使用第三方库"></a>谨慎使用第三方库</h3><p>很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p><h3 id="选择合适的文件夹存放资源文件"><a href="#选择合适的文件夹存放资源文件" class="headerlink" title="选择合适的文件夹存放资源文件"></a>选择合适的文件夹存放资源文件</h3><p>我们知道 hdpi/xhdpi/xxhdpi 等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100x100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200x200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>关于更多性能优化的知识推荐Google官方系列视频《Android Performance Patterns》，地址贴在下方。</p><p>Youtube：<a href="https://www.youtube.com/watch?v=qk5F6Bxqhr4&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android Performance Patterns 系列视频</a></p><p>参考了胡凯大佬的博客，学到了很多： <a href="http://hukai.me/">胡凯</a></p>]]></content>
    
    
    <categories>
      
      <category>Performance Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android性能优化之Bitmap高效加载</title>
    <link href="/2019/03/06/c63415c3/"/>
    <url>/2019/03/06/c63415c3/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么Bitmap需要高效加载？"><a href="#为什么Bitmap需要高效加载？" class="headerlink" title="为什么Bitmap需要高效加载？"></a>为什么Bitmap需要高效加载？</h2><p>现在的高清大图，动辄就要好几M，而Android对单个应用锁施加的内存限制，只有小十几M，如16M，这导致加载Bitmap的时候很容易出现内存溢出。如下异常信息，便是在开发中经常需要的：</p><blockquote><p>java.lang.OutofMemoryError:bitmap size exceeds VM budget </p></blockquote><p>为了解决这个问题，就出现了Bitmap的高效加载策略。假设通过ImageView来显示图片，很多时候ImageView并没有原始图片的尺寸那么大，这个时候把整个图片加载进来后再设置给ImageView，显然是没有必要的，因为ImageView根本没办法显示原始图片。这时候就可以按一定的采样率来将图片缩小后再加载进来，这样图片既能在ImageView显示出来，又能降低内存占用从而在一定程度上避免OOM，提高了Bitmap加载时的性能。</p><h2 id="Bitmap高效加载的具体方式"><a href="#Bitmap高效加载的具体方式" class="headerlink" title="Bitmap高效加载的具体方式"></a>Bitmap高效加载的具体方式</h2><h3 id="加载Bitmap的方式"><a href="#加载Bitmap的方式" class="headerlink" title="加载Bitmap的方式"></a>加载Bitmap的方式</h3><p>Bitmap在Android中指的是一张图片。通过BitmapFactory类提供的四类方法：decodeFile,decodeResource,decodeStream和decodeByteArray,分别从文件系统，资源，输入流和字节数组中加载出一个Bitmap对象，其中decodeFile,decodeResource又间接调用了decodeStream方法，这四类方法最终是在Android的底层实现的，对应着BitmapFactory类的几个native方法。</p><h3 id="BitmapFactory-Options的参数"><a href="#BitmapFactory-Options的参数" class="headerlink" title="BitmapFactory.Options的参数"></a>BitmapFactory.Options的参数</h3><h4 id="①inSampleSize参数"><a href="#①inSampleSize参数" class="headerlink" title="①inSampleSize参数"></a>①inSampleSize参数</h4><p>上述四类方法都支持BitmapFactory.Options参数，而Bitmap的按一定采样率进行缩放就是通过BitmapFactory.Options参数实现的，主要用到了inSampleSize参数，即采样率。通过对inSampleSize的设置，对图片的像素的高和宽进行缩放。</p><p>当inSampleSize=1，即采样后的图片大小为图片的原始大小。小于1，也按照1来计算。 当inSampleSize&gt;1，即采样后的图片将会缩小，缩放比例为1/(inSampleSize的二次方)。</p><p>例如：一张1024 ×1024像素的图片，采用ARGB8888格式存储，那么内存大小1024×1024×4=4M。如果inSampleSize=2，那么采样后的图片内存大小：512×512×4=1M。</p><p><strong>注意：官方文档支出，inSampleSize的取值应该总是2的指数，如1，2，4，8等。如果外界传入的inSampleSize的值不为2的指数，那么系统会向下取整并选择一个最接近2的指数来代替。比如3，系统会选择2来代替。当时经验证明并非在所有Android版本上都成立。</strong></p><p><strong>关于inSampleSize取值的注意事项：</strong> 通常是根据图片宽高实际的大小/需要的宽高大小，分别计算出宽和高的缩放比。但应该取其中最小的缩放比，避免缩放图片太小，到达指定控件中不能铺满，需要拉伸从而导致模糊。</p><p>例如：ImageView的大小是100×100像素，而图片的原始大小为200×300，那么宽的缩放比是2，高的缩放比是3。如果最终inSampleSize=2，那么缩放后的图片大小100×150，仍然合适ImageView。如果inSampleSize=3，那么缩放后的图片大小小于ImageView所期望的大小，这样图片就会被拉伸而导致模糊。</p><h4 id="②inJustDecodeBounds参数"><a href="#②inJustDecodeBounds参数" class="headerlink" title="②inJustDecodeBounds参数"></a><strong>②inJustDecodeBounds参数</strong></h4><p>我们需要获取加载的图片的宽高信息，然后交给inSampleSize参数选择缩放比缩放。那么如何能先不加载图片却能获得图片的宽高信息，通过inJustDecodeBounds=true，然后加载图片就可以实现只解析图片的宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。当获取了宽高信息，计算出缩放比后，然后在将inJustDecodeBounds=false,再重新加载图片，就可以加载缩放后的图片。</p><p><strong>注意：BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，比如同一张图片放在不同的drawable目录下或者程序运行在不同屏幕密度的设备上，都可能导致BitmapFactory获取到不同的结果，和Android的资源加载机制有关。</strong></p><h3 id="3-高效加载Bitmap的流程"><a href="#3-高效加载Bitmap的流程" class="headerlink" title="3.高效加载Bitmap的流程"></a>3.高效加载Bitmap的流程</h3><p>①将BitmapFactory.Options的inJustDecodeBounds参数设为true并加载图片。</p><p>②从BitmapFactory.Options中取出图片的原始宽高信息，它们对应于outWidth和outHeight参数。</p><p>③根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize。</p><p>④将BitmapFactory.Options的inJustDecodeBounds参数设为false，然后重新加载图片。</p><h2 id="三、Bitmap高效加载的代码实现"><a href="#三、Bitmap高效加载的代码实现" class="headerlink" title="三、Bitmap高效加载的代码实现"></a>三、Bitmap高效加载的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeSampledBitmapFromResource</span><span class="hljs-params">(Resources res, <span class="hljs-keyword">int</span> resId, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span></span>&#123;<br>       BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();<br>       options.inJustDecodeBounds = <span class="hljs-keyword">true</span>;<br>       <span class="hljs-comment">//加载图片</span><br>       BitmapFactory.decodeResource(res,resId,options);<br>       <span class="hljs-comment">//计算缩放比</span><br>       options.inSampleSize = calculateInSampleSize(options,reqHeight,reqWidth);<br>       <span class="hljs-comment">//重新加载图片</span><br>       options.inJustDecodeBounds =<span class="hljs-keyword">false</span>;<br>       <span class="hljs-keyword">return</span> BitmapFactory.decodeResource(res,resId,options);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateInSampleSize</span><span class="hljs-params">(BitmapFactory.Options options, <span class="hljs-keyword">int</span> reqHeight, <span class="hljs-keyword">int</span> reqWidth)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> height = options.outHeight;<br>       <span class="hljs-keyword">int</span> width = options.outWidth;<br>       <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span>(height&gt;reqHeight||width&gt;reqWidth)&#123;<br>           <span class="hljs-keyword">int</span> halfHeight = height/<span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">int</span> halfWidth = width/<span class="hljs-number">2</span>;<br>           <span class="hljs-comment">//计算缩放比，是2的指数</span><br>           <span class="hljs-keyword">while</span>((halfHeight/inSampleSize)&gt;=reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;=reqWidth)&#123;<br>               inSampleSize*=<span class="hljs-number">2</span>;<br>           &#125;<br>       &#125;<br><br><br>       <span class="hljs-keyword">return</span> inSampleSize;<br>   &#125;<br></code></pre></td></tr></table></figure><p> 这个时候就可以通过如下方式高效加载图片： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mImageView.setImageBitmap(decodeSampledBitmapFromResource(getResources(),R.mipmap.ic_launcher,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>除了BitmapFactory的decodeResource方法，其他方法也可以类似实现。</p><h2 id="四、三级缓存"><a href="#四、三级缓存" class="headerlink" title="四、三级缓存"></a>四、三级缓存</h2><p>大部分情况下我们的图片都是来自于网络，通过网络请求下载到本地再进行加载。而网路请求是耗时操作，不仅需要大量时间，还会消耗大量的流量，非常影响用户体验。如果图片过多，而我们又没有对图片进行有效的缓存，就很容易导致OOM。 因此对图片进行缓存是非常重要的。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Android图片三级缓存的原理如下：</p><p><img src="/img/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="三级缓存"></p><p> 可见，Android中图片的三级缓存主要是强引用、软引用和文件系统。 </p><p>Android原生为我们提供了一个LruCache，其中维护着一个LinkedHashMap。LruCache可以用来存储各种类型的数据，但最常见的是存储图片（Bitmap）。LruCache创建LruCache时，我们需要设置它的大小，一般是系统最大存储空间的八分之一。LruCache的机制是存储最近、最后使用的图片，如果LruCache中的图片大小超过了其默认大小，则会将最老、最远使用的图片移除出去。</p><p>当图片被LruCache移除的时候，我们需要手动将这张图片添加到软引用（SoftReference）中。我们需要在项目中维护一个由SoftReference组成的集合，其中存储被LruCache移除出来的图片。软引用的一个好处是当系统空间紧张的时候，软引用可以随时销毁，因此软引用是不会影响系统运行的，换句话说，如果系统因为某个原因OOM了，那么这个原因肯定不是软引用引起的。</p><p><strong>下面叙述一下三级缓存的流程：</strong></p><p>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache中有，则直接取出来使用，如果LruCache中没有，则去SoftReference中寻找，如果SoftReference中有，则从SoftReference中取出图片使用，同时将图片重新放回到LruCache中，如果SoftReference中也没有图片，则去文件系统中寻找，如果有则取出来使用，同时将图片添加到LruCache中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图片保存到文件系统中，然后放到LruCache中。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>（1）网络访问工具类HttpUtil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问Http的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HttpUtil instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HttpUtil</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpUtil <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (HttpUtil.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> HttpUtil();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过path（URL）访问网络获取返回的字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getByteArrayFromWeb(String path) &#123;<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">null</span>;<br>        InputStream is = <span class="hljs-keyword">null</span>;<br>        ByteArrayOutputStream baos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            URL url = <span class="hljs-keyword">new</span> URL(path);<br>            HttpURLConnection connection = (HttpURLConnection) url.openConnection();<br>            connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br>            connection.setDoInput(<span class="hljs-keyword">true</span>);<br>            connection.setConnectTimeout(<span class="hljs-number">5000</span>);<br>            connection.connect();<br>            <span class="hljs-keyword">if</span> (connection.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;<br>                baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                is = connection.getInputStream();<br>                <span class="hljs-keyword">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> ((length = is.read(tmp)) != -<span class="hljs-number">1</span>) &#123;<br>                    baos.write(tmp, <span class="hljs-number">0</span>, length);<br>                &#125;<br>            &#125;<br>            b = baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>                    is.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (baos != <span class="hljs-keyword">null</span>) &#123;<br>                    baos.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）操作文件系统的工具类FileUtil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.content.Context;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作内存文件的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FileUtil instance;<br><br>    <span class="hljs-keyword">private</span> Context context;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FileUtil</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileUtil <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (FileUtil.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> FileUtil(context);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将文件存储到内存中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFileToStorage</span><span class="hljs-params">(String fileName, <span class="hljs-keyword">byte</span>[] b)</span> </span>&#123;<br>        FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            File file = <span class="hljs-keyword">new</span> File(context.getFilesDir(), fileName);<br>            fos = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>            fos.write(b, <span class="hljs-number">0</span>, b.length);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;<br>                    fos.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从内存中读取文件的字节码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] readBytesFromStorage(String fileName) &#123;<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">null</span>;<br>        FileInputStream fis = <span class="hljs-keyword">null</span>;<br>        ByteArrayOutputStream baos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = context.openFileInput(fileName);<br>            baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            <span class="hljs-keyword">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len = fis.read(tmp)) != -<span class="hljs-number">1</span>) &#123;<br>                baos.write(tmp, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            b = baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) &#123;<br>                    fis.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (baos != <span class="hljs-keyword">null</span>) &#123;<br>                    baos.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）LruCache的子类ImageCache：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.graphics.Bitmap;<br><span class="hljs-keyword">import</span> android.os.Build;<br><span class="hljs-keyword">import</span> android.support.annotation.RequiresApi;<br><span class="hljs-keyword">import</span> android.util.LruCache;<br><br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图片缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequiresApi(api = Build.VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LruCache</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Bitmap</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; cacheMap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCache</span><span class="hljs-params">(Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; cacheMap)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>((<span class="hljs-keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="hljs-number">8</span>));<br>        <span class="hljs-keyword">this</span>.cacheMap = cacheMap;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 获取图片大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sizeOf</span><span class="hljs-params">(String key, Bitmap value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value.getRowBytes() * value.getHeight();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 当有图片从LruCache中移除时，将其放进软引用集合中</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evicted, String key, Bitmap oldValue, Bitmap newValue)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span>) &#123;<br>            SoftReference&lt;Bitmap&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;Bitmap&gt;(oldValue);<br>            cacheMap.put(key, softReference);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; getCacheMap() &#123;<br>        <span class="hljs-keyword">return</span> cacheMap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）三级缓存的工具类CacheUtil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.graphics.Bitmap;<br><span class="hljs-keyword">import</span> android.graphics.BitmapFactory;<br><span class="hljs-keyword">import</span> android.os.Build;<br><span class="hljs-keyword">import</span> android.widget.ImageView;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缓存工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CacheUtil instance;<br><br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> ImageCache imageCache;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">CacheUtil</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.context = context;<br>        Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; cacheMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123; <span class="hljs-comment">// SDK版本判断</span><br>            <span class="hljs-keyword">this</span>.imageCache = <span class="hljs-keyword">new</span> ImageCache(cacheMap);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CacheUtil <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (CacheUtil.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> CacheUtil(context);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将图片添加到缓存中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putBitmapIntoCache</span><span class="hljs-params">(String fileName, <span class="hljs-keyword">byte</span>[] data)</span> </span>&#123;<br>        <span class="hljs-comment">// 将图片的字节数组写入到内存中</span><br>        FileUtil.getInstance(context).writeFileToStorage(fileName, data);<br>        <span class="hljs-comment">// 将图片存入强引用（LruCache）</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;<br>            imageCache.put(fileName, BitmapFactory.decodeByteArray(data, <span class="hljs-number">0</span>, data.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从缓存中取出图片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">getBitmapFromCache</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        <span class="hljs-comment">// 从强引用（LruCache）中取出图片</span><br>        Bitmap bm = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123; <span class="hljs-comment">// SDK版本判断</span><br>            bm = imageCache.get(fileName);<br>            <span class="hljs-keyword">if</span> (bm == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果图片不存在强引用中，则去软引用（SoftReference）中查找</span><br>                Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; cacheMap = imageCache.getCacheMap();<br>                SoftReference&lt;Bitmap&gt; softReference = cacheMap.get(fileName);<br>                <span class="hljs-keyword">if</span> (softReference != <span class="hljs-keyword">null</span>) &#123;<br>                    bm = softReference.get();<br>                    imageCache.put(fileName, bm);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果图片不存在软引用中，则去内存中找</span><br>                    <span class="hljs-keyword">byte</span>[] data = FileUtil.getInstance(context).readBytesFromStorage(fileName);<br>                    <span class="hljs-keyword">if</span> (data != <span class="hljs-keyword">null</span> &amp;&amp; data.length &gt; <span class="hljs-number">0</span>) &#123;<br>                        bm = BitmapFactory.decodeByteArray(data, <span class="hljs-number">0</span>, data.length);<br>                        imageCache.put(fileName, bm);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bm;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用三级缓存为ImageView设置图片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageToView</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String path, <span class="hljs-keyword">final</span> ImageView view)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String fileName = path.substring(path.lastIndexOf(File.separator) + <span class="hljs-number">1</span>);<br>        Bitmap bm = getBitmapFromCache(fileName);<br>        <span class="hljs-keyword">if</span> (bm != <span class="hljs-keyword">null</span>) &#123;<br>            view.setImageBitmap(bm);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从网络获取图片</span><br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">byte</span>[] b = HttpUtil.getInstance().getByteArrayFromWeb(path);<br>                    <span class="hljs-keyword">if</span> (b != <span class="hljs-keyword">null</span> &amp;&amp; b.length &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 将图片字节数组写入到缓存中</span><br>                        putBitmapIntoCache(fileName, b);<br>                        <span class="hljs-keyword">final</span> Bitmap bm = BitmapFactory.decodeByteArray(b, <span class="hljs-number">0</span>, b.length);<br>                        <span class="hljs-comment">// 将从网络获取到的图片设置给ImageView</span><br>                        view.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                                view.setImageBitmap(bm);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>（1）MainActivity的布局文件activity_main.xml中的代码： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;RelativeLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:id=<span class="hljs-string">&quot;@+id/activity_main&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;<br><br>    &lt;ListView<br>        android:id=<span class="hljs-string">&quot;@+id/id_main_lv_lv&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:divider=<span class="hljs-string">&quot;#DDDDDD&quot;</span><br>        android:dividerHeight=<span class="hljs-string">&quot;1.0dip&quot;</span> /&gt;<br><br>&lt;/RelativeLayout&gt;<br></code></pre></td></tr></table></figure><p>（2）MainActivity中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.widget.ListView;<br><br><span class="hljs-keyword">import</span> com.example.testimagecache.R;<br><span class="hljs-keyword">import</span> com.example.testimagecache.SharedData;<br><span class="hljs-keyword">import</span> com.example.testimagecache.adapter.ImageAdapter;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ListView lv;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; urlList;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        lv = (ListView) findViewById(R.id.id_main_lv_lv);<br>        initData();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化图片URL列表</span><br>        urlList = Arrays.asList(SharedData.IMAGE_URLS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onResume();<br>        initView();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化视图</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 为ListView适配数据</span><br>        ImageAdapter adapter = <span class="hljs-keyword">new</span> ImageAdapter(MainActivity.<span class="hljs-keyword">this</span>, urlList);<br>        lv.setAdapter(adapter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）ListView的适配器类ImageAdapter中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.widget.ListView;<br><br><span class="hljs-keyword">import</span> com.example.testimagecache.R;<br><span class="hljs-keyword">import</span> com.example.testimagecache.SharedData;<br><span class="hljs-keyword">import</span> com.example.testimagecache.adapter.ImageAdapter;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ListView lv;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; urlList;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        lv = (ListView) findViewById(R.id.id_main_lv_lv);<br>        initData();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化图片URL列表</span><br>        urlList = Arrays.asList(SharedData.IMAGE_URLS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onResume();<br>        initView();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化视图</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 为ListView适配数据</span><br>        ImageAdapter adapter = <span class="hljs-keyword">new</span> ImageAdapter(MainActivity.<span class="hljs-keyword">this</span>, urlList);<br>        lv.setAdapter(adapter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）ListView的Item的布局文件listitem_image.xml中的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span><br>    android:padding=<span class="hljs-string">&quot;10.0dip&quot;</span>&gt;<br><br>    &lt;ImageView<br>        android:id=<span class="hljs-string">&quot;@+id/id_imageitem_image&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;100.0dip&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;100.0dip&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center_horizontal&quot;</span><br>        android:contentDescription=<span class="hljs-string">&quot;@string/app_name&quot;</span><br>        android:scaleType=<span class="hljs-string">&quot;fitXY&quot;</span> /&gt;<br><br>&lt;/LinearLayout&gt;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/bitmap.md">Android Bitmap压缩策略</a></p><p><a href="https://www.cnblogs.com/itgungnir/p/6211002.html">【Android - 进阶】之图片三级缓存的原理及实现</a></p>]]></content>
    
    
    <categories>
      
      <category>Performance Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedHashMap原理</title>
    <link href="/2019/02/16/87a48ef6/"/>
    <url>/2019/02/16/87a48ef6/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前文章讲了HashMap。HashMap是一种非常常见、非常有用的集合，但在多线程情况下使用不当会有线程安全问题。</p><p>大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是<strong>迭代HashMap的顺序并不是HashMap放置的顺序</strong>，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map。</p><p>这个时候，LinkedHashMap就闪亮登场了，它虽然增加了时间和空间上的开销，但是<strong>通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序</strong>。<strong>该迭代顺序可以是插入顺序或者是访问顺序。</strong></p><p>我们写一个简单的LinkedHashMap的程序演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedHashMap&lt;string, integer=<span class="hljs-string">&quot;&quot;</span>&gt; lmap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;string, integer=<span class="hljs-string">&quot;&quot;</span>&gt;();<br>lmap.put(<span class="hljs-string">&quot;语文&quot;</span>, <span class="hljs-number">1</span>);<br>lmap.put(<span class="hljs-string">&quot;数学&quot;</span>, <span class="hljs-number">2</span>);<br>lmap.put(<span class="hljs-string">&quot;英语&quot;</span>, <span class="hljs-number">3</span>);<br>lmap.put(<span class="hljs-string">&quot;历史&quot;</span>, <span class="hljs-number">4</span>);<br>lmap.put(<span class="hljs-string">&quot;政治&quot;</span>, <span class="hljs-number">5</span>);<br>lmap.put(<span class="hljs-string">&quot;地理&quot;</span>, <span class="hljs-number">6</span>);<br>lmap.put(<span class="hljs-string">&quot;生物&quot;</span>, <span class="hljs-number">7</span>);<br>lmap.put(<span class="hljs-string">&quot;化学&quot;</span>, <span class="hljs-number">8</span>);<br><span class="hljs-keyword">for</span>(Entry&lt;string, integer=<span class="hljs-string">&quot;&quot;</span>&gt; entry : lmap.entrySet()) &#123;<br>System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">语文: <span class="hljs-number">1</span> 数学: <span class="hljs-number">2</span> 英语: <span class="hljs-number">3</span> 历史: <span class="hljs-number">4</span> 政治: <span class="hljs-number">5</span> 地理: <span class="hljs-number">6</span> 生物: <span class="hljs-number">7</span> 化学: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：</p><p>可以看到LinkedHashMap内部结构其实跟HashMap是一样的，只不过比HashMap多了一个双向链表。</p><p><img src="/img/03eb9014-da38-11e4-9cbf-03d9c21f05f2.png" alt="LinkedHashMap数据结构"></p><h2 id="四个关注点"><a href="#四个关注点" class="headerlink" title="四个关注点"></a>四个关注点</h2><table><thead><tr><th><strong>关 注 点</strong></th><th><strong>结 论</strong></th></tr></thead><tbody><tr><td>LinkedHashMap是否允许空</td><td>Key和Value都允许空</td></tr><tr><td>LinkedHashMap是否允许重复数据</td><td>Key重复会覆盖、Value允许重复</td></tr><tr><td>LinkedHashMap是否有序</td><td><strong>有序</strong></td></tr><tr><td>LinkedHashMap是否线程安全</td><td>非线程安全</td></tr></tbody></table><h2 id="LinkedHashMap基本结构"><a href="#LinkedHashMap基本结构" class="headerlink" title="LinkedHashMap基本结构"></a>LinkedHashMap基本结构</h2><p>LinkedHashMap可以认为是<strong>HashMap+LinkedList</strong>，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。</p><p>其实LinkedHashMap本身就继承自HashMap，也就是说它继承了HashMap中所有的非私有方法和属性：</p><p><img src="/img/20190216144930.png" alt="LinkedHashMap中的属性和方法"></p><h3 id="重点属性和方法"><a href="#重点属性和方法" class="headerlink" title="重点属性和方法"></a>重点属性和方法</h3><p>我们可以看到LinkedHashMap中有几个特有的属性和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The head (eldest) of the doubly linked list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The tail (youngest) of the doubly linked list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="hljs-comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;<br><br><span class="hljs-comment">// 这三个方法其实在HashMap已经定义了，但是空实现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>三个属性中，accessOrder表示是以访问排序还是以插入排序。</p><p>head和tail表示双链表的头结点和尾结点，用来表示循环双向链表的入口和出口。它们都是LinkedHashMap.Entry，我们看看这个Entry和HashMap中的Entry(Node)有何不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Entry继承自HashMap.Node，它具有的完整属性如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 哈希码</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br><span class="hljs-comment">// Key</span><br><span class="hljs-keyword">final</span> K key;<br><span class="hljs-comment">// Value</span><br>V value;<br><span class="hljs-comment">// 指向下一个结点（哈希表）</span><br>Node&lt;K,V&gt; next;<br><span class="hljs-comment">// 前一个结点和后一个结点（双向链表）</span><br>Entry&lt;K,V&gt; before, after;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>LinkedHashMap中定义五个构造方法，都是交给父类HashMap来初始化的，不过都初始化了accessOrder为false，也就是说默认是按照插入顺序来排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(initialCapacity, loadFactor);<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(initialCapacity);<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">float</span> loadFactor,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">boolean</span> accessOrder)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(initialCapacity, loadFactor);<br>    <span class="hljs-keyword">this</span>.accessOrder = accessOrder;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三个重点函数分析"><a href="#三个重点函数分析" class="headerlink" title="三个重点函数分析"></a>三个重点函数分析</h2><p>上面我们提到了HashMap中定义下三个空实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Callbacks to allow LinkedHashMap post-actions</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>LinkedHashMap继承于HashMap，重新实现了这3个函数，通过函数名我们知道这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。</p><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// 将结点移动到链表尾</span><br>    LinkedHashMap.Entry&lt;K,V&gt; last;<br>    <span class="hljs-comment">// 如果定义了accessOrder，那么就保证最近访问节点放到最后</span><br>    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>        LinkedHashMap.Entry&lt;K,V&gt; p =<br>            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>        p.after = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>            head = a;<br>        <span class="hljs-keyword">else</span><br>            b.after = a;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)<br>            a.before = b;<br>        <span class="hljs-keyword">else</span><br>            last = b;<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>            head = p;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p.before = last;<br>            last.after = p;<br>        &#125;<br>        tail = p;<br>        ++modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是说在进行get和put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。</p><p>LinkedHashMap重写了get方法但使用的是HashMap的put方法，get方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (accessOrder)<br>        afterNodeAccess(e);<br>    <span class="hljs-keyword">return</span> e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到确实调用了afterNodeAccess()方法调整链表相对位置。</p><p>再来看看HashMap中的put方法有没有调用afterNodeAccess：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        ··· ···<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现HashMap中的put方法调用了afterNodeAccess方法同时也调用了afterNodeInsertion()方法。</p><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span><br>    LinkedHashMap.Entry&lt;K,V&gt; first;<br>    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;<br>        K key = first.key;<br>        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>afterNodeInsertion()方法表示的是在put操作之后需要进行的操作，如果用户定义了removeEldestEntry的规则，那么就可以执行相应的移除操作。</p><p>removeEldestEntry()方法在LinkedHashMap中默认实现是false，主要是交给用户去实现，以达到自动删除头结点（也就是访问最少结点，也叫eldest）的效果，这也是LinkedHashMap常用来作缓存的原因。</p><h3 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval()"></a><strong>afterNodeRemoval()</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// unlink</span><br>    LinkedHashMap.Entry&lt;K,V&gt; p =<br>        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>    p.before = p.after = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>        head = a;<br>    <span class="hljs-keyword">else</span><br>        b.after = a;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>)<br>        tail = b;<br>    <span class="hljs-keyword">else</span><br>        a.before = b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数是在移除节点后调用的，就是将节点从双向链表中删除。</p><p>我们从上面3个函数看出来，基本上都是为了<strong>保证双向链表中的节点次序或者双向链表容量</strong>所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p><h2 id="LinkedHashMap实现LRU算法缓存"><a href="#LinkedHashMap实现LRU算法缓存" class="headerlink" title="LinkedHashMap实现LRU算法缓存"></a>LinkedHashMap实现LRU算法缓存</h2><p>LinkedHashMap可以用来作缓存，比方说LRUCache，看一下这个类的代码，很简单，就十几行而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">super</span>(maxSize, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);<br>        maxElements = maxSize;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(java.util.Map.Entry eldest)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> size() &gt; maxElements;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> maxElements;<br>&#125;<br></code></pre></td></tr></table></figure><p>顾名思义，LRUCache就是基于LRU算法的Cache，这个类继承自LinkedHashMap，而类中看到没有什么特别的方法，这说明LRUCache实现缓存LRU功能都是源自LinkedHashMap的。</p><p>LinkedHashMap可以实现LRU算法的缓存基于两点：</p><p>1、LinkedList首先它是一个Map，Map是基于K-V的，和缓存一致</p><p>2、LinkedList提供了一个boolean值和一个方法可以让用户指定是否实现LRU</p><p>第二点的意思就是，如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，双向队列最头的那个数据不就是最不常访问的那个数据了吗？换句话说，双向链表最头的那个数据就是要淘汰的数据。</p><p>“访问”，这个词有两层意思：</p><p>1、根据Key拿到Value，也就是get方法</p><p>2、修改Key对应的Value，也就是put方法</p><p>我们上面已经看过get和put方法的源码了，主要涉及afterNodeAccess和afterNodeInsertion两个方法，前者将链表的结点以访问的频繁度排列，后者通过自定义的removeEldestEntry规则实现何时清理缓存。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JDK1.8 LinkedHashMap源码</p><p>Java集合之LinkedHashMap</p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LinkedHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的线程池</title>
    <link href="/2019/02/10/af0ae3b4/"/>
    <url>/2019/02/10/af0ae3b4/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？主要有如下几个步骤：</p><p>1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p><p>处理流程如下图所示：</p><p><img src="/img/QQ%E5%9B%BE%E7%89%8720190210153304.png" alt="线程池处理流程"></p><p>ThreadPoolExecutor执行execute()方法的示意图如下所示：</p><p><img src="/img/20190210154259.png" alt="execute()方法"></p><p>从中可以看到，如果我们执行ThreadPoolExecutor的execute方法，会遇到各种情况：<br>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p><p>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p><p>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</p><p>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize）几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><p>看看源码是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><span class="hljs-comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span><br><span class="hljs-keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;<br><span class="hljs-comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span><br><span class="hljs-keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;<br><span class="hljs-keyword">if</span> (runState != RUNNING || poolSize == <span class="hljs-number">0</span>)<br>ensureQueuedTaskHandled(command);<br>&#125;<br><span class="hljs-comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span><br><span class="hljs-comment">// 则创建一个线程执行任务。</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addIfUnderMaximumPoolSize(command))<br><span class="hljs-comment">// 抛出RejectedExecutionException异常</span><br>reject(command); <span class="hljs-comment">// is shutdown or saturated</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工作线程：</strong>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Runnable task = firstTask;<br><span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>runTask(task);<br>task = <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>workerDone(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor中线程执行任务的示意图如下所示：</p><p><img src="/img/20190210160848.png" alt="线程池的任务执行"></p><p>线程池中的线程执行任务分两种情况，如下。<br>1）在execute()方法中创建一个线程时，会让这个线程执行当前任务。<br>2）这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过ThreadPoolExecutor来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,<br>milliseconds,runnableTaskQueue, handler);<br></code></pre></td></tr></table></figure><p>解释一下这几个参数：</p><p>1）corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p><p>2）runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。<br>·ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。<br>·LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br>·SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br>·PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p><p>3）maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p><p>4）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="hljs-string">&quot;XX-task-%d&quot;</span>).build();<br></code></pre></td></tr></table></figure><p>5）RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p><p>·AbortPolicy：直接抛出异常。<br>·CallerRunsPolicy：只用调用者所在线程来运行任务。<br>·DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>·DiscardPolicy：不处理，丢弃掉。</p><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><p>·keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，<br>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p><p>·TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-comment">// TODO Auto-generated method stub</span><br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<br><span class="hljs-keyword">try</span> &#123;<br>Object s = future.get();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// 处理中断异常</span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br><span class="hljs-comment">// 处理无法执行任务异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdown();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的<strong>shutdown</strong>或<strong>shutdownNow</strong>方法来关闭线程池。它们的原理是<strong>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</strong>但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p>通过直接或者间接地配置ThreadPoolExecutor的参数可以创建不同类型的ThreadPoolExecutor，其中有 4种线程池比较常用，它们分别是FixedThreadPool、CachedThreadPool、SingleThreadExecutor和ScheduledThreadPool。</p><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool 是可重用固定线程数的线程池。在 Executors 类中提供了创建FixedThreadPool的方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                             <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                             <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都设置为创建FixedThreadPool指定的参数nThreads，也就意味着FixedThreadPool只有核心线程，并且数量是固定的，没有非核心线程。keepAliveTime设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以keepAliveTime是无效的参数。另外，任务队列采用了无界的阻塞队列LinkedBlockingQueue。</p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个根据需要创建线程的线程池，创建CachedThreadPool的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>CachedThreadPool的corePoolSize为0，maximumPoolSize设置为Integer.MAX_VALUE，这意味着CachedThreadPool没有核心线程，非核心线程是无界的。keepAliveTime设置为60L，则空闲线程等待新任务的最长时间为 60s。在此用了阻塞队列 SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor是使用单个工作线程的线程池，其创建源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                           <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                           <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br> &#125;<br></code></pre></td></tr></table></figure><p>corePoolSize和maximumPoolSize都为1，意味着SingleThreadExecutor只有一个核心线程，其他的参数都和FixedThreadPool一样，这里就不赘述了。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>ScheduledThreadPool是一个能实现定时和周期性任务的线程池，它的创建源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了ScheduledThreadPoolExecutor，ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，它主要用于给定延时之后的运行任务或者定期处理任务。ScheduledThreadPoolExecutor 的构造方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>              <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出，ScheduledThreadPoolExecutor  的构造方法最终调用的是ThreadPoolExecutor的构造方法。corePoolSize是传进来的固定数值，maximumPoolSize的值是Integer.MAX_VALUE。因为采用的DelayedWorkQueue是无界的，所以maximumPoolSize这个参数是无效的。</p>]]></content>
    
    
    <categories>
      
      <category>Java Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadPool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap详解</title>
    <link href="/2019/02/04/48014e1e/"/>
    <url>/2019/02/04/48014e1e/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>JDK1.7之前HashMap采用的数据结构为数组+链表，使用这种结构是为了解决哈希冲突（拉链法）。JDK1.8之后还引入了红黑树，当链表长度达到一个阈值时该链表就会转化为红黑树。</p><p><img src="/img/944365-4bf32082bf297dd9.png" alt="HashMap的数据结构"></p><h3 id="数组元素和链表结点"><a href="#数组元素和链表结点" class="headerlink" title="数组元素和链表结点"></a>数组元素和链表结点</h3><p>JDK1.7之前为Entry，JDK1.8为Node，两者只是名称不同。</p><p>Entry（或Node）中存放着键值对、键的哈希值，并且指向下一个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Entry类实现了Map.Entry接口</span><br><span class="hljs-comment"> * 即 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法</span><br><span class="hljs-comment">**/</span>  <br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> K key;  <span class="hljs-comment">// 键</span><br>    V value;  <span class="hljs-comment">// 值</span><br>    Entry&lt;K,V&gt; next; <span class="hljs-comment">// 指向下一个节点 ，也是一个Entry对象，从而形成解决hash冲突的单链表</span><br>    <span class="hljs-keyword">int</span> hash;  <span class="hljs-comment">// hash值</span><br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 构造方法，创建一个Entry </span><br><span class="hljs-comment">     * 参数：哈希值h，键值k，值v、下一个节点n </span><br><span class="hljs-comment">     */</span>  <br>    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  <br>        value = v;  <br>        next = n;  <br>        key = k;  <br>        hash = h;  <br>    &#125;  <br><br>    <span class="hljs-comment">// 返回 与 此项 对应的键</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> key;  <br>    &#125;  <br><br>    <span class="hljs-comment">// 返回 与 此项 对应的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;  <br>        V oldValue = value;  <br>        value = newValue;  <br>        <span class="hljs-keyword">return</span> oldValue;  <br>    &#125;  <br><br>   <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * equals（）</span><br><span class="hljs-comment">     * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  </span><br><span class="hljs-comment">     */</span> <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <br>        Map.Entry e = (Map.Entry)o;  <br>        Object k1 = getKey();  <br>        Object k2 = e.getKey();  <br>        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;  <br>            Object v1 = getValue();  <br>            Object v2 = e.getValue();  <br>            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-keyword">null</span> &amp;&amp; v1.equals(v2)))  <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <br>    &#125;  <br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * hashCode（） </span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();  <br>    &#125;  <br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 当向HashMap中添加元素时，即调用put(k,v)时， </span><br><span class="hljs-comment">     * 对已经在HashMap中k位置进行v的覆盖时，会调用此方法 </span><br><span class="hljs-comment">     * 此处没做任何处理 </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordAccess</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  <br>    &#125;  <br><br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 当从HashMap中删除了一个Entry时，会调用该函数 </span><br><span class="hljs-comment">     * 此处没做任何处理 </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordRemoval</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  <br>    &#125; <br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="红黑树结点"><a href="#红黑树结点" class="headerlink" title="红黑树结点"></a>红黑树结点</h3><p>HashMap中红黑树结点采用TreeNode类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 红黑树节点 实现类：继承自LinkedHashMap.Entry&lt;K,V&gt;类</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;  <br><br>   <span class="hljs-comment">// 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色</span><br>   TreeNode&lt;K,V&gt; parent;  <br>   TreeNode&lt;K,V&gt; left;   <br>   TreeNode&lt;K,V&gt; right;<br>   TreeNode&lt;K,V&gt; prev;   <br>   <span class="hljs-keyword">boolean</span> red;   <br><br>   <span class="hljs-comment">// 构造函数</span><br>   TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;  <br>       <span class="hljs-keyword">super</span>(hash, key, val, next);  <br>   &#125;  <br><br>   <span class="hljs-comment">// 返回当前节点的根节点  </span><br>   <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123;  <br>       <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;  <br>           <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-keyword">null</span>)  <br>               <span class="hljs-keyword">return</span> r;  <br>           r = p;  <br>       &#125;  <br>   &#125; <br></code></pre></td></tr></table></figure><h2 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h2><h3 id="容量（capacity）"><a href="#容量（capacity）" class="headerlink" title="容量（capacity）"></a>容量（capacity）</h3><p>容量指的是HashMap中数组的长度，它的值必须是2的N次幂。初始容量为16，最大不可超过2的30次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认初始容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><h3 id="加载因子（factor）"><a href="#加载因子（factor）" class="headerlink" title="加载因子（factor）"></a>加载因子（factor）</h3><p>加载因子决定了HashMap在自动增加时能达到多大载量，它与容量一起决定每次扩容的阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实际加载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br><span class="hljs-comment">// 默认加载因子 = 0.75</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>加载因子越大，到达扩容阈值时哈希表填满的元素越多，空间利用率越高，但是哈希冲突也更多，使得链表长度更长，HashMap的查找效率变低。反之查找效率变高，但是空间利用率变低了。如下图：</p><p><img src="/img/944365-b85819e2f8a3c30a.jpeg" alt="关于加载因子"></p><h3 id="扩容阈值（threshold）"><a href="#扩容阈值（threshold）" class="headerlink" title="扩容阈值（threshold）"></a>扩容阈值（threshold）</h3><p>当哈希表所存放的元素数量≥扩容阈值时，就会触发哈希表的resize操作进行扩容。扩容阈值等于容量乘以加载因子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩容阈值 = 容量 x 加载因子</span><br><span class="hljs-keyword">int</span> threshold;<br></code></pre></td></tr></table></figure><h3 id="红黑树相关"><a href="#红黑树相关" class="headerlink" title="红黑树相关"></a>红黑树相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 树化阈值，即链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>; <br><span class="hljs-comment">// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><span class="hljs-comment">// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表</span><br><span class="hljs-comment">// 否则，若桶内元素太多时，则直接扩容，而不是树形化</span><br><span class="hljs-comment">// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><h3 id="JDK1-8与JDK1-7的差异"><a href="#JDK1-8与JDK1-7的差异" class="headerlink" title="JDK1.8与JDK1.7的差异"></a>JDK1.8与JDK1.7的差异</h3><p><img src="/img/944365-67768bc4f0d23d69-1024x283.png" alt="1.8中数据结构与1.7差异"></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap提供了四个构造方法，需要注意的是，<strong>这四个方法中都没有进行哈希表的初始化</strong>，哈希表的初始化工作实际是在第一次put元素时才会进行。这里仅贴出可自定义初始容量和加载因子的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="hljs-comment"> * capacity and load factor.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  loadFactor      the load factor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="hljs-comment"> *         or the load factor is nonpositive</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +  initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor()方法类似于JDK1.7中inflateTable()里的roundUpToPowerOf2(toSize)，会根据传入的cap值返回大于cap的最小2的n次幂。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> \* Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意此处的扩容阈值threshold并不是真正要用的阈值，最终的阈值在putVal方法中计算。这里将扩容阈值计算好，后面直接可以替换初始容量。</p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>对比：</p><p><img src="/img/944365-45ec8c640c5e5363-1024x192.png" alt="1.8与1.7添加元素的区别"></p><p>JDK1.8与1.7最主要的差别就是每次向HashMap中添加元素都要额外考虑红黑树的情况。</p><h3 id="计算hash值"><a href="#计算hash值" class="headerlink" title="计算hash值"></a>计算hash值</h3><p>先调用Key对象本身的hashCode()方法计算出hash值，再进行hash扰动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span><br> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>   h ^= k.hashCode(); <br>   h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>   <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br><br> <span class="hljs-comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span><br> <span class="hljs-comment">// 1. 取hashCode值： h = key.hashCode() </span><br> <span class="hljs-comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span><br> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>       <span class="hljs-comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span><br>       <span class="hljs-comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span><br>       <span class="hljs-comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 若哈希表为空，则通过resize()方法创建 </span><br>    <span class="hljs-comment">// 所以哈希表的初始化其实是在resize()方法中完成的</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br><br>    <span class="hljs-comment">// 注意这里tab数组下表计算为i = (n - 1) &amp; hash，在jdk1.7中是个单独的函数indexFor()完成的</span><br>    <span class="hljs-comment">// 如果数组中该下表为空，则表示没有哈希冲突，直接新建一个数组元素存入</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果存在哈希冲突</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 判断是否存在Key值相同，相同则覆盖</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// Key值不相同，判断需要插入的数据结构是否是红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不为红黑树，则遍历链表进行插入或者更新值</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 判断是否达到了树化阈值</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">// 链表转换为红黑树</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// key已存在，新value替换旧value</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 判断是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>上面我们提到了resize()方法有两个作用：一是初始化哈希表，二是扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扩容前数组已经达到最大值，不再扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 若不会超过最大值，则翻倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 扩充阈值也翻倍</span><br>    &#125;<br>    <span class="hljs-comment">// 若旧数组长度等于0，表示哈希表还未初始化，则将扩充阈值赋给新数组容量</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <br>        <span class="hljs-comment">// 扩充阈值为不大于0则直接使用默认值</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 计算新的扩充阈值</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历旧数组，把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// 重新计算数组下标</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 链表优化，见下图</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.8扩容时，数据存储位置重新计算的方式如图所示：</p><p><img src="/img/944365-a467fdaa3a110350-1024x398.png" alt="重新计算位置"></p><p><img src="/img/944365-2466f5db47fd7685.png" alt="详解"></p><p>数组位置转换示意：</p><p><img src="/img/944365-d78ae9079c14f222.png" alt="示意图"></p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>get()函数的原理与put()基本相同，先获取扰动后的hash值，然后计算数组下标，接着依次从数组、红黑树、链表中读取数据，然后返回数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 函数原型</span><br><span class="hljs-comment">   * 作用：根据键key，向HashMap获取对应的值</span><br><span class="hljs-comment">   */</span> <br>   map.get(key)；<br><br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 源码分析</span><br><span class="hljs-comment">   */</span> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 1. 计算需获取数据的hash值</span><br>    <span class="hljs-comment">// 2. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1</span><br>    <span class="hljs-comment">// 3. 获取后，判断数据是否为空</span><br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 分析1：getNode(hash(key), key))</span><br><span class="hljs-comment">   */</span> <br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br><br>    <span class="hljs-comment">// 1. 计算存放在数组table中的位置</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-comment">// 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span><br>        <span class="hljs-comment">// a. 先在数组中找，若存在，则直接返回</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br><br>        <span class="hljs-comment">// b. 若数组中没有，则到红黑树中寻找</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br><br>            <span class="hljs-comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重点及细节Q-amp-A"><a href="#重点及细节Q-amp-A" class="headerlink" title="重点及细节Q&amp;A"></a>重点及细节Q&amp;A</h2><h4 id="HashMap如何解决哈希冲突？"><a href="#HashMap如何解决哈希冲突？" class="headerlink" title="HashMap如何解决哈希冲突？"></a><strong>HashMap如何解决哈希冲突？</strong></h4><p>HashMap采用拉链法解决哈希冲突，配合哈希扰动以及扩容机制，使得数据在数组中分布得更加均匀，数据结构上采用数组、链表和红黑树优化哈希冲突。</p><h4 id="为什么哈希数组的长度必须为2的N次幂？"><a href="#为什么哈希数组的长度必须为2的N次幂？" class="headerlink" title="为什么哈希数组的长度必须为2的N次幂？"></a><strong>为什么哈希数组的长度必须为2的N次幂？</strong></h4><h4 id="为什么采用哈希码-amp-数组长度（h-amp-（n-1））的方式计算存储数组下标？"><a href="#为什么采用哈希码-amp-数组长度（h-amp-（n-1））的方式计算存储数组下标？" class="headerlink" title="为什么采用哈希码&amp;数组长度（h&amp;（n - 1））的方式计算存储数组下标？"></a><strong>为什么采用哈希码&amp;数组长度（h&amp;（n - 1））的方式计算存储数组下标？</strong></h4><p>这两个问题是类似的。如果在设计时要提升HashMap性能，那么我们就需要减少哈希冲突，让数据优先存满数组，再依次加入链表中。那么可以采用哈希码除以数组长度再取余的方式计算存储数组下标，也就是 index = hash % n，但是这种方式计算下标效率太低（每次计算都要大量除法操作再取余）。</p><p>后来设计师想到可以采用与运算，若一个每一位都为1的二进制数（数组长度-1）与另一个数（哈希码）相与，和取余操作得到的结果是相同的，但是位运算效率自然更高。要保证这个二进制数始终每位为1，那就必须使数组长度始终为2的N次幂（再减一）。</p><h4 id="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化"><a href="#为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化" class="headerlink" title="为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化"></a>为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化</h4><p><img src="/img/944365-ce5aa2227f269410.jpeg" alt="解答"></p><h4 id="为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键"><a href="#为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键" class="headerlink" title="为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键"></a>为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键</h4><p>由于默认的hashCode()方法（Object中）是根据地址值进行计算的，若两个Key值相等，但是地址不同的话，使用默认的hashCode()方法会出现相同Key不同hash值的情况。除此之外，默认的equals()方法也是直接比较对象地址，所以也需要重写。而String和Integer中都重写了hashCode()和equals()方法，保证了hash值的准确定，并且都为final类，保证了key的不可更改性。</p><p>因此，若是用自定义类作为HashMap的键的话，必须重写hashCoe()和equals()方法，并且最好用final修饰。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JDK1.8 - HashMap.java</p><p>JDK1.7 - HashMap.java</p><p><a href="https://www.jianshu.com/p/8324a34577a0">Java源码分析：HashMap 1.8 相对于1.7 到底更新了什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android触摸事件分发机制</title>
    <link href="/2018/12/15/7f716777/"/>
    <url>/2018/12/15/7f716777/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要进行事件分发"><a href="#为什么要进行事件分发" class="headerlink" title="为什么要进行事件分发"></a>为什么要进行事件分发</h2><p>android中View是树形结构的，view可能会重叠，当我们点击某个区域时，如下图中的View，由于Activity、ViewGroupA、ViewGroupB和View都能对触摸事件进行响应，系统无法确定该事件交由谁处理，这就需要事件分发机制来帮忙。</p><center>  <img src="/img/Screenshot_1547291939-576x1024.png" style="zoom:50%;" /></center><h2 id="什么是触摸事件"><a href="#什么是触摸事件" class="headerlink" title="什么是触摸事件"></a>什么是触摸事件</h2><p>官方文档中的描述：</p><blockquote><p>Motion events describe movements in terms of an action code and a set of axis values. The action code specifies the state change that occurred such as a pointer going down or up. The axis values describe the position and other movement properties. </p></blockquote><p>动作事件根据操作代码和一套坐标轴值来描述动作/运动。操作代码指定发生的状态更改，例如指针向下或向上。坐标轴值描述位置和其他动作属性。</p><p>事件通常被封装成MotionEvent对象。</p><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><table><thead><tr><th><strong>事件</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td>ACTION_DOWN</td><td>手指 <strong>初次接触到屏幕</strong> 时触发。</td></tr><tr><td>ACTION_MOVE</td><td>手指 <strong>在屏幕上滑动</strong> 时触发，会会多次触发。</td></tr><tr><td>ACTION_UP</td><td>手指 <strong>离开屏幕</strong> 时触发。</td></tr><tr><td>ACTION_CANCEL</td><td>事件 <strong>被上层拦截</strong> 时触发。</td></tr></tbody></table><p>对于单指触控来说，一次简单的交互流程是这样的:</p><p><strong>手指落下(ACTION_DOWN) －&gt; 移动(ACTION_MOVE) －&gt; 离开(ACTION_UP)</strong></p><blockquote><p>本次事例中 ACTION_MOVE 有多次触发。<br>如果仅仅是单击(手指按下再抬起)，不会触发 ACTION_MOVE。 </p></blockquote><h2 id="事件分发、拦截与消费"><a href="#事件分发、拦截与消费" class="headerlink" title="事件分发、拦截与消费"></a>事件分发、拦截与消费</h2><p>主要涉及三个方法：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>相关方法</strong></th><th><strong>Activity</strong></th><th><strong>ViewGroup</strong></th><th><strong>View</strong></th></tr></thead><tbody><tr><td>事件分发</td><td>dispatchTouchEvent</td><td>有</td><td>有</td><td>有</td></tr><tr><td>事件拦截</td><td>onInterceptTouchEvent</td><td>无</td><td>有</td><td>无</td></tr><tr><td>事件消费</td><td>onTouchEvent</td><td>有</td><td>有</td><td>有</td></tr></tbody></table><p>Activity和View中都是没有事件拦截，这是因为：</p><blockquote><p>Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果。<br>View最为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。 </p></blockquote><p><strong>public boolean dispatchTouchEvent(MotionEvent ev)</strong> </p><p>用来进行事件的分发。如果事件能够传递给当前View，那么首先就会调用此方法，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消费该事件。</p><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong></p><p>在 <strong>dispatchTouchEvent</strong>方法中调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么该事件不会再继续传递，此方法不会被再次调用，返回结果表示是否拦截某事件。</p><p><strong>public boolean onTouchEvent(MotionEvent event)</strong></p><p>在<strong>dispatchTouchEvent</strong>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p><p>上述三个方法有何区别？又有何联系？可以用如下伪代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> consume = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;<br>        consume = onTouchEvent(ev);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        consume = child.dispatchTouchEvent(ev);<br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;<br>&#125;<br></code></pre></td></tr></table></figure><p>稍微解释一下上述伪代码，对于ViewGroupA来说，点击事件产生后，首先会传递给它（Activity -&gt; (PhoneWindow -&gt; DecorView) -&gt; ViewGroupA），这时它的dispatchTouchEvent()方法就会被调用。若ViewGroupA的onInterceptTouchEvent()返回true就表示它要拦截当前事件，接着事件就会被传递到ViewGroupA的onTouchEvent()方法中；若ViewGroupA的onInterceptTouchEvent()返回false则表示不拦截当前事件，这个事件就会传递给子视图ViewGroupB，接着ViewGroupB的dispatchTouchEvent()方法就会被调用。</p><center>  <img src="/img/Screenshot_1547291939-576x1024 (1)-4193421.png"  style="zoom:50%;" /></center> <br><p>下面我们简单地用几种特殊情况来理解事件分发。</p><h3 id="点击View区域但没有任何View消费事件"><a href="#点击View区域但没有任何View消费事件" class="headerlink" title="点击View区域但没有任何View消费事件"></a>点击View区域但没有任何View消费事件</h3><p><img src="/img/%E6%97%A0%E4%BB%BB%E4%BD%95%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9.png" alt="无任何事件消费（简化）"></p><p><strong>注意：</strong>上图中onInterceptTouchEvent方法返回false后直接调用了子View的dispatchTouchEvent，实际上是ViewGroup的dispatchTouchEvent方法根据onInterceptTouchEvent方法的返回值调用的子View的dispatchTouchEvent方法。后面的图中也是一样的。</p><h3 id="点击View区域且事件被View消费"><a href="#点击View区域且事件被View消费" class="headerlink" title="点击View区域且事件被View消费"></a>点击View区域且事件被View消费</h3><p><img src="/img/View%E6%B6%88%E8%B4%B9.png" alt="View消费了事件（简化）"></p><h3 id="点击View区域但事件被ViewGroupB拦截"><a href="#点击View区域但事件被ViewGroupB拦截" class="headerlink" title="点击View区域但事件被ViewGroupB拦截"></a>点击View区域但事件被ViewGroupB拦截</h3><p><img src="/img/ViewGroupB%E6%8B%A6%E6%88%AA%E4%BA%86%E4%BA%8B%E4%BB%B6.png" alt="ViewGroupB拦截了事件"></p><p><strong>注意：</strong>上图中ViewGroupB的onInterceptTouchEvent方法返回true后，应该是由dispatchTouchEvent来调用onTouchEvent方法。这里分两种情况：如果拦截的事件是初始事件，也就是ACTION_DOWN事件的话，那么ViewGroupB就会调用自己的onTouchEvent方法自己来处理事件；如果拦截的事件不是初始事件的话，它就会把事件交还给Activity来处理，如果Activity.onTouchEvent也不处理的话就抛弃。</p><p>事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 </p><ol><li>如果事件被消费，就意味着事件信息传递终止。</li><li>如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。</li><li>判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。</li></ol><h2 id="事件相关方法调用顺序"><a href="#事件相关方法调用顺序" class="headerlink" title="事件相关方法调用顺序"></a>事件相关方法调用顺序</h2><p>我们知道View可以注册很多监听器，例如单击事件onClick、长按事件onLongClick、触摸事件onTouch，并且View自身也有onTouchEvent()方法，那么这么多监听器到底哪个先执行呢？</p><p>如果我们认真思考一下的话，不需要看源码也能猜出来。</p><p>单击事件onClickListener需要两个事件ACTION_DOWN和ACTION_UP才能触发，如果先分配给它判断会导致其他事件阻塞，显然是不合理的，应该放到最后。</p><p>长按事件onLongClickListener只需要一个事件ACTION_DOWN就能触发，它应该比单击事件更早处理，但是长按也需要长时间等待（相对来说）才能触发，所以应该靠后。</p><p>触摸事件onTouchListener与onTouchEvent方法的区别是触摸事件是交由用户自己处理的，所以应该在最前面，同时会覆盖掉onTouchEvent。</p><p>View自身处理onTouchEvent是默认的一种处理方式，如果用户决定自己处理，也就不需要View自身来处理了，所以顺序应该在触摸事件后面。</p><p><strong>这样的话我们得出了事件方法调用顺序：onTouchListener &gt; onTouchEvent（可能不执行） &gt; onLongClickListener &gt; onClickListener</strong></p><p>查看View中的dispatchTouchEvent()方法源码也能找到结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// result 为返回值，主要作用是告诉调用者事件是否已经被消费。</span><br>    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>        ListenerInfo li = mListenerInfo;<br>        <span class="hljs-comment">/** </span><br><span class="hljs-comment">         * 如果设置了OnTouchListener，并且当前 View 可点击，就调用监听器的 onTouch 方法，</span><br><span class="hljs-comment">         * 如果 onTouch 方法返回值为 true，就设置 result 为 true。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span><br>                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>                &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123;<br>            result = <span class="hljs-keyword">true</span>;<br>        &#125;<br>      <br>        <span class="hljs-comment">/** </span><br><span class="hljs-comment">         * 如果 result 为 false，则调用自身的 onTouchEvent。</span><br><span class="hljs-comment">         * 如果 onTouchEvent 返回值为 true，则设置 result 为 true。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>            result = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>onClick和onLongClick在onTouchEvent()方法中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = event.getAction();<br>  <span class="hljs-comment">// 检查各种 clickable</span><br>    <span class="hljs-keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||<br>            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||<br>            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;<br>        <span class="hljs-keyword">switch</span> (action) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                ...<br>                removeLongPressCallback();  <span class="hljs-comment">// 移除长按</span><br>                ...<br>                performClickInternal();             <span class="hljs-comment">// 检查单击，返回performClick()方法的执行结果</span><br>                ...<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                ...<br>                checkForLongClick(<span class="hljs-number">0</span>,x,y);       <span class="hljs-comment">// 检测长按</span><br>                ...<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                        <span class="hljs-comment">// 表示事件被消费</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结论与分析"><a href="#结论与分析" class="headerlink" title="结论与分析"></a>结论与分析</h2><p><strong>（1）同一个事件序列（gesture）是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</strong></p><p><strong>（2）正常情况下，一个事件序列只能被一个View拦截且消耗。</strong></p><p><strong>（3）某个View一旦决定拦截，那么这个事件序列都只能由它来处理（如果事件序列能传递给它的话），并且它的onInterceptTouchEvent不会再被调用。</strong></p><p>ViewGroup中dispatchTouchEvent()方法源码中有一段描述的是否进行拦截，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Check for interception.</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<br><span class="hljs-comment">// 若当前事件为ACTION_DOWN或者子元素已经处理了事件，判断是否拦截</span><br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>        || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>        intercepted = onInterceptTouchEvent(ev);<br>        ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-keyword">false</span>;<br>    &#125;<br><span class="hljs-comment">// 若当前事件不为ACTION_DOWN，并且没有目标来处理该事件（子元素没有处理初始事件），直接拦截</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span><br>    <span class="hljs-comment">// so this view group continues to intercept touches.</span><br>    intercepted = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述源码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类型为ACTION_DOWN或者mFirstTouchTarget不为null。前者我们知道，那mFirstTarget是什么呢？当事件由ViewGroup的子元素成功处理时，mFirstTarget会被指向子元素，也就是说当ViewGroup不拦截事件并且子元素成功处理时，mFirstTouchTarget != null成立。</p><p>现在我们模拟一种情况，当手指点击在ViewGroup上时，产生一个ACTION_DOWN事件，而当前ViewGroup是允许拦截的（FLAG_DISALLOW_INTERCEPT标志位为false），那么就会调用onInterceptTouchEvent方法判断是否拦截，若返回false，则ViewGroup就不会拦截当前事件，并交给子View进行处理。子View处理完毕后，mFirstTouchTarget会被赋值指向子View。接着手指移动一段距离并松开，产生ACTION_MOVE和ACTION_UP事件，由于此时mFirstTouchEvent != null成立，所以继续判断是否拦截，若ViewGroup决定拦截ACTION_MOVE，那么mFirstTouchEvent会被重置为null，当ACTION_UP被分发的时候，两个条件都不满足则直接进入循环体的else代码语句中，不再调用onInterceptTouchEvent()方法，直接将拦截标志设为true。</p><p>现在用代码来验证一下，在View中消费ACTION_DOWN事件，然后父ViewGroupB拦截ACTION_MOVE，打印日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">D/Activity: dispatchTouchEvent    ACTION_DOWN<br>D/ViewGroupA: dispatchTouchEvent    ACTION_DOWN<br>D/ViewGroupA: onInterceptTouchEvent    ACTION_DOWN<br>D/ViewGroupB: dispatchTouchEvent    ACTION_DOWN<br>D/View: dispatchTouchEvent    ACTION_DOWN<br>D/View: onTouchEvent    消费事件（<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>）<br>D/Activity: dispatchTouchEvent    ACTION_MOVE<br>D/ViewGroupA: dispatchTouchEvent    ACTION_MOVE<br>D/ViewGroupA: onInterceptTouchEvent    ACTION_MOVE<br>D/ViewGroupB: dispatchTouchEvent    ACTION_MOVE<br>D/ViewGroupB: onInterceptTouchEvent    拦截ACTION_MOVE<br>D/View: dispatchTouchEvent    ACTION_CANCEL<br>D/View: onTouchEvent    CANCEL<br>D/Activity: onTouchEvent    ACTION_MOVE<br>D/Activity: dispatchTouchEvent    ACTION_UP<br>D/ViewGroupA: dispatchTouchEvent    ACTION_UP<br>D/ViewGroupA: onInterceptTouchEvent    ACTION_UP<br>D/ViewGroupB: dispatchTouchEvent    ACTION_UP<br>D/Activity: onTouchEvent    ACTION_UP<br></code></pre></td></tr></table></figure><p>可以看到当ACTION_DOWN被View消费之后就不会继续传递了，这时的mFirstTouchTarget指向View，而后续事件ACTION_MOVE被ViewGroupB拦截后，<strong>View会收到一个ACTION_CANCEL事件</strong>，表示这个事件序列的后续处理被取消。ACTION_MOVE事件被拦截后由于没有被消费，就不会再继续传递了，而是直接返回给Activity来处理，后续的ACTION_UP事件也会被ViewGroupB拦截，但这时onInterceptTouchEvent方法并没有被再次调用。</p><p><strong>（4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它处理，并且事件将重新交给它的父元素去处理，即父元素的onTouchEvent会被调用。</strong></p><p><strong>（5）如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续事件，最终这些消失的点击事件会传递给Activity处理。</strong></p><p><strong>（6）ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent默认返回false。</strong></p><p><strong>（7）如果ViewGroup拦截了初始事件（ACTION_DOWN），那么它就会调用自己onTouchEvent方法来处理事件，如果拦截的不是初始事件，那么它不会自己处理，而是将事件返回给Activity。</strong></p><p><strong>（8）如果View当前处理的事件被上层ViewGroup拦截，View会收到一个ACTION_CANCEL事件，后续事件不会再传递过来。</strong></p><p><strong>（9）View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</strong></p><p><strong>（10）View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable属性同时为false）。View的longClickable属性默认都为false，而clickable属性要看子类具体实现。</strong></p><p><strong>（11）View的enable属性不影响onTouchEvent的默认返回值。</strong></p><p><strong>（12）onClick会发生的前提是View是可点击的（clickable），并且它收到了down和up事件。</strong></p><p><strong>（13）事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</strong></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://developer.android.google.cn/reference/android/view/MotionEvent">MotionEvent</a></p><p><a href="https://book.douban.com/subject/26599538/">《Android开发艺术探索》</a></p><p><a href="http://www.gcssloop.com/customview/dispatch-touchevent-source">安卓自定义View进阶-事件分发机制详解</a></p><p><a href="http://wuxiaolong.me/2015/12/19/MotionEvent/">Android事件传递机制分析</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/9097463">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/9153747">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Touch Event</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View的绘制流程</title>
    <link href="/2018/12/10/bfd836fe/"/>
    <url>/2018/12/10/bfd836fe/</url>
    
    <content type="html"><![CDATA[<h2 id="ViewRoot和Decor"><a href="#ViewRoot和Decor" class="headerlink" title="ViewRoot和Decor"></a>ViewRoot和Decor</h2><p>ViewRoot对应与VieRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程（Measure、Layout和Draw）均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。</p><p>DecorView作为顶级View，一般情况下它会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况跟Android版本及主体Theme有关），上面为标题栏，如下图的TitleBar，下面为内容懒，如下图的ContentView。通过源码我们可以知道，DecorView其实是一个FrameLayotu，View层的事件都先经过DecorView，然后才传递给我们的View。</p><p><img src="/img/View%E7%AA%97%E5%8F%A3-1.png" alt="View窗口"></p><p>PhoneWindow为Window类的实现类，DecorView即顶级View，是PhoneWindow的子类。</p><h2 id="View树的绘制机制"><a href="#View树的绘制机制" class="headerlink" title="View树的绘制机制"></a>View树的绘制机制</h2><p>当Activity接收到焦点的时候，它会被请求绘制布局，该请求由Android Framework处理，绘制是从根节点开始，对布局树进行measure和draw。整个View树的绘图流程在<strong>ViewRoot.java</strong>类中的**performTraversal()**函数展开，该方法所做的工作可简单概括为以下几点：</p><ul><li>是否需要重新计算视图大小（measure）</li><li>是否需要重新安置视图的位置（layout）</li><li>是否需要重新绘制视图（draw）</li></ul><p><img src="/img/performTraversals.png" alt="performTraversals"></p><p>performTraversals这个方法会一次调用performMeasure、performLayout、performDraw三个方法，这三个方法分别完成顶级View（DecorView）的<strong>Measure</strong>、<strong>Layout</strong>和<strong>Draw</strong>这三大流程，其中在 performMeasure会调用measure方法，measure方法又会调用onMeasure方法，在onMeasure方法中会对所有子视图进行measure过程，子视图重复父视图的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过没有本质区别。</p><p>从整体上来看 Measure 和 Layout 两个步骤的执行： </p><p><img src="/img/measure_and_layout_process.png" alt="measure和layout过程"></p><p><strong>总的来说，树的遍历是有序的，由父视图到子视图，每一个 ViewGroup 负责测绘它所有的子视图，而最底层的 View 会负责测绘自身。</strong> </p><p><strong>View绘制流程函数调用链</strong></p><p><img src="/img/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="View绘制流程调用链"></p><p><strong>如果用户主动调用requestLayout()，只会触发measure和layout过程而不会执行draw过程。</strong></p><h2 id="MeasureSpec和LayoutParams"><a href="#MeasureSpec和LayoutParams" class="headerlink" title="MeasureSpec和LayoutParams"></a>MeasureSpec和LayoutParams</h2><p>MeasureSpec和LayoutParams是Measure过程中传递尺寸的两个类，在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对象的MeasureSpec ，然后再根据这个MeasureSpec来测量出View的宽和高。</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec代表一个32位的int值，高2位代表SpecMode，测量模式，低30位代表SpecSize，规格尺寸。</p><p>SpecMode有三类，每一类都表示特殊的含义：</p><p><strong>UNSPECIFIED</strong></p><p>父容器不对View有任何限制，它可以达到所期望的任意尺寸，这种情况一般用于系统内部，如ListView、ScrollView，一般自定义View用不到。</p><p><strong>EXACTLY</strong></p><p>父视图为子视图指定一个确切的尺寸，而且无论子视图期望多大，它都必须在该指定大小的边界内，对应的属性为 match_parent 或具体值，比如 100dp，父控件可以通过**MeasureSpec.getSize(measureSpec)**直接得到子控件的尺寸。 </p><p><strong>AT_MOST</strong></p><p>父视图为子视图指定一个最大尺寸SpecSize，子视图必须确保它自己所有子视图可以适应在该尺寸范围内，对应的属性为 wrap_content。这种模式下，父控件无法确定子 View 的尺寸，只能由子控件自己根据需求去计算自己的尺寸，这种模式就是我们自定义视图需要实现测量逻辑的情况。 </p><h3 id="ViewGroup-LayoutParams"><a href="#ViewGroup-LayoutParams" class="headerlink" title="ViewGroup.LayoutParams"></a>ViewGroup.LayoutParams</h3><p>这个类我们很常见，就是用来指定视图的高度和宽度等参数。对于每个视图的 height 和 width，你有以下选择：</p><ul><li>具体值</li><li>MATCH_PARENT 表示子视图希望和父视图一样大(不包含 padding 值)</li><li>WRAP_CONTENT 表示视图为正好能包裹其内容大小(包含 padding 值)</li></ul><h3 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a>MeasureSpec和LayoutParams的对应关系</h3><p>在View测量的时候，系统会将LayoutParams在父容器的约束下转换成相应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽和高。注意，<strong>MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec</strong>，从而进一步决定View的宽和高。</p><p>对于顶级View（DecorView）和普通View来说，MeasureSpec的转换过程略有不同。对于DecorView，其MeasureSpec由窗口的尺寸和自身的LayoutParams来共同确定；对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽和高了。</p><p><img src="/img/e6a69616e7368751.png" alt="View的MeasureSpec创建规则"></p><blockquote><p>注意：</p><p>图上有一处错误，当parent指定子View的MeasureSpecMode为UNSPECIFIED时，子View的尺寸实际上是没有限制的，而不是0。</p><p>也就是说子View的大小可以超过父VIew，当然子View实际上不能超过父View的区域进行绘制，这种情况我们经常接触，对应RecyclerView或者ListView内部的情况。</p><p>RecyclerView或者ListView将子View的SpecMode设置为UNSPECIFIED，表示子View可以不必受父View限制来测量自身大小，当子View超过父View的大小时，RecyclerView/ListView通过滚动的方式将子View完整展示出来。</p></blockquote><h2 id="三大流程分析"><a href="#三大流程分析" class="headerlink" title="三大流程分析"></a>三大流程分析</h2><p>Measure过程决定了View<strong>测量后的宽和高</strong>，注意是测量后的宽和高，<strong>某些情况下并不等同于最终的宽和高</strong>。Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽和高。</p><p>Layout过程决定了View的四个顶点的坐标和<strong>实际的View的宽和高，</strong>完成以后，可以通过getTop、getButton、getLeft和getRight来拿到View的四个顶点的位置，并可以通过getWidth和getHeight方法拿到最终View的宽和高。</p><p>Draw过程则决定了View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。</p><h3 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h3><p>Measure过程要分情况来看。 如果只是一个原始的View，那么通过**measure(int widthMeasureSpec, int heightMeasureSpec)**方法就完成了其测量过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子视图的measure方法，各个子视图再递归地去执行这个流程。</p><h4 id="View的Measure过程"><a href="#View的Measure过程" class="headerlink" title="View的Measure过程"></a>View的Measure过程</h4><p>View的Measure过程由其measure方法来完成，meausre方法是一个final方法，不能被重写，measure方法中会调用View的onMeasure方法，onMeasure方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),<br>            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法就是我们自定义View中需要重写来实现测量逻辑的方法。可以看到Measure过程最终方法是setMeasuredDimension()方法，该方法会设置View宽高的测量值，看看getDefaultSize()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = size;<br>    <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>    <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>        result = size;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>    <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>        result = specSize;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于我们来说只需要关心AT_MOST和EXACTLY两种情况，可以看到，返回的结果其实就是measureSpec中的specSize，而这个specSize就是View测量后的大小。至于UNSPECIFIED这种情况，一般用于系统内部的测量过程，这种情况下返回的是第一个参数size，也就是getSuggestedMinimumWidth()和getSuggestedMinimumHeight()两个函数的返回值。</p><p>以getSuggestedMinimumWidth()为例介绍一下这个默认值是怎么来的：</p><ul><li>View没有设置背景：返回<strong>android:minWidth</strong>这个属性所指定的值，这个值可以为0</li><li>View设置了背景：返回<strong>android:minWidth</strong>与<strong>背景的最小宽度</strong>两者的最大值</li></ul><p>从getDefaultSize方法的实现来看，View的宽高由specSize决定，所以可以得出如下结论：</p><p><strong>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</strong></p><h4 id="ViewGroup的Measure过程"><a href="#ViewGroup的Measure过程" class="headerlink" title="ViewGroup的Measure过程"></a>ViewGroup的Measure过程</h4><p>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子视图的measure方法，各个子视图再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，但是它提供了一个叫measureChildren的方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求所有子 View 去 measure 自己，要考虑的部分有对子 View 的测绘要求 </span><br><span class="hljs-comment"> MeasureSpec 以及其自身的 padding</span><br><span class="hljs-comment"> * 这里跳过所有为 GONE 状态的子 View，最繁重的工作是在 getChildMeasureSpec </span><br><span class="hljs-comment"> 方法中处理的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> widthMeasureSpec  对该 View 的 width 测绘要求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> heightMeasureSpec 对该 View 的 height 测绘要求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> View child = children[i];<br>        <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，ViewGroup在measure时，会调用measureChild对每一个子视图进行measure，measureChild源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> LayoutParams lp = child.getLayoutParams();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,<br>            mPaddingLeft + mPaddingRight, lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,<br>            mPaddingTop + mPaddingBottom, lp.height);<br><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>&#125;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 该方法是 measureChildren 中最繁重的部分，为每一个 ChildView 计算出自己的 MeasureSpec。</span><br><span class="hljs-comment"> * 目标是将 parentView 的 MeasureSpec 和 childView 的LayoutParams 结合起来去得到一个最合适的结果。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spec 对该 View 的测绘要求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> padding 当前 View 在当前唯独上的 paddingand，也有可能含有 margins</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> childDimension 在当前维度上（height 或 width）的具体指</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 子视图的 MeasureSpec </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> padding, <span class="hljs-keyword">int</span> childDimension)</span> </span>&#123;<br><br>        .........<br><br>    <span class="hljs-comment">// 根据获取到的子视图的测量要求和大小创建子视图的 MeasureSpec</span><br>    <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里验证了我们上面所说的，子视图的measure需要父容器的MeasureSpec和自身的LayoutParams，通过getChildMeasureSpec方法来得到自身的MeasureSpec，然后将MeasureSpec传递给子视图的measure方法来进行测量。</p><p><img src="/img/measure%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="ViewGroup的Measure流程"></p><p>View的Measure过程是三大流程中最复杂的一个，Measure完成以后，通过getMeasuredWidth/getMeasuredHeight方法就可以正确地获取到View的测量宽高。但是，在某些极端情况下，系统可能需要多次Measure才能确定最终的测量宽高，所以，比较稳妥的方法是在onLayout方法中去获取View的测量宽高或最终宽高。</p><h3 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h3><p>Layout的作用是ViewGroup用来确定子视图的位置（<strong>相对于父视图</strong>），当ViewGroup的位置被确定后，它在onLayout会遍历所有的子视图并调用其layout方法，在layout方法中onLayout方法又会被调用。layout方法是用来确定View本身的位置的，onLayout方法则是用来确认所有子视图的位置的。View的layout方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;<br>        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);<br>        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> oldL = mLeft;<br>    <span class="hljs-keyword">int</span> oldT = mTop;<br>    <span class="hljs-keyword">int</span> oldB = mBottom;<br>    <span class="hljs-keyword">int</span> oldR = mRight;<br><br>    <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?<br>            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<br><br>    <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<br>        onLayout(changed, l, t, r, b);<br><br>        <span class="hljs-keyword">if</span> (shouldDrawRoundScrollbar()) &#123;<br>            <span class="hljs-keyword">if</span>(mRoundScrollbarRenderer == <span class="hljs-keyword">null</span>) &#123;<br>                mRoundScrollbarRenderer = <span class="hljs-keyword">new</span> RoundScrollbarRenderer(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mRoundScrollbarRenderer = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;<br><br>        ListenerInfo li = mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="hljs-keyword">null</span>) &#123;<br>            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =<br>                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();<br>            <span class="hljs-keyword">int</span> numListeners = listenersCopy.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                listenersCopy.get(i).onLayoutChange(<span class="hljs-keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> wasLayoutValid = isLayoutValid();<br><br>    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;<br>    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;<br>    ··· ···<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为该子 View 设置相对其父视图上的坐标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会通过setFrame方法来设定View的四个顶点的位置，从而确定View在父容器中的位置，接着会调用onLayout方法来确定子视图的位置。跟onMeasure方法一样，onLayout的实现也跟具体布局有关，所以View和ViewGroup都没有实现onLayout方法，都是交给子类去实现。不过我们可以看看LinearLayout的onLayout方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;<br>          layoutVertical(l, t, r, b);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          layoutHorizontal(l, t, r, b);<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 遍历所有的子 View，为其设置相对父视图的坐标</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layoutVertical</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;<br>  ···<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>              <span class="hljs-keyword">final</span> View child = getVirtualChildAt(i);<br>              <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>                  childTop += measureNullChild(i);<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.getVisibility() != GONE) &#123;<span class="hljs-comment">//不需要立即展示的 View 设置为 GONE 可加快绘制</span><br>                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidth = child.getMeasuredWidth();<span class="hljs-comment">//measure 过程确定的 Width</span><br>                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeight = child.getMeasuredHeight();<span class="hljs-comment">//measure 过程确定的 height</span><br><br>                  ...确定 childLeft、childTop 的值<br><br>                  setChildFrame(child, childLeft, childTop + getLocationOffset(child),<br>                          childWidth, childHeight);<br>              &#125;<br>          &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildFrame</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;        <br>      child.layout(left, top, left + width, top + height);<br>  &#125; <br></code></pre></td></tr></table></figure><p>可以看到，layoutVertical方法会遍历所有子视图并调用serChildFrame方法来为子视图指定对应的位置，其中childTop会逐渐增大，刚好符合竖直方向LinearLayou的特性。而setChildFrame方法其实就是调用了子视图的layout方法，这样子视图就能通过layout方法来确定自己的位置，这样一层一层传递下去就完成了整个View树的Layout过程。</p><h3 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h3><p>Draw过程比较简单，它的工作就是讲View绘制到平面上面。View的绘制过程遵循如下几步：</p><ol><li>绘制背景background.draw(Canvas canvas)</li><li>绘制自己（onDraw）</li><li>绘制children（dispatchDraw）</li><li>绘制装饰（onDrawScrollBars）</li></ol><p>通过源码可以清晰的看出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Manually render this view (and all of its children) to the given Canvas.</span><br><span class="hljs-comment"> * The view must have already done a full layout before this function is</span><br><span class="hljs-comment"> * called.  When implementing a view, implement</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</span><br><span class="hljs-comment"> * If you do need to override this method, call the superclass version.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> canvas The Canvas to which the View is rendered.  </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 根据给定的 Canvas 自动渲染 View（包括其所有子 View）。在调用该方法之前必须要完成 layout。当你自定义 view 的时候，</span><br><span class="hljs-comment"> * 应该去是实现 onDraw(Canvas) 方法，而不是 draw(canvas) 方法。如果你确实需要复写该方法，请记得先调用父类的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br><br>    / * Draw traversal performs several drawing steps which must be executed<br>     * in the appropriate order:<br>     *<br>     *      <span class="hljs-number">1.</span> Draw the background <span class="hljs-keyword">if</span> need<br>     *      <span class="hljs-number">2.</span> If necessary, save the canvas<span class="hljs-string">&#x27; layers to prepare for fading</span><br><span class="hljs-string">     *      3. Draw view&#x27;</span>s content<br>     *      <span class="hljs-number">4.</span> <span class="hljs-function">Draw <span class="hljs-title">children</span> <span class="hljs-params">(dispatchDraw)</span></span><br><span class="hljs-function">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class="hljs-function">     *      6. Draw <span class="hljs-title">decorations</span> <span class="hljs-params">(scrollbars <span class="hljs-keyword">for</span> instance)</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function"></span><br><span class="hljs-function"> <span class="hljs-comment">// Step 1, draw the background, if needed</span></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(!dirtyOpaque)</span> </span>&#123;<br>        drawBackground(canvas);<br>    &#125;<br><br>     <span class="hljs-comment">// skip step 2 &amp; 5 if possible (common case)</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> viewFlags = mViewFlags;<br>    <span class="hljs-keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;<br>        <span class="hljs-comment">// Step 3, draw the content</span><br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br><br>        <span class="hljs-comment">// Step 4, draw the children</span><br>        dispatchDraw(canvas);<br><br>        <span class="hljs-comment">// Step 6, draw decorations (scrollbars)</span><br>        onDrawScrollBars(canvas);<br><br>        <span class="hljs-keyword">if</span> (mOverlay != <span class="hljs-keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;<br>            mOverlay.getOverlayView().dispatchDraw(canvas);<br>        &#125;<br><br>        <span class="hljs-comment">// we&#x27;re done...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Step 2, save the canvas&#x27; layers</span><br>    ...<br><br>    <span class="hljs-comment">// Step 3, draw the content</span><br>    <span class="hljs-keyword">if</span> (!dirtyOpaque) <br>        onDraw(canvas);<br><br>    <span class="hljs-comment">// Step 4, draw the children</span><br>    dispatchDraw(canvas);<br><br>    <span class="hljs-comment">// Step 5, draw the fade effect and restore layers</span><br><br>    <span class="hljs-comment">// Step 6, draw decorations (scrollbars)</span><br>    onDrawScrollBars(canvas);<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的处理过程，我们也可以得出一些优化的小技巧：当不需要绘制 Layer 的时候第二步和第五步会跳过。<strong>因此在绘制的时候，能省的 layer 尽可省，可以提高绘制效率。</strong></p><p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子视图的draw方法，将draw事件传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">dispatchDraw(Canvas canvas)&#123;<br><br>...<br><br> <span class="hljs-keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="hljs-number">0</span> &amp;&amp; canAnimate()) &#123;<span class="hljs-comment">//处理 ChildView 的动画</span><br>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> buildCache = !isHardwareAccelerated();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;<br>                <span class="hljs-keyword">final</span> View child = children[i];<br>                <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;<span class="hljs-comment">//只绘制 Visible 状态的布局，因此可以通过延时加载来提高效率</span><br>                    <span class="hljs-keyword">final</span> LayoutParams params = child.getLayoutParams();<br>                    attachLayoutAnimationParameters(child, params, i, childrenCount);<span class="hljs-comment">// 添加布局变化的动画</span><br>                    bindLayoutAnimation(child);<span class="hljs-comment">//为 Child 绑定动画</span><br>                    <span class="hljs-keyword">if</span> (cache) &#123;<br>                        child.setDrawingCacheEnabled(<span class="hljs-keyword">true</span>);<br>                        <span class="hljs-keyword">if</span> (buildCache) &#123;<br>                            child.buildDrawingCache(<span class="hljs-keyword">true</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>     <span class="hljs-keyword">final</span> LayoutAnimationController controller = mLayoutAnimationController;<br>            <span class="hljs-keyword">if</span> (controller.willOverlap()) &#123;<br>                mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;<br>            &#125;<br><br>    controller.start();<span class="hljs-comment">// 启动 View 的动画</span><br>&#125;<br><br> <span class="hljs-comment">// 绘制 ChildView</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;<br>            <span class="hljs-keyword">final</span> View child = (preorderedList == <span class="hljs-keyword">null</span>)<br>                    ? children[childIndex] : preorderedList.get(childIndex);<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                more |= drawChild(canvas, child, drawingTime);<br>            &#125;<br>        &#125;<br><br>...<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is called by ViewGroup.drawChild() to have each child view draw itself.</span><br><span class="hljs-comment">     * This draw() method is an implementation detail and is not intended to be overridden or</span><br><span class="hljs-comment">     * to be called from anywhere else other than ViewGroup.drawChild().</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="其他方法补充"><a href="#其他方法补充" class="headerlink" title="其他方法补充"></a>其他方法补充</h2><h3 id="View-setWillNotDraw-boolean-willNotDraw"><a href="#View-setWillNotDraw-boolean-willNotDraw" class="headerlink" title="View.setWillNotDraw(boolean willNotDraw)"></a>View.setWillNotDraw(boolean willNotDraw)</h3><p>当我们的自定义View继承于ViewGroup并且本身不需要进行绘制时，就开启（true）这个标志位以便于系统进行后续的优化。</p><h3 id="View-invalidate"><a href="#View-invalidate" class="headerlink" title="View.invalidate()"></a>View.invalidate()</h3><p>请求重绘 View 树，即 draw 过程，假如视图大小没有变化就不会调用Layout过程，并且只绘制那些调用了invalidate()方法的 View。 </p><h3 id="View-requestLayout"><a href="#View-requestLayout" class="headerlink" title="View.requestLayout()"></a>View.requestLayout()</h3><p>当布局变化的时候，比如方向变化，尺寸的变化，会调用该方法，在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发Measure和Layout过程，但不会进行 draw。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/topics/ui/how-android-draws">How Android Draws Views</a></p><p><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f">公共技术点之 View 绘制流程</a></p><p><a href="https://book.douban.com/subject/26599538/">《Android开发艺术探索》</a></p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AsyncTask源码详解</title>
    <link href="/2018/11/04/c28d723e/"/>
    <url>/2018/11/04/c28d723e/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>Callable的接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span> </span>&#123;   <br>       <span class="hljs-function">V   <span class="hljs-title">call</span><span class="hljs-params">()</span>   <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Callable接口声明了一个名称为call()的方法，该方法可以有返回值V，也可以抛出异常。Callable也是一个线程接口，它与Runnable的主要区别就是Callable在线程执行完成后可以有返回值而Runnable没有返回值，Runnable接口声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>那么Callable接口如何使用呢，Callable需要和ExcutorService结合使用，其中ExecutorService也是一个线程池对象继承自Executor接口，接着看看ExecutorService提供了那些方法供我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<br>Future&lt;?&gt; submit(Runnable task);<br></code></pre></td></tr></table></figure><ul><li>submit(Callable task)，传递一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</li><li> submit(Runnable task, T result)，传递一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</li><li>submit(Runnable task)，传递一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</li></ul><p>因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。Callable接口介绍就先到这，再来看看Future时什么鬼。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get()),取消(cancel()),判断是否完成等操作。其方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//取消任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><br>    <span class="hljs-comment">//如果任务完成前被取消，则返回true。</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</span><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br>    <span class="hljs-comment">// 获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，</span><br>    <span class="hljs-comment">//如果阻塞时间超过设定的timeout时间，该方法将返回null。</span><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总得来说Future有以下3点作用：</p><ul><li>能够中断执行中的任务</li><li>判断任务是否执行完成</li><li>获取任务执行完成后额结果。</li></ul><p>但是Future只是接口，我们根本无法将其创建为对象，于官方又给我们提供了其实现类FutureTask，这里我们要知道前面两个接口的介绍都只为此类做铺垫，毕竟AsncyTask中使用到的对象是FutureTask。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>先来看看FutureTask的实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">FutureTask</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">RunnableFuture</span> &#123; <br>&#125;<br></code></pre></td></tr></table></figure><p>RunnableFuture接口的实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">RunnableFuture</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Runnable</span>, <span class="hljs-symbol">Future</span> &#123;<br>     <span class="hljs-built_in">void</span> run();<br>&#125;<br></code></pre></td></tr></table></figure><p>从接口实现可以看出，FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask既可以当做Future对象也可是Runnable对象，当然FutureTask也就可以直接提交给线程池来执行。接着我们最关心的是如何创建FutureTask对象，实际上可以通过如下两个构造方法来构建FutureTask：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">FutureTask</span>(<span class="hljs-params">Callable&lt;V&gt; callable</span>)</span> &#123;  <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">FutureTask</span>(<span class="hljs-params">Runnable runnable, V result</span>)</span> &#123;  <br>&#125;<br></code></pre></td></tr></table></figure><p>从构造方法看出，我们可以把一个实现了Callable或者Runnable的接口的对象封装成一个FutureTask对象，然后通过线程池去执行。</p><h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>通常我们使用AsyncTask时，会自定义一个IAsyncTask继承自AsyncTask，然后调用其execute()方法来执行任务，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> IAsyncTask(<span class="hljs-string">&quot;IAsyncTask-1&quot;</span>).execute(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>入口是execute()方法，查看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">execute</span><span class="hljs-params">(Params... params)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> executeOnExecutor(sDefaultExecutor, params);<br>&#125;<br></code></pre></td></tr></table></figure><p>execute()方法没有做任何操作，而是直接调用了executeOnExecutor()方法，并传入了<em>sDefaultExecutor</em>和参数params，这个<em>sDefaultExecutor</em>是什么呢？看名字我们应该猜到它是一个线程池，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor SERIAL_EXECUTOR = <span class="hljs-keyword">new</span> SerialExecutor();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;<br></code></pre></td></tr></table></figure><p>SerialExecutor是AsyncTask四个内部类中的一个，它实现了Executor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> ArrayDeque&lt;Runnable&gt;();<br>    Runnable mActive;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable r)</span> </span>&#123;<br>        mTasks.offer(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">// 插入一个Runnable任务</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    r.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    scheduleNext();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 如果当前没有任务进行</span><br>        <span class="hljs-keyword">if</span> (mActive == <span class="hljs-keyword">null</span>) &#123;<br>            scheduleNext();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((mActive = mTasks.poll()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//从任务队列mTasks中取出任务并放到THREAD_POOL_EXECUTOR线程池中执行.</span><br>            <span class="hljs-comment">//由此也可见任务默认是串行进行的。</span><br>            THREAD_POOL_EXECUTOR.execute(mActive);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看出，SerialExecutor维护了一个存放任务队列的容器ArrayDeque和一个正在执行的任务Runnable，其工作就是当用户调用execute方法时将任务存放到任务队列中，并交给THREAD_POOL_EXECUTOR串行的处理。 </p><p>由此可见SerialExecutor并不是真正的线程执行者，它只是是保证传递进来的任务Runnable（实例是一个FutureTask）串行执行，而真正执行任务的是THREAD_POOL_EXECUTOR线程池。接下来我们看看THREAD_POOL_EXECUTOR：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();<br><span class="hljs-comment">// 核心线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="hljs-number">2</span>, Math.min(CPU_COUNT - <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">// 线程池最大容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 保活时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> KEEP_ALIVE_SECONDS = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 阻塞队列，默认容量128</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">128</span>);<br><span class="hljs-comment">// 线程工厂</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadFactory sThreadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger mCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;AsyncTask #&quot;</span> + mCount.getAndIncrement());<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor THREAD_POOL_EXECUTOR;<br><br><span class="hljs-keyword">static</span> &#123;<br>    ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,<br>            sPoolWorkQueue, sThreadFactory);<br>    threadPoolExecutor.allowCoreThreadTimeOut(<span class="hljs-keyword">true</span>);<br>    THREAD_POOL_EXECUTOR = threadPoolExecutor;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于线程池先看到这，我们之前讲到用户调用execute()方法实际是调用了executeOnExecutor()方法，看看它做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">executeOnExecutor</span><span class="hljs-params">(Executor exec,</span></span><br><span class="hljs-function"><span class="hljs-params">        Params... params)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前状态</span><br>    <span class="hljs-keyword">if</span> (mStatus != Status.PENDING) &#123;<br>        <span class="hljs-keyword">switch</span> (mStatus) &#123;<br>            <span class="hljs-comment">// 同一任务只被执行一次</span><br>            <span class="hljs-keyword">case</span> RUNNING:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Cannot execute task:&quot;</span><br>                        + <span class="hljs-string">&quot; the task is already running.&quot;</span>);<br>            <span class="hljs-keyword">case</span> FINISHED:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Cannot execute task:&quot;</span><br>                        + <span class="hljs-string">&quot; the task has already been executed &quot;</span><br>                        + <span class="hljs-string">&quot;(a task can be executed only once)&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    mStatus = Status.RUNNING;<br>    <span class="hljs-comment">// 这里调用了我们自己实现的onPreExecute方法</span><br>    onPreExecute();<br>    <span class="hljs-comment">//参数传递给了mWorker.mParams</span><br>    mWorker.mParams = params;<br>    <span class="hljs-comment">// 执行了线程池THREAD_POOL_EXECUTOR的execute方法</span><br>    exec.execute(mFuture);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从executeOnExecutor方法的源码分析得知，执行任务前先会去判断当前AsyncTask的状态，如果处于RUNNING和FINISHED状态就不可再执行，直接抛出异常，只有处于Status.PENDING时，AsyncTask才会去执行。然后onPreExecute()被执行的，该方法可以用于线程开始前做一些准备工作。接着会把我们传递进来的参数赋值给 mWorker.mParams ，并执行开始执行mFuture任务，那么mWorker和mFuture到底是什么？先看看mWorker即WorkerRunnable的声明源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerRunnable</span>&lt;<span class="hljs-title">Params</span>, <span class="hljs-title">Result</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Result</span>&gt; </span>&#123;<br>    Params[] mParams;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现WorkerRunnable是个抽象类，存在一个参数数组，并且实现了Callable方法。既然WorkerRunnable是个抽象类，那么肯定会有具体的实现类来进行实例化，果然，在AsyncTask的构造方法中有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;<br>    mHandler = callbackLooper == <span class="hljs-keyword">null</span> || callbackLooper == Looper.getMainLooper()<br>        ? getMainHandler()<br>        : <span class="hljs-keyword">new</span> Handler(callbackLooper);<br>    <span class="hljs-comment">// 创建WorkerRunnable mWorker，本质上就是一个实现了Callable接口对象</span><br>    mWorker = <span class="hljs-keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-comment">// 设置标志</span><br>            mTaskInvoked.set(<span class="hljs-keyword">true</span>);<br>            Result result = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<br>                <span class="hljs-comment">// 执行DoInBackGround方法，取得结果</span><br>                result = doInBackground(mParams);<br>                Binder.flushPendingCommands();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable tr) &#123;<br>                mCancelled.set(<span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">throw</span> tr;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 调用postResult方法更新结果</span><br>                postResult(result);<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 把mWorker（即Callable实现类）封装成FutureTask实例</span><br>    <span class="hljs-comment">// 最终执行结果也就封装在FutureTask中</span><br>    mFuture = <span class="hljs-keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;<br>        <span class="hljs-comment">// 任务执行完成后被调用</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果还没更新结果通知就执行postResultIfNotInvoked</span><br>                postResultIfNotInvoked(get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                android.util.Log.w(LOG_TAG, e);<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;An error occurred while executing doInBackground()&quot;</span>,<br>                        e.getCause());<br>            &#125; <span class="hljs-keyword">catch</span> (CancellationException e) &#123;<br>                postResultIfNotInvoked(<span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在初始化AsyncTask时，不仅创建了mWorker（本质实现了Callable接口的实例类）而且也创建了FutureTask对象，并把mWorker对象封装在FutureTask对象中，最后FutureTask对象将在executeOnExecutor方法中通过线程池去执行。</p><p>AsynTask在初始化时会创建mWorker实例对象和FutureTask实例对象，mWorker是一个实现了Callable线程接口并封装了传递参数的实例对象，然后mWorker实例会被封装成FutureTask实例中。在AsynTask创建后，我们调用execute方法去执行异步线程，其内部又直接调用了executeOnExecutor方法，并传递了线程池exec对象和执行参数，该方法内部通过线程池exec对象去执行mFuture实例，这时mWorker内部的call方法将被执行并调用doInBackground方法，最终通过postResult去通知更新结果。关于postResult方法,其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Result <span class="hljs-title">postResult</span><span class="hljs-params">(Result result)</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,<br>            <span class="hljs-keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="hljs-keyword">this</span>, result));<br>    message.sendToTarget();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然是通过Handler去执行结果更新的，在执行结果成返回后，会把result封装到一个AsyncTaskResult对象中，最后把MESSAGE_POST_RESULT标示和AsyncTaskResult存放到Message中并发送给Handler去处理，这里我们先看看AsyncTaskResult的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTaskResult</span>&lt;<span class="hljs-title">Data</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> AsyncTask mTask;<br>    <span class="hljs-keyword">final</span> Data[] mData;<br><br>    AsyncTaskResult(AsyncTask task, Data... data) &#123;<br>        mTask = task;<br>        mData = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然AsyncTaskResult封装了执行结果的数组以及AsyncTask本身，这个没什么好说的，接着看看AsyncTaskResult被发送到handler后如何处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InternalHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(looper);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> MESSAGE_POST_RESULT:<br>                <span class="hljs-comment">// There is only one result</span><br>                result.mTask.finish(result.mData[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MESSAGE_POST_PROGRESS:<br>                result.mTask.onProgressUpdate(result.mData);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过handler发送过来的不同标志去决定执行那种结果，如果标示为MESSAGE_POST_RESULT则执行AsyncTask的finish方法并传递执行结果给该方法，finish方法源码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(Result result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isCancelled()) &#123;<span class="hljs-comment">// 判断任务是否被取消</span><br>        onCancelled(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 执行onPostExecute(result)并传递result结果</span><br>        onPostExecute(result);<br>    &#125;<br>    mStatus = Status.FINISHED;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法先判断任务是否被取消，如果没有被取消则去执行onPostExecute(result)方法，外部通过onPostExecute方法去更新相关信息，如UI，消息通知等。最后更改AsyncTask的状态为已完成。到此AsyncTask的全部流程执行完。 </p><p>这里还有另一种标志MESSAGE_POST_PROGRESS，该标志是我们在doInBackground方法中调用publishProgress方法时发出的，该方法原型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishProgress</span><span class="hljs-params">(Progress... values)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isCancelled()) &#123;<br>        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,<br>                <span class="hljs-keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="hljs-keyword">this</span>, values)).sendToTarget();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法执行流程：</p><p><img src="/img/426077-20170220202059273-943906034-1024x715.png" alt="时序图"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.google.cn/reference/android/os/AsyncTask">AsyncTask</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/52464139">android多线程-AsyncTask之工作原理深入解析(下)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AsyncTask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler机制基本原理</title>
    <link href="/2018/10/29/e7df41f4/"/>
    <url>/2018/10/29/e7df41f4/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由于Android本身是线程不安全的，为了解决多线程并发的问题，Android提供了一套原生异步消息处理机制——Handler机制。Handler机制主要涉及到四个类：Handler、Looper、Message和MessageQueue。</p><p><img src="/img/2018123122095360.png" alt="Handler机制"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="创建Handler对象"><a href="#创建Handler对象" class="headerlink" title="创建Handler对象"></a>创建Handler对象</h3><p>方式一：在主线程中创建Handler对象，并重写其handMessage方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Handler uiHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (msg.what)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-comment">// 处理消息</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 由于<strong>非静态内部类、匿名内部类会隐式地持有外部类的引用</strong>，虽然仅仅持有引用并不会引起内存泄漏，但是如果有什么延时的操作，而且进行某个延时操作的对象还必须以持有外部类为基础才能进行的，这个时候就内存泄漏了 。所以若使用方式一，则需要在Activity的onDestroy()方法中调用Handler中的**removeCallbackAndMessages(null)**方法防止内存泄漏。</p><p>方式二（推荐)：使用静态内部类+弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UIHandler uiHandler = <span class="hljs-keyword">new</span> UIHandler(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UIHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UIHandler</span><span class="hljs-params">(MainActivity activity)</span></span>&#123;<br>        mActivity = <span class="hljs-keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mActivity.get()!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">switch</span> (msg.what)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在子线程中使用下列方法将Message发出"><a href="#在子线程中使用下列方法将Message发出" class="headerlink" title="在子线程中使用下列方法将Message发出"></a>在子线程中使用下列方法将Message发出</h3><ol><li>post(Runnable)</li><li>postDelayed(Runnable,long)</li><li>sendMessage(Message)</li><li>sendMessageDelayed(Message, long)</li></ol><h2 id="核心类解析"><a href="#核心类解析" class="headerlink" title="核心类解析"></a>核心类解析</h2><h3 id="消息的封装类：Message"><a href="#消息的封装类：Message" class="headerlink" title="消息的封装类：Message"></a>消息的封装类：Message</h3><p>Message的主要功能是进行消息的封装，同时可以指定消息的操作形式，常用的属性有：</p><ol><li><p>public int what：最常用变量，作为一个Message的标识，<br>定义此Message属于何种操作</p></li><li><p> public Object obj：变量，用于定义此Message传递的信息数据，通过它传递信息 </p></li><li><p> public int arg1：变量，传递一些整型数据时使用 </p></li><li><p> public int arg2：变量，传递一些整型数据时使用 </p></li><li><p>Handler target：变量，发送和处理该Message的Handler</p><p>在整个消息处理机制中，Message又叫Task，封装了任务携带的<strong>信息</strong>和处理该任务的<strong>Handler</strong>。Message的用法比较简单，但是有这么几点需要注意：</p></li></ol><p>（1）尽管Message有public的默认构造方法，但是你应该通过Message.**obtain()**来从消息池中获得空消息对象，以节省资源。</p><p>（2）如果你的Message只需要携带简单的<strong>int</strong>信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</p><p>（3）擅用Message.<strong>what</strong>来<strong>标识信息</strong>，以便用不同方式处理Message。</p><p>（4）使用setData()存放<strong>Bundle</strong>对象。</p><h3 id="消息循环器：Looper"><a href="#消息循环器：Looper" class="headerlink" title="消息循环器：Looper"></a>消息循环器：Looper</h3><p>在使用Handler处理Message时，需要<strong>Looper</strong>来完成。在一个Activity中，系统会自动帮用户启动Looper对象，而在一个用户自定义的类中，则需要用户手动调用Looper类中的方法，然后才可以正常启动Looper对象。使用Looper类创建Looper线程很简单： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 将当前线程初始化为Looper线程</span><br>        Looper.prepare();<br>         <br>        <span class="hljs-comment">// ...其他处理，如实例化handler</span><br>         <br>        <span class="hljs-comment">// 开始循环处理消息队列</span><br>        Looper.loop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper中常用的方法：</p><p><strong>prepare(boolean quitAllowed)</strong></p><p>prepare()方法会创建一个Looper对象，将当前线程初始化为一个Looper线程。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<em>sThreadLocal</em>为<strong>ThreadLocal</strong>对象，什么是ThreadLocal？</p><blockquote><p> ThreadLocal，线程本地变量，是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 </p><p>ThreadLocal为每个线程创建了一个副本，用于访问副本变量。</p></blockquote><p>可以看到<strong>每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象</strong>，这样Thread跟Looper就形成了一一对应关系，也就是说，一个线程只能有一个Looper。</p><p><strong>loop()</strong></p><p>looper()则是开启消息循环，不断获取MessageQueue中的消息，并发送给相应的Handler对象。</p><p><img src="/img/2018123121424067.png" alt="loop()方法示意图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Looper me = myLooper(); <span class="hljs-comment">//从ThreadLocal中get到当前looper对象</span><br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<span class="hljs-comment">//获取与当前looper绑定的MessageQueue</span><br><br>    <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>    <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ident = Binder.clearCallingIdentity();<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Message msg = queue.next(); <span class="hljs-comment">// 当没有消息时会阻塞</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>        <span class="hljs-keyword">final</span> Printer logging = me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> traceTag = me.mTraceTag;<br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;<br>            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将处理工作交给Message的target，即handler</span><br>            msg.target.dispatchMessage(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>                Trace.traceEnd(traceTag);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>        &#125;<br><br>        <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>        <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> newIdent = Binder.clearCallingIdentity();<br>        <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>            Log.wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                    + Long.toHexString(ident) + <span class="hljs-string">&quot; to 0x&quot;</span><br>                    + Long.toHexString(newIdent) + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                    + msg.target.getClass().getName() + <span class="hljs-string">&quot; &quot;</span><br>                    + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>        &#125;<br><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>myLooper()</strong></p><p>myLooper()方法的作用是从当前线程的ThreadLocal中获取当前Looper对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Looper <span class="hljs-title">myLooper</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，Looper有以下几个要点：</p><p>1）<strong>每个线程有且只能有一个Looper对象</strong>，它是一个ThreadLocal</p><p>2）Looper内部有一个<strong>消息队列</strong>，loop()方法调用后线程开始不断从队列中取出消息执行</p><p>3）Looper使一个线程变成Looper线程。</p><h3 id="消息的发送者和处理者：Handler"><a href="#消息的发送者和处理者：Handler" class="headerlink" title="消息的发送者和处理者：Handler"></a>消息的发送者和处理者：Handler</h3><p>Message对象封装了所有的消息，而这些消息的操作需要android.os.Handler类完成。什么是Handler？Handler 起到了<strong>处理MessageQueue上的消息</strong>的作用（只处理由自己发出的消息），即通知MessageQueue它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。Handler创建时会关联一个Looper，默认的构造方法将关联当前线程的Looper，不过这也是可以set的。默认的构造方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">handler</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> MessageQueue mQueue;  <span class="hljs-comment">// 关联的MessageQueue</span><br>    <span class="hljs-keyword">final</span> Looper mLooper;  <span class="hljs-comment">// 关联的Looper</span><br>    <span class="hljs-keyword">final</span> Callback mCallback; <br>    <span class="hljs-comment">// 其他属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<br>            <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();<br>            <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) <br>                    &#123;<br>                Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> + klass.getCanonicalName());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 默认将关联当前线程的looper</span><br>        mLooper = Looper.myLooper();<br>        <span class="hljs-comment">// Looper不能为空，即该默认的构造方法只能在Looper线程中使用</span><br>        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//把关联looper的MessageQueue作为自己的MessageQueue，因此它的消息将发送到关联looper的MessageQueue上</span><br>        mQueue = mLooper.mQueue;<br>        mCallback = <span class="hljs-keyword">null</span>;<br>    &#125;<br>     <br>    ··· ···<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a><strong>Handler发送消息</strong></h4><p>发送消息的方法有很多，但归根结底都是调用了sendMessageAtTime()方法。</p><p>在子线程中通过Handler的post()方式或send()方式发送消息，最终都是调用了sendMessageAtTime()方法。 </p><p><strong>post方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">post</span><span class="hljs-params">(Runnable r)</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postAtTime</span><span class="hljs-params">(Runnable r, <span class="hljs-keyword">long</span> uptimeMillis)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);<br>    &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postAtTime</span><span class="hljs-params">(Runnable r, Object token, <span class="hljs-keyword">long</span> uptimeMillis)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);<br>    &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postDelayed</span><span class="hljs-params">(Runnable r, <span class="hljs-keyword">long</span> delayMillis)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>send方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(Message msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>    &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendEmptyMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> sendEmptyMessageDelayed(what, <span class="hljs-number">0</span>);<br>    &#125; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendEmptyMessageDelayed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;<br>        Message msg = Message.obtain();<br>        msg.what = what;<br>        <span class="hljs-keyword">return</span> sendMessageDelayed(msg, delayMillis);<br>    &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendEmptyMessageAtTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>        Message msg = Message.obtain();<br>        msg.what = what;<br>        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, uptimeMillis);<br>    &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageDelayed</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> delayMillis)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            delayMillis = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>就连子线程中调用Activity中的runOnUiThread()中更新UI，其实也是发送消息通知主线程更新UI，最终也会调用sendMessageAtTime()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runOnUiThread</span><span class="hljs-params">(Runnable action)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != mUiThread) &#123;<br>            mHandler.post(action);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            action.run();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sendMessage()  -&gt; sendMessageDelayed() -&gt; sendMessageAtTime() -&gt; <strong>enqueueMessage</strong>() </p><p>sendMessageAtTime()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>      <span class="hljs-comment">//其中mQueue是消息队列，从Looper中获取的</span><br>       MessageQueue queue = mQueue;<br>       <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;<br>           RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<br>                   <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>           Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//调用enqueueMessage方法</span><br>       <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到sendMessageAtTime()方法的作用很简单，就是调用MessageQueue的enqueueMessage()方法，往消息队列中添加一个消息。</p><p>enqueueMessage()方法的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>    msg.target = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    <span class="hljs-comment">// 调用MessageQueue的enqueueMessage方法将消息入队</span><br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面来看enqueueMessage()方法的具体执行逻辑。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-comment">// 每一个Message必须有一个target</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;  <span class="hljs-comment">//正在退出时，回收msg，加入到消息池</span><br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        msg.markInUse();<br>        msg.when = when;<br>        Message p = mMessages;<br>        <span class="hljs-keyword">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span><br>            <span class="hljs-comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p;<br>            prev.next = msg;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><h4 id="Handler分发和处理消息"><a href="#Handler分发和处理消息" class="headerlink" title="Handler分发和处理消息"></a><strong>Handler分发和处理消息</strong></h4><p>在loop()方法中，获取到下一条消息后，执行msg.target.dispatchMessage(msg)来分发消息到目标Handler对象。</p><p>下面就来看dispatchMessage()方法具体的执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//当Message存在回调方法，回调msg.callback.run()方法；</span><br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//当Handler存在Callback成员变量时，回调方法handleMessage()；</span><br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//Handler自身的回调方法handleMessage()</span><br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handleCallback()方法其实就是调用发送的Runnable中的run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        message.callback.run();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分发消息的流程</strong></p><p>当Message的msg.callback不为空时，则回调方法msg.callback.run()；</p><p>当Handler的mCallback不为空时，则回调方法mCallback.handleMessage(msg)；</p><p>最会调用Handler自身的的回调方法handleMessage()，该方法默认为空，由子类实现。</p><p><strong>消息分发的优先级</strong></p><p>Message的回调方法：message.callback.run()，优先级最高；<br>Handler中Callback的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；<br>Handler的默认方法：Handler.handleMessage(msg)，优先级最低。</p><p>对于很多情况下，消息分发后的处理方法是第3种情况，即<br>Handler.handleMessage(msg) ，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p><p>Handler有两个重要的特点：</p><p>(1)Handler可以在<strong>任意线程发送消息</strong>，这些消息会被添加到关联的MessageQueue上；</p><p>(2) <strong>消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的</strong>，handler是在它<strong>关联的looper线程中处理消息</strong>的。</p><p>这就解决了android最经典的不能在其他非主线程中更新UI的问题。<strong>android的主线程也是一个looper线程</strong>(looper在android中运用很广)，我们在其中创建的handler默认将关联主线程MQ。因此，利用<strong>handler的一个solution就是在activity中创建handler并将其引用传递给worker thread，worker thread执行完任务后使用handler发送消息通知activity更新UI。</strong></p><p><img src="/img/2018123122313535.png" alt="Handler机制工作示意图"></p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment进阶使用技巧</title>
    <link href="/2018/09/28/ad641d8b/"/>
    <url>/2018/09/28/ad641d8b/</url>
    
    <content type="html"><![CDATA[<h2 id="内存重启"><a href="#内存重启" class="headerlink" title="内存重启"></a>内存重启</h2><p>当App运行在后台，系统由于资源紧张把App杀死回收，此时App从后台切回前台会产生重启现象，我们把这种情况称为“内存重启”。另外，屏幕旋转等配置变化也会造成当前Activity重启，本质与“内存重启”类似。</p><p>在系统要把app回收之前，系统会把Activity的状态保存下来，Activity的FragmentManager负责把Activity中的Fragment保存起来。在“内存重启”后，Activity的恢复是从栈顶逐步恢复，Fragment会在宿主Activity的onCreate方法调用后紧接着恢复（从onAttach生命周期开始）。</p><h2 id="Fragment常用方法"><a href="#Fragment常用方法" class="headerlink" title="Fragment常用方法"></a>Fragment常用方法</h2><p>Fragment 的动态添加、删除等操作都需要借助于FragmentTransaction类来完成，下面是几种常用的方法：</p><ul><li>add() 系列：添加 Fragment 到 Activity 界面中；</li><li>remove()：移除 Activity 中的指定 Fragment；</li><li>replace() 系列：通过内部调用 remove() 和 add() 完成 Fragment 的修改；</li><li>hide() 和 show()：隐藏和显示 Activity 中的 Fragment；</li><li>addToBackStack()：添加当前事务到回退栈中，即当按下返回键时，界面回归到当前事物状态；</li><li>commit()：提交事务，所有通过上述方法对 Fragment 的改动都必须通过调用 commit() 方法完成提交</li></ul><h3 id="add、show、hide、replace的区别"><a href="#add、show、hide、replace的区别" class="headerlink" title="add、show、hide、replace的区别"></a>add、show、hide、replace的区别</h3><p>区别：</p><ul><li>show()，hide()最终是让Fragment的View setVisibility(true还是false)，不会调用生命周期；</li><li>replace()的话会销毁视图，即调用onDestoryView、onCreateView等一系列生命周期；</li><li>注意：add()和 replace()不要在同一个阶级的FragmentManager里混搭使用。</li></ul><p>使用场景：</p><ul><li>如果你有一个很高的概率会再次使用当前的Fragment，建议使用show()，hide()，可以提高性能。</li><li>大部分情况下用show()，hide()，而不是replace</li><li>注意：如果你的app有大量图片，这时更好的方式可能是replace，配合你的图片框架在Fragment视图销毁时，回收其图片所占的内存。</li></ul><h2 id="onHiddenChanged-回调时机"><a href="#onHiddenChanged-回调时机" class="headerlink" title="onHiddenChanged()回调时机"></a>onHiddenChanged()回调时机</h2><p>当使用add()+show()/hide()跳转新的Fragment时，旧的Fragment回调onHiddenChanged()，不会回调onStop()等生命周期方法，而<strong>新的Fragment在创建时是不会回调onHiddenChanged()的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hidden)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onHiddenChanged(hidden);<br>    <span class="hljs-keyword">if</span>(activity!=<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(hidden)&#123;<br>            <span class="hljs-comment">//当该页面隐藏时</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//当页面展现时</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为何不使用构造传值"><a href="#为何不使用构造传值" class="headerlink" title="为何不使用构造传值"></a>为何不使用构造传值</h2><p>当Activity重建时会调用Fragment的无参构造来重建Fragment，会导致数据丢失。</p><h2 id="Fragment栈视图"><a href="#Fragment栈视图" class="headerlink" title="Fragment栈视图"></a>Fragment栈视图</h2><p>每个Fragment以及宿主Activity(继承自FragmentActivity)都会在创建时，初始化一个FragmentManager对象，处理好Fragment嵌套问题的关键，就是理清这些不同阶级的栈视图。</p><h2 id="获取FragmentManager对象"><a href="#获取FragmentManager对象" class="headerlink" title="获取FragmentManager对象"></a>获取FragmentManager对象</h2><ul><li>对于宿主Activity，getSupportFragmentManager()获取的FragmentActivity的FragmentManager对象;</li><li>对于Fragment，getFragmentManager()是获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象，而getChildFragmentManager()是获取自己的FragmentManager对象。</li></ul><h2 id="Fragment之懒加载"><a href="#Fragment之懒加载" class="headerlink" title="Fragment之懒加载"></a>Fragment之懒加载</h2><p>懒加载，其实也就是延迟加载，就是等到该页面的UI展示给用户时，再加载该页面的数据（从网络、数据库等）。</p><p>Fragment中实现懒加载主要涉及setUserVisibleHint()方法，该方法会在onCreateView之前执行，当Fragment从可见到不可见或是从不可见到可见时，都会调用此方法。此外可以使用getUserVisibleHint()来判断Fragment是否可见。</p><h3 id="ViewPager与Fragment"><a href="#ViewPager与Fragment" class="headerlink" title="ViewPager与Fragment"></a>ViewPager与Fragment</h3><p>在使用viewpager（或其他容器）与多个Fragment来组合使用，ViewPager 会默认一次加载当前页面前后隔一个页面，即使设置setofflimit（0）也无效果，也会预加载。这样把我们看不到的页面的数据也加载了，大大降低了性能，浪费初始化资源。然而我们就采用懒加载技术，只让用户看到的页面才会加载他的数据，大大提高效率。</p><p>代码案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMVPLazyFragment</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IBasePresenter</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMVPFragment</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Fragment的View加载完毕的标记</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isViewInitiated;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Fragment对用户可见的标记</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isVisibleToUser;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 是否懒加载</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isDataInitiated;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第一步,改变isViewInitiated标记</span><br><span class="hljs-comment">    * 当onViewCreated()方法执行时,表明View已经加载完毕,此时改变isViewInitiated标记为true,并调用lazyLoad()方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState);<br>        isViewInitiated = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//只有Fragment onCreateView好了，</span><br>        <span class="hljs-comment">//另外这里调用一次lazyLoad(）</span><br>        prepareFetchData();<br>        <span class="hljs-comment">//lazyLoad();</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第二步</span><br><span class="hljs-comment">    * 此方法会在onCreateView(）之前执行</span><br><span class="hljs-comment">    * 当viewPager中fragment改变可见状态时也会调用</span><br><span class="hljs-comment">    * 当fragment 从可见到不见，或者从不可见切换到可见，都会调用此方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser);<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser;<br>        prepareFetchData();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第四步:定义抽象方法fetchData(),具体加载数据的工作,交给子类去完成</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第三步:在lazyLoad()方法中进行双重标记判断,通过后即可进行数据加载</span><br><span class="hljs-comment">    * 第一种方法</span><br><span class="hljs-comment">    * 调用懒加载，getUserVisibleHint()会返回是否可见状态</span><br><span class="hljs-comment">    * 这是fragment实现懒加载的关键,只有fragment 可见才会调用onLazyLoad() 加载数据</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (getUserVisibleHint() &amp;&amp; isViewInitiated &amp;&amp; !isDataInitiated) &#123;<br>            fetchData();<br>            isDataInitiated = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第二种方法</span><br><span class="hljs-comment">    * 调用懒加载</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareFetchData</span><span class="hljs-params">()</span> </span>&#123;<br>        prepareFetchData(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 第三步:在lazyLoad()方法中进行双重标记判断,通过后即可进行数据加载</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareFetchData</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceUpdate)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser &amp;&amp; isViewInitiated &amp;&amp; (!isDataInitiated || forceUpdate)) &#123;<br>            fetchData();<br>            isDataInitiated = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在BaseMVPLazyFragment中需要在onActivityCreated()及setUserVisibleHint()方法中都调了一次lazyLoad() 方法。如果仅仅在setUserVisibleHint()调用lazyLoad()，当默认首页首先加载时会导致viewPager的首页第一次展示时没有数据显示，切换一下才会有数据。因为首页fragment的setUserVisible()在onActivityCreated() 之前调用，此时isPrepared为false 导致首页fragment 没能调用onLazyLoad()方法加载数据。</p><h4 id="onLazyLoad-加载数据条件"><a href="#onLazyLoad-加载数据条件" class="headerlink" title="onLazyLoad()加载数据条件"></a>onLazyLoad()加载数据条件</h4><ul><li>getUserVisibleHint()会返回是否可见状态，这是fragment实现懒加载的关键,只有fragment 可见才会调用onLazyLoad() 加载数据。</li><li>isPrepared参数在系统调用onActivityCreated时设置为true,这时onCreateView方法已调用完毕(一般我们在这方法里执行findviewbyid等方法),确保 onLazyLoad()方法不会报空指针异常。</li><li>isLazyLoaded确保ViewPager来回切换时BaseFragment的initData方法不会被重复调用，onLazyLoad在该Fragment的整个生命周期只调用一次,第一次调用onLazyLoad()方法后马上执行 isLazyLoaded = true。</li><li>然后再继承这个BaseMVPLazyFragment实现onLazyLoad() 方法就行。他会自动控制当fragment 展现出来时，才会加载数据</li></ul><h4 id="使用FragmentPagerAdapter需要注意的"><a href="#使用FragmentPagerAdapter需要注意的" class="headerlink" title="使用FragmentPagerAdapter需要注意的"></a>使用FragmentPagerAdapter需要注意的</h4><p>在给ViewPager绑定FragmentPagerAdapter时，new FragmentPagerAdapter(fragmentManager)的FragmentManager，一定要保证正确。如果ViewPager是Activity内的控件，则传递getSupportFragmentManager()，如果是Fragment内的控件，则传递getChildFragmentManager()。只要记住ViewPager内的Fragments是当前组件的子Fragment这个原则即可。</p><h2 id="关于事务Transaction"><a href="#关于事务Transaction" class="headerlink" title="关于事务Transaction"></a>关于事务Transaction</h2><p>Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。</p><p>transaction只是记录了从一个状态到另一个状态的变化过程，即比如从FragmentA替换到FragmentB的过程，当通过函数transaction.addToBackStack(null)将这个事务添加到回退栈，则会记录这个事务的状态变化过程，如从FragmentA —&gt;FragmentB,当用户点击手机回退键时，因为transaction的状态变化过程被保存，则可以将事务的状态变化过程还原，即将FragmentB —&gt; FragmentA。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Create new fragment and transaction</span><br>Fragment newFragment = <span class="hljs-keyword">new</span> ExampleFragment();<br>FragmentTransaction transaction = getFragmentManager().beginTransaction();<br><br><span class="hljs-comment">// Replace whatever is in the fragment_container view with this fragment,</span><br><span class="hljs-comment">// and add the transaction to the back stack</span><br>transaction.replace(R.id.fragment_container, newFragment);<br>transaction.addToBackStack(<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">// Commit the transaction</span><br>transaction.commit();<br></code></pre></td></tr></table></figure><h2 id="关于commit-与commitAllowingStateLoss"><a href="#关于commit-与commitAllowingStateLoss" class="headerlink" title="关于commit()与commitAllowingStateLoss()"></a>关于commit()与commitAllowingStateLoss()</h2><p>若在Activity的onSaveInstanceState()方法之后调用commit()方法提交事务会出错，并提示“Can not perform this action after onSaveInstanceState”。因为onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存完状态后再给它添加Fragment就会出错。如果无法确定onSaveInstanceState()的调用时机，使用commitAllowingStateLoss()方法。</p><p>看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> commitInternal(<span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">commitAllowingStateLoss</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> commitInternal(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从源代码来看，它们调用了同一个方法只是传递的参数不同，那么就是这个参数导致的不同了，继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">commitInternal</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> allowStateLoss)</span> </span>&#123;<br>        .......<br>        mManager.enqueueAction(<span class="hljs-keyword">this</span>, allowStateLoss);<br>        <span class="hljs-keyword">return</span> mIndex;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueAction</span><span class="hljs-params">(OpGenerator action, <span class="hljs-keyword">boolean</span>          allowStateLoss)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!allowStateLoss) &#123;<br>            checkStateLoss();<br>        &#125;<br>        ........<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkStateLoss</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (mStateSaved) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>             <span class="hljs-string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">if</span> (mNoTransactionsBecause != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>              <span class="hljs-string">&quot;Can not perform this action inside of &quot;</span> + mNoTransactionsBecause);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到allowStateLoss的值主要是影响了checkStateLoss()的调用，当allowStateLoss为true时就会在onSaveInstanceState()被调用后抛出异常。</p>]]></content>
    
    
    <categories>
      
      <category>Android Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fragment</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
