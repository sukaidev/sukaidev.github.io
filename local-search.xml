<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解JVM（一）——自动内存管理</title>
    <link href="/2021/03/14/132bcd6f/"/>
    <url>/2021/03/14/132bcd6f/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><p>对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”， 又是从事最基础工作的劳动人民——既拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。</p><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对 的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问 题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如下所示。</p><p><img src="/img/jvm/jvm_run_time_data_areas.png" alt="JVM Run-time data areas"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个技术记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则应为空（Undefined）。此内存区是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，<strong>Java虚拟机栈（Java Virtual Machine Stack）</strong>也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧（Stack Frame）</strong>用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（<strong>boolean</strong>、<strong>byte</strong>、<strong>char</strong>、<strong>short</strong>、<strong>int</strong>、 <strong>float</strong>、<strong>long</strong>、<strong>double</strong>）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈（Native Method Stacks）</strong>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于Java应用程序来说，<strong>Java堆（Java Heap）</strong>是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域存在的唯一目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的内存区域，因此有些资料也称其为<strong>”GC堆“（Garbage Collected Heap）</strong>。</p><p>从回收内存的角度看，现代垃圾收集器通常在<strong>逻辑上</strong>将Java堆分为<strong>”新生代“</strong>、<strong>”老年代“</strong>、<strong>”永久代“</strong>、”<strong>Eden空间“</strong>、<strong>”From Survivor空间“</strong>等区域，但这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，也与《Java虚拟机规范》无关。</p><p>从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB）</strong>，以提升对象分配时的效率。不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。如果堆中内有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在《Java虚拟机规范》中把方法区描述为<strong>堆的一个逻辑部分</strong>，为了与Java堆区分，通常把它叫做<strong>”非堆（Non-Heap）“</strong>。</p><p>方法区的内存使用超过限制会抛出OutOfMemory异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是<strong>常量池表（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说<strong>，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</strong></p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK 1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMe-moryError异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>接下来我们以最常见的虚拟机HotSpot和内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p><p>先看一张图：</p><p><img src="/img/jvm/jvm_java_object_creation.png" alt="Java Object Creation"></p><p>我们来分析一下这个流程。</p><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。Java堆中有两种内存分配方式，分别是<strong>”指针碰撞“</strong>和<strong>”空闲列表“</strong>。</p><ul><li><strong>指针碰撞（Bump The Pointer）：</strong>已分配内存和空闲内存之间放置一个作为分界点的指示器，通过移动这个指示器来调整空闲空间的大小实现对象的内存分配。这种分配方式适合内存绝<strong>对规整</strong>的情况。</li><li><strong>空闲列表（Free List）：</strong>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有<strong>空间压缩整理（Compact）</strong>的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p><p>除了划分可用内存空间之外，对象的创建实际上还会有线程安全的问题：可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。要解决这个问题有两种可选方案：</p><ol><li>对分配内存空间的动作进行同步处理。实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间之中进行。这种情况需要每个线程预先在堆上分配一小块内存，称为本地线程分配缓冲<strong>（Thread Local Allocation Buffer，TLAB）</strong>，哪个线程要分配内存，就先到它的TLAB中分配，只有TLAB满了，分配新的缓存区时才需要同步锁定。</li></ol><p>分配完内存之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</p><p>接下来JVM需要对对象进行必要的设置，例如接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的<strong>对象头(Object Header)之中</strong>。</p><p>完成上面的工作之后，在虚拟机看来实际上一个新的对象已经产生了。不过从程序角度来看，还需要调用构造函数来初始化对象的资源和状态。因此new指令之后接着会执行Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。如下图所示。</p><p><img src="/img/jvm/HotSpot_object_storage_distribution.png" alt="HotSpot虚拟机对象存储分布"></p><p>其中MarkWord是一个有着动态定义的数据结构，在未开启指针压缩的情况，在32位和64位虚拟机上的长度分别为32个比特和64个比特。</p><p>例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><table><thead><tr><th align="center">存储内容</th><th align="center">标志位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象哈希码、分代年龄</td><td align="center">01</td><td align="center">未锁定</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">00</td><td align="center">轻量级锁定</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">10</td><td align="center">膨胀（重量级锁定）</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">01</td><td align="center">可偏向</td></tr></tbody></table><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li>使用句柄访问时，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自具体的地址信息，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_handles.png" alt="通过句柄访问对象"></p><ul><li>使用直接指针访问时，Java堆中对象的内存布局就必须考虑如何放置访问数据类型的相关信息，reference中存储的直接就是对象地址。如果只是访问对象本身的话，就不需要额外的间接访问开销了，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_pointer.png" alt="通过直接指针访问对象"></p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p><strong>垃圾收集简称GC（Garbage Collection）</strong>，它主要需要完成三件事：</p><ul><li>那些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>上面介绍了Java内存运行时区域的各个部分，我们知道线程私有的区域可以随着线程的销毁而进行内存的清理工作，而Java堆和方法区是线程共享的部分，这部分内存的分配和回收是动态的，所以是垃圾收集器重点关注的区域，本文讨论的也是这两个区域。</p><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>在Java堆中存放这Java世界中几乎所有的对象实例，垃圾收集器在堆堆进行GC钱，第一件事就是要确认哪些对象的实例”活着“，哪些对象已经”死亡“需要被回收。</p><p>目前主流的判断对象存活的算法有两种：</p><ul><li><strong>引用计数法</strong></li><li><strong>可达性分析法</strong></li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数：<strong>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</strong></p><p>此算法简单且高效，只需要占用一些额外的内存空间来进行计数，但主流的JVM都没有选用这个算法来管理内存，主要原因是：这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><p>这也是常说的”循环引用“问题，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// &lt;-- 背景 --&gt;</span><br><span class="hljs-comment">// 对象objA 和 objB 都有字段 name</span><br><span class="hljs-comment">// 两个对象相互进行引用，除此之外这两个人对象没有任何引用</span><br>objA.name = objB；<br>objB.name = objA；<br><br><span class="hljs-comment">// &lt;-- 问题 --&gt;</span><br><span class="hljs-comment">// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收</span><br><span class="hljs-comment">// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象</span><br></code></pre></div></td></tr></table></figure><p>当出现循环引用时，两个对象已经”死亡“，但实际上由于引用计数器不为0而无法被回收引起泄露。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。</p><p>可达性分析（Reachability Analysis）：<strong>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</strong></p><p><img src="/img/jvm/reachablity_analysis_process.png" alt="可达性分析法"></p><p>如上图所示，与GC Root不存在引用链的对象将会被判为“死亡”对象，在下一次GC时进行回收。</p><p>Java中固定可作为GC Root的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象，即栈帧中的本地变量表，里面存放了各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，例如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</li></ul><p>除了上述固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如发生局部回收（Partial GC）时，如果只针对Java堆中某一块区域发起垃圾收集，这个区域里的对象完全有可能被区域外部的其他对象引用，例如下图中的B对象。此时A对象会被一并加入到GC Roots集合中，充当临时的GC Root，才能保证可达性分析的准确性。</p><p><img src="/img/jvm/partial_gc_reachability.png" alt="局部GC"></p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>一个对象要真正被垃圾回收器回收，除了要在可达性分析判断为不可达对象外，还要经历至少两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行**finalize()**方法。如果对象没有复写finalize方法或者finalize方法已经被调用过一次了，那么这两种情况都被视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<strong>F-Queue</strong>的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，<strong>但并不承诺一定会等待它运行结束</strong>。 不承诺它一定结束的原因是，finalize()方法可能会很耗时或者存在死循环导致其他对象无法正常执行finalize()。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。本文主要探讨追踪式垃圾收集。</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（五）——官方框架</title>
    <link href="/2021/02/28/c18f109d/"/>
    <url>/2021/02/28/c18f109d/</url>
    
    <content type="html"><![CDATA[<h2 id="协程框架概述"><a href="#协程框架概述" class="headerlink" title="协程框架概述"></a>协程框架概述</h2><p>Kotlin协程的官方框架kotlin.coroutines是一套独立于标准库之外的以生产为目的的框架，框架本身提供了丰富的API来支撑生产环境中异步程序的设计和实现。主要包含以下几个部分：</p><ul><li>core：框架的核心逻辑，包含前两篇文章实现的内容和Channel、Flow等特性。</li><li>ui：包含android、javafx、swing三个库，用于提供各平台的UI调度器和一些特有的逻辑。</li><li>reactive：提供对各种响应式编程框架的协程支持。<ul><li>reactive：提供对<a href="http://www.reactive-streams.org/">Reactive Streams</a>的协程支持。</li><li>reactor：提供对<a href="https://projectreactor.io/">Reactor</a>的协程支持。</li><li>rx2：提供对<a href="https://github.com/ReactiveX/RxJava">RxJava 2.x</a>版本的协程支持。</li></ul></li><li>integration：提供与其他框架的异步回调的集成。<ul><li>jdk8：提供对CompletableFuture的协程API的支持。</li><li>guava：提供对ListenableFuture的协程API的支持。</li><li>slf4j：提供MDCContext作为协程上下文的元素。</li><li>play-services：提供对Google Play服务中的Task的协程API的支持。</li></ul></li></ul><p><img src="/img/kotlinx_coroutines_framework.png" alt="官方协程框架的结构"></p><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>kotlin官方协程框架中协程的启动多了一个start参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动模式总共有4种。</p><ul><li>DEFAULT ：协程创建后，立即开始调度，在调度前如果被取消则进入取消相应的状态。</li><li>ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点前不响应取消。</li><li>LAZY：只有协程主调调用start、join或者await等函数时才会开始调度，如果调度前被取消将进入异常结束状态。</li><li>UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个挂起点。</li></ul><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>官方框架中预置了4个调度器，我们可以通过Dispatchers对象访问它们。</p><ul><li>Default：默认调度器，适合处理后台计算，是一个CPU密集型任务调度器。</li><li>IO：IO调度器，适合执行IO相关操作，是一个IO密集型任务调度器。</li><li>Main：UI调度器，根据平台不同会被初始化为对应的UI线程的调度器，例如ANdroid平台的主线程（UI线程）。</li><li>Unconfined：未定调度器，不要求协程执行在特定的线程上。如果协程的调度器是Unconfined，那么它在挂起点恢复执行时后续代码会在恢复所在的线程上直接执行。</li></ul><p>如果内置的调度器无法满足需求，也可以自定义调度器，只需要实现CoroutineDispatcher接口即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDispatcher</span> : <span class="hljs-type">CoroutineDispatcher</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>      ... ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>更多的时候我们将自己定义好的线程池转成调度器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Executors.newSingleThreadExecutor()<br>    .asCoroutineDispatcher()<br>    .use &#123; dispatcher -&gt;<br>        <span class="hljs-keyword">val</span> result = withContext(dispatcher) &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-string">&quot;Hello World.&quot;</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里用到了<strong>asCoroutineDispatcher</strong>和<strong>withContext</strong>两个扩展函数。asCoroutineDispatcher实际上也就是把线程池转为CoroutineDispatcher接口的实现，withContext函数会将参数中的Lambda表达式调度到对应的调度器上，返回值为Lambda表达式的值，它的作用等价于async{ … }.await()，且内存开销更低，因此对于async之后立即await的情况都可以用withContext来提高性能。</p><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>官方框架中支持全局的异常处理器，在根协程（顶级协程）未设置异常处理器时，未捕获异常会优先传递给全局异常处理器处理，之后再交给线程的UncaughtExceptionHandler。</p><p>定义一个全局异常处理器与普通的异常处理器没有区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineExceptionHandler &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Global Coroutine exception:<span class="hljs-variable">$exception</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 关键在于我们需要在classpath目录下创建META-INF/services目录，在其中创建一个名为kotlinx.coroutines.CoroutineExceptionHandler的文件，文件的内容是全局异常处理器的全类名。</p><h3 id="取消检查"><a href="#取消检查" class="headerlink" title="取消检查"></a>取消检查</h3><p>协程中挂起函数可以通过suspendCancellableCoroutine来响应所在协程的取消转台，那么没有挂起点的话如何取消呢？例如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyTo</span><span class="hljs-params">(<span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>, bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    <span class="hljs-keyword">var</span> bytesCopied: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">val</span> buffer = ByteArray(bufferSize)<br>    <span class="hljs-keyword">var</span> bytes = read(buffer)<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, bytes)<br>        bytesCopied += bytes<br>        bytes = read(buffer)<br>    &#125;<br>    <span class="hljs-keyword">return</span> bytesCopied<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以效仿线程的取消，在while循环内设置一个状态监听，这里我们可以监听父协程的存活状态来判断是否取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@OptIn(InternalCoroutinesApi::class)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyToSuspend</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">val</span> job = coroutineContext[Job]<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        job?.let &#123; it.takeIf &#123; it.isActive &#125; ?: <span class="hljs-keyword">throw</span>  job.getCancellationException() &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际上这里还有更简便的方法，那就是<strong>yield</strong>函数。yield函数内部会调用CoroutineContext#checkCompletion函数来检查协程是否存活：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()  <span class="hljs-comment">// 检查协程是否存活</span><br>    <span class="hljs-keyword">val</span> cont = uCont.intercepted() <span class="hljs-keyword">as</span>? DispatchedContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">if</span> (!cont.dispatcher.isDispatchNeeded(context)) &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-keyword">if</span> (cont.yieldUndispatched()) COROUTINE_SUSPENDED <span class="hljs-keyword">else</span> <span class="hljs-built_in">Unit</span><br>    &#125;<br>    cont.dispatchYield(<span class="hljs-built_in">Unit</span>)<br>    COROUTINE_SUSPENDED<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineContext.<span class="hljs-title">checkCompletion</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">get</span>(Job)<br>    <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) <span class="hljs-keyword">throw</span> job.getCancellationException()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这点与线程的yield函数不同，线程的yield函数仅让出线程的执行权，并不会进行中断状态检查。</p><h3 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h3><p>官方提供了两个api用于超时取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> user = withTimeout(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时抛出取消异常</span><br>        getUserSuspend()<br>    &#125;<br>    <span class="hljs-keyword">val</span> userOrNull = withTimeoutOrNull(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时返回null</span><br>        getUserSuspend()<br>    &#125;<br>    println(user)<br>    println(userOrNull)<br>&#125;.join()<br></code></pre></div></td></tr></table></figure><h3 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h3><p>官方框架提供一个名为NonCancellable的上下文实现用于禁止作用范围内的协程被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">yield()<br>withContext(NonCancellable) &#123; <span class="hljs-comment">// 禁止被取消</span><br>    delay(<span class="hljs-number">10000L</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="热数据通道Channel"><a href="#热数据通道Channel" class="headerlink" title="热数据通道Channel"></a>热数据通道Channel</h2><p>Channel用于连接协程实现协程间的通信，它实际上就是一个并发安全的队列，用法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><br><span class="hljs-keyword">val</span> producer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        channel.send(i++)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = channel.receive()<br>        println(element)<br>    &#125;<br>&#125;<br>producer.join()<br>consumer.join()<br></code></pre></div></td></tr></table></figure><p>这里使用channel实现了一个简单的生产消费者模式，producer中每隔1s向Channel发送一个数字，而consumer一直在读取Channel来读取这个数字并打印。channel.receive必然是挂起的，那么channel.send一定是个挂起函数吗？</p><h3 id="Channel的容量"><a href="#Channel的容量" class="headerlink" title="Channel的容量"></a>Channel的容量</h3><p>前面说了channel本质是个队列，那么队列是有空间的，一但空间不足就可能会出现两种情况，阻塞或者直接抛异常。send在发送消息时，队列的缓冲区也可能会满，满了之后send就需要挂起协程等待外部调用receive取走元素了。来看下Channel缓冲区的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> <span class="hljs-title">Channel</span><span class="hljs-params">(capacity: <span class="hljs-type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =<br>    <span class="hljs-keyword">when</span> (capacity) &#123;<br>        RENDEZVOUS -&gt; RendezvousChannel()<br>        UNLIMITED -&gt; LinkedListChannel()<br>        CONFLATED -&gt; ConflatedChannel()<br>        BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY)<br>        <span class="hljs-keyword">else</span> -&gt; ArrayChannel(capacity)<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>根据传入的容量值不同，这里创建了四种不同的Channel：</p><ul><li><strong>RendezvousChannel</strong>：缓冲区大小为0或者说没有缓冲区的Channel。这意味着send调用后会马上挂起直到receive被调用，receive调用后也会马上挂起协程直到另一个协程调用send。</li><li><strong>LinkedListChannel</strong>：缓冲区是一个的LinkedList，它的send永远不会挂起协程，同时offer总是返回true，这意味着它“来者不拒”，这点跟LinkedBlockingQueue有点类似。</li><li><strong>ConflatedChannel</strong>：缓冲区仅保留最近send过来的一个元素。send函数不会挂起协程，但仅保留最近的send的一个元素，这意味这如果receive调用时机晚了会丢失早先send的数据。</li><li><strong>ArrayChannel</strong>：接收一个值作为缓冲区大小，效果类似于ArrayBlockingQueue，缓冲区满了Sender挂起，缓冲区空了Receiver挂起。</li></ul><h3 id="迭代Channel"><a href="#迭代Channel" class="headerlink" title="迭代Channel"></a>迭代Channel</h3><p>Channel重写的Iterator操作符，因此可以进行迭代。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> iterator = channel.iterator()<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">val</span> element = iterator.next()<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> channel) &#123;<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="produce和actor"><a href="#produce和actor" class="headerlink" title="produce和actor"></a>produce和actor</h3><p>可以使用produce或者actor快速构建一个生产者或者消费者协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer: ReceiveChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.produce &#123;<br>    repeat(<span class="hljs-number">100</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        send(it)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer: SendChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.actor &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = receive()<br>        println(element)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ReceiveChannel和SendChannel是Channel的父接口，分别定义了receive和send方法。produce构造除了ProducerCoroutine对象，该类是Job的实现类之一，主要工作是在协程结束或被取消时关闭Channel，send同理。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerCoroutine</span>&lt;<span class="hljs-type">E</span>&gt;</span>(<br>    parentContext: CoroutineContext, channel: Channel&lt;E&gt;<br>) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="hljs-literal">true</span>), ProducerScope&lt;E&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">super</span>.isActive<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">(value: <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        _channel.close()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>, handled: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> processed = _channel.close(cause)<br>        <span class="hljs-keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Channel的关闭"><a href="#Channel的关闭" class="headerlink" title="Channel的关闭"></a>Channel的关闭</h3><p>Channel存在关闭的概念，所以被称为<strong>热数据流</strong>。当我们调用Channel的close方法时，它会立即停止接收元素，这个时候它的<strong>isClosedForSend</strong>会立即返回true，该属性表示发送端已经关闭。当Channel缓冲区的所有元素都被读取后，<strong>isClosedForReceive</strong>会返回true，表示接收端也已经关闭。</p><p>跟I/O流一样，我们需要在合适的时候关闭Channel，如果不关闭则会导致接收端一直处于挂起等待状态。对于单向通信的Channel，由发送端处理关闭较为合适；对于双向通信的Channel则协商关闭。</p><h3 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h3><p>前面的Channel发送端和接收端可能存在一对多的情况，不过同一元素只会被一个接收端接收到。不过<strong>BroadcastChannel</strong>中多个接收者不存在互斥行为。可以通过BroadcastChannel方法来构建一个BroadcastChannel对象，再通过这个对象来获取ReceiveChannel。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建BroadcastChannel</span><br><span class="hljs-keyword">val</span> broadcastChannel = BroadcastChannel&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// 获取一个ReceiveChannel</span><br><span class="hljs-keyword">val</span> receiveChannel = broadcastChannel.openSubscription()<br></code></pre></div></td></tr></table></figure><p>或者可以使用普通的channel转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><span class="hljs-keyword">val</span> broadcastChannel = channel.broadcast(<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p>Channel.broadcast方法实际就是读取原Channel的元素然后再通过广播发送。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> ReceiveChannel<span class="hljs-type">&lt;E&gt;</span>.<span class="hljs-title">broadcast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    capacity: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.LAZY</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: BroadcastChannel&lt;E&gt; =<br>    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;<br>        <span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span><span class="hljs-symbol">@broadcast</span>) &#123; <span class="hljs-comment">// 读取原Channel</span><br>            send(e)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>有一点需要注意的是，由于这里读取了原Channel，所以如果有其他协程也在读取这个Channel，可能会存在互斥的情况。</p><h3 id="Channel的内部结构"><a href="#Channel的内部结构" class="headerlink" title="Channel的内部结构"></a>Channel的内部结构</h3><p>支持Channel胜任并发场景的是其内部数据结构。本节来探讨缓冲区是<strong>链表</strong>和<strong>数组</strong>的版本。链表版本的定义主要是在<strong>AbstractSendChannel</strong>中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSendChannel</span>&lt;<span class="hljs-type">E</span>&gt; : <span class="hljs-type">SendChannel</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> queue = LockFreeLinkedListHead()<br>    ··· ···<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>LockFreeLinkedListHead</strong>本身是一个双向链表的节点，Channel把它收尾相连形成循环链表，这个queue作为哨兵节点，当有新的节点插入时就插入到queue的前面，相当于在整个链表的最后插入元素。该链表节点的关键结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockFreeLinkedListNode</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _next = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed | OpDescriptor</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed</span><br></code></pre></div></td></tr></table></figure><p><strong>_next</strong> 和 <strong>_prev</strong>表示节点的向前引用和向后引用，其使用atomic包裹仅能进行原子操作。不过CAS操作通常只能修改一个引用，对于需要同时修改前后节点引用的情形是不适用的。当我们在单链表中插入节点时，也会存在并发问题，如下图所示。</p><p><img src="/img/singly_linked_list_concurrently_insert.png" alt="单链表并发插入问题"></p><p>而无锁链表LockFreeLinked的实现是引入一个prev来辅助完成。A被移除时不会像单链表一样直接断开指针， 而是现将A.next和A.prev标记为Removed，指向的节点不变，因此即便同时有另一个线程插入一个节点X，链表同样有机会在后续通过CAS算法实现前后节点引用的修复。具体实现参照LockFreeLinkedListNode在JVM上的实现。</p><p>而对于数组版本，ArrayChannel相对就比较简单了，其内部维护了一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = ReentrantLock()<br><span class="hljs-comment">// 缓冲区大于8时会先分配大小为8的数组，之后再进行扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="hljs-number">8</span>))<br></code></pre></div></td></tr></table></figure><p>对这个数组的读写操作都会使用可重入锁ReentrantLock进行加锁。</p><h2 id="冷数据流Flow"><a href="#冷数据流Flow" class="headerlink" title="冷数据流Flow"></a>冷数据流Flow</h2><p>我们现在大多数App都使用了RxJava作为异步框架，而RxJava的核心就是响应式编程模型。Flow就是Kotlin协程与响应式编程模型结合的产物。</p><h3 id="认识Flow"><a href="#认识Flow" class="headerlink" title="认识Flow"></a>认识Flow</h3><p>先来使用flow创建发送序列，这里对比一下官方的序列生成器<strong>sequence</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intsSeq = sequence &#123;  <span class="hljs-comment">// 不支持设置协程上下文</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        yield(it)<br>        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 编译报红</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>        delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 可调用外部挂起函数</span><br>    &#125;<br>&#125;<br>intFlow.flowOn(Dispatchers.IO)  <span class="hljs-comment">// 指定在IO线程生成</span><br></code></pre></div></td></tr></table></figure><p>我们知道，sequence不支持传入协程上下文，因而无法对协程进行线程调度。而受<strong>SequenceScope</strong>的<strong>RestrictsSuspension</strong>注解的影响，其内部也无法调用外部的的挂起函数。这其中其实是有个因果关系的，假设sequence支持调用delay，由于sequence本身不支持调度，所以会导致delay执行后会有切换线程的副作用。而Flow则没有这么多限制了，我们可以内部使用emit发送元素，可调用外部的挂起函数，同时也可以使用flowOn函数进行线程调度。</p><h3 id="Flow的线程切换"><a href="#Flow的线程切换" class="headerlink" title="Flow的线程切换"></a>Flow的线程切换</h3><p>Flow的线程切换使用<strong>Flow.flowOn</strong>方法，这个方法与RxJava的subscribeOn和observeOn切换协程的方式十分类似，下面是对比代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123; e -&gt;<br>        it.onNext(e)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>    it.onComplete()<br>&#125;<br>    .subscribeOn(Schedulers.io())  <span class="hljs-comment">// 第一次有效</span><br>    .subscribeOn(Schedulers.computation())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe &#123;<br>        println(it)  <span class="hljs-comment">// Android主线程</span><br>    &#125;<br><br>flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO) <span class="hljs-comment">// 第一次有效</span><br>    .flowOn(Dispatchers.Default)<br>    .collect &#123; <br>        println(it)  <span class="hljs-comment">// 与所在协程调度器一致</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到flowOn方法与RxJava的subscribeOn方法十分类似，都是会只会影响其之前的代码，而且都是只有第一次调用是有效的，这个其实跟collect或者subscribe的逆序调用执行有关，代码顺序中第一次调用flowOn或者subscribeOn其实是最后才执行，所以它们是有效的，这里不深究了。另外区别是RxJava中可以使用observeOn方法来调度subscribe回调的执行线程，看起来似乎Flow的collect没有类似的调度方法，其实不然，Flow的collect是个挂起函数，其调度线程跟外部的协程调度在哪个线程是一致的。</p><h3 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h3><p>与RxJava类似，Flow的生产总是在消费被调用后才会执行，并且多次调用会多次生产。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO)<br>    .flowOn(Dispatchers.Default)<br><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br></code></pre></div></td></tr></table></figure><p>所谓的冷数据流，就是只有消费时才会生产的数据流，这一点与Channel刚好相反。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Flow异常处理比较简单直接，直接调用catch函数即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    emit(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">&quot;Div 0&quot;</span>)  <span class="hljs-comment">// 抛出一个异常</span><br>&#125;.<span class="hljs-keyword">catch</span> &#123; t: Throwable -&gt;<br>    println(<span class="hljs-string">&quot;caught error : <span class="hljs-variable">$t</span>&quot;</span>)<br>&#125;.onCompletion &#123; <span class="hljs-comment">// Flow完成后回调</span><br>    println(<span class="hljs-string">&quot;onCompletion.&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用catch函数捕获flow中抛出的异常，这里需要注意的是catch<strong>只能捕获上游的异常</strong>，如果没有catch，则会在消费时抛出。</p><p><strong>onCompletion</strong>方法的作用类似于RxJava中Subscriber的OnComplete，作为整个Flow完成的回调使用，无论是否存在未捕获的异常都会被调用。</p><h3 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h3><p>前面我们使用了collect来消费Flow的数据，像这种包含消费含义的操作符称为<strong>末端操作符</strong>。Flow的末端操作符大体可以分为两类：</p><ul><li>集合类型转换操作符，包括toList、toSet等。</li><li>聚合操作符，包括将Flow规约到单值的reduce、fold等操作；还有获得单个元素的操作符，包括single、singleOrNull、first等。</li></ul><h3 id="分离Flow的消费和触发"><a href="#分离Flow的消费和触发" class="headerlink" title="分离Flow的消费和触发"></a>分离Flow的消费和触发</h3><p>我们除了可以在collect处消费Flow的元素之外，还可以通过onEach来消费元素，而collect只需要作为触发点就可以。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .onEach &#123; println(it) &#125;  <span class="hljs-comment">// onEach中消费</span><br><br>intFlow.collect()  <span class="hljs-comment">// collect触发生产和消费</span><br></code></pre></div></td></tr></table></figure><p>另外Flow中还提供了一个launchIn方法指定一个协程作用域，使其消费在指定的协程中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123; intFlow.collect() &#125;<br>intFlow.launchIn(GlobalScope) <span class="hljs-comment">// 两种方法是一样的</span><br></code></pre></div></td></tr></table></figure><h3 id="Flow的取消"><a href="#Flow的取消" class="headerlink" title="Flow的取消"></a>Flow的取消</h3><p>Flow不存在取消的概念，因为其依托于外部协程的生命周期，所以要想取消一个Flow只需要取消其外部协程即可。</p><h3 id="其他Flow的创建方式"><a href="#其他Flow的创建方式" class="headerlink" title="其他Flow的创建方式"></a>其他Flow的创建方式</h3><p>之前我们使用了flow{…}来创建一个Flow，这种方式的缺点是当中无法随意切换调度器，如果在当中使用调度器会报错，因为emit函数不是线程安全的。如果需要在生成元素时切换调度器可以使用ChannelFlow，通过channelFlow{…}来创建。</p><h3 id="Flow的背压"><a href="#Flow的背压" class="headerlink" title="Flow的背压"></a>Flow的背压</h3><p>只要是响应式编程就会有背压问题，即生产者生产元素的速率远高于消费者的处理速率时，消费者还未处理上一个数据新数据就已经到达的情况。</p><p>为了保证数据不丢失，我们可以为Flow添加缓冲区。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;.buffer() <span class="hljs-comment">// 可以指定容量</span><br></code></pre></div></td></tr></table></figure><p>不过如果只是单纯添加缓冲，缓冲区迟早也会出现数据积压，只是治标不治本。</p><p>要从根本上解决背压问题，除了直接优化消费者的性能外，还可以采用一些取舍手段。</p><p>第一种是<strong>conflate</strong>。与Channel中的Conflate模式一直，新数据会覆盖老数据，使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .conflate()<br>    .collect &#123;<br>        println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$it</span>&quot;</span>)<br>        delay(<span class="hljs-number">100</span>)<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> collected&quot;</span>)<br>    &#125;<br><br><span class="hljs-comment">// 输出</span><br>Collecting <span class="hljs-number">0</span><br><span class="hljs-number">0</span> collected<br>Collecting <span class="hljs-number">99</span><br><span class="hljs-number">99</span> collected<br></code></pre></div></td></tr></table></figure><p>上述代码快速发送了100个元素，最后接收到的只有2个。</p><p>第二种是<strong>collectLasted</strong>，作用是只处理最新的数据。看起来似乎与conflate是一样的，其实不然，collectLasted不会进行数据的覆盖，而是在当前数据还未处理完而新的数据来的时候，当前数据的处理逻辑会被取消，转而处理新数据。</p><p>除了collectLasted之外，还有<strong>mapLastest</strong>、<strong>flatMapLatest</strong>等。</p><h3 id="Flow的变换"><a href="#Flow的变换" class="headerlink" title="Flow的变换"></a>Flow的变换</h3><p>Flow与RxJava的Observable一样，可以使用map、flattenConcat等函数来进行变换。</p><h2 id="select表达式"><a href="#select表达式" class="headerlink" title="select表达式"></a>select表达式</h2><p>select在Java NIO里很常见，Kotlin协程中的select用于同时等待多个挂起函数，并可以选择第一个恢复的gaug挂起。</p><h3 id="复用多个await"><a href="#复用多个await" class="headerlink" title="复用多个await"></a>复用多个await</h3><p>假设我们有个常见是分别从本地和网络获取数据，哪个先返回就用哪个，那么如何做到这一点呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromApi</span><span class="hljs-params">(login: <span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    gitHubServiceApi.getUserSuspend(login)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromLocal</span><span class="hljs-params">(login:<span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="hljs-keyword">class</span>.java) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以使用select来同时启动这两个挂起函数，并最终返回先恢复的那个挂起函数返回的数据，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> localDeferred = getUserFromLocal(login)<br>    <span class="hljs-keyword">val</span> remoteDeferred = getUserFromApi(login)<br><br>    <span class="hljs-keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;<br>        localDeferred.onAwait &#123; Response(it, <span class="hljs-literal">true</span>) &#125;<br>        remoteDeferred.onAwait &#123; Response(it, <span class="hljs-literal">false</span>) &#125;<br>    &#125;<br>    ...<br>&#125;.join()<br></code></pre></div></td></tr></table></figure><p>我们没有直接调用await，而是使用<strong>Deferred#onAwait</strong>方法在select中注册了回调，select总是会立即调用最先返回的事件的回调。</p><h3 id="复用多个Channel"><a href="#复用多个Channel" class="headerlink" title="复用多个Channel"></a>复用多个Channel</h3><p>对于多个Channel的情况，也比较类似：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">val channels = List(<span class="hljs-number">10</span>) &#123; Channel<span class="hljs-params">&lt;Int&gt;</span>() &#125;<br><br>select<span class="hljs-params">&lt;Int?&gt;</span> &#123;<br>    channels.<span class="hljs-class">forEach </span>&#123; channel -&gt;<br>        channel.<span class="hljs-class">onReceive </span>&#123; it &#125;<br>        <span class="hljs-comment">// OR</span><br>        channel.<span class="hljs-class">onReceiveOrNull </span>&#123; it &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于 onReceive，如果Channel被关闭，select会直接抛出异常；而对于 onReceiveOrNull如果遇到Channel被关闭的情况，it的值就是null。</p><h3 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h3><p>如何知道哪些事件可以被select呢？实际上所有能够被select的事件都是SelectClauseN类型，包括：</p><ul><li><p>SelectClause0：对应事件没有返回值，例如join没有返回值，那么onJoin就是SelectClauseN类型。使用时，onJoin的参数是一个无惨函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    job.onJoin &#123; println(<span class="hljs-string">&quot;Join resumed!&quot;</span>) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>SelectClause1：对应事件有返回值，前面的onAwait和onReceive都是此类情况。</p></li><li><p>SelectClause2：对应事件有返回值，此外还需要一个额外的参数作为回调，例如Channel.onSend有两个参数，第一个表示即将发送的值，第二个是发送成功的回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">List(<span class="hljs-number">100</span>) &#123; element -&gt;<br>    select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>        channels.forEach &#123; channel -&gt;<br>            channel.onSend(element) &#123; sentChannel -&gt;<br>                println(<span class="hljs-string">&quot;send on  <span class="hljs-variable">$sentChannel</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>综上，如果想要确认挂起函数是否支持select，只需要查看其是否存在对应的SelectClauseN类型可回调即可。</p><h3 id="使用Flow实现多路复用"><a href="#使用Flow实现多路复用" class="headerlink" title="使用Flow实现多路复用"></a>使用Flow实现多路复用</h3><p>多数情况下，我们可以通过构造何时的Flow来实现多路复用的效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> login = <span class="hljs-string">&quot;...&quot;</span><br>    listOf(::getUserFromApi, ::getUserFromLocal)  <span class="hljs-comment">// list中存放函数引用</span><br>        .map &#123; function -&gt;<br>            function.call(login)  <span class="hljs-comment">// 调用函数，得到返回值</span><br>        &#125;<br>        .map &#123; deferred -&gt;<br>            flow &#123; emit(deferred.await()) &#125;  <span class="hljs-comment">// 创建Flow，发送deferred.await的返回结果</span><br>        &#125;<br>        .merge() <span class="hljs-comment">// 多个Flow合并成一个Flow</span><br>        .onEach &#123; user -&gt; <span class="hljs-comment">// 使用onEach来消费</span><br>            println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$user</span>&quot;</span>)<br>        &#125;.launchIn(<span class="hljs-keyword">this</span>)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码的关键之处在于，我们为每一个deferred都创建了一个单独的Flow，并在Flow内部发送了deferred.await()返回的结果，最后再通过<strong>merge</strong>函数合并成一个Flow来进行处理。</p><p><img src="/img/flow_merge.png" alt="使用merge合并Flow"></p><h2 id="协程的并发工具"><a href="#协程的并发工具" class="headerlink" title="协程的并发工具"></a>协程的并发工具</h2><p>协程框架提供了一些并发安全的工具，包括：</p><ul><li><p><strong>Channel</strong>：并发安全的消息通道。</p></li><li><p><strong>Mutex</strong>：轻量级锁，在获取不到锁时不会阻塞线程而是挂起等待锁的释放。代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> mutex = Mutex()<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        mutex.withLock &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></div></td></tr></table></figure></li><li><p>Semaphore：轻量级信号量，信号量可以有多个，协程在获取到信号量后即可执行并发操作。当Semaphore的参数为1时，效果等价于Mutex，代码示例如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> semaphore = Semaphore(<span class="hljs-number">1</span>)<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        semaphore.withPermit &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（四）——Kotlin协程框架初探（二）</title>
    <link href="/2021/02/21/dd192d66/"/>
    <url>/2021/02/21/dd192d66/</url>
    
    <content type="html"><![CDATA[<p>本篇继续探讨协程的取消、异常处理以及作用域问题。</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><p>协程的取消本质是协作式的取消，这点跟线程的中断一致，除了自身状态置为取消外，也需要协程体的执行逻辑能够检查状态的变化来响应取消。</p><h3 id="完善协程的取消逻辑"><a href="#完善协程的取消逻辑" class="headerlink" title="完善协程的取消逻辑"></a>完善协程的取消逻辑</h3><p>我们的Job目前还有两个函数空着没有实现，分别是cancle和invokeOnCancel。后者的实现与doOnCompleted类似，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CancellationHandlerDisposable(<span class="hljs-keyword">this</span>, onCancel)<br><br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Cancelling)?.let &#123; onCancel() &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellationHandlerDisposable</span></span>(<span class="hljs-keyword">val</span> job: Job, <span class="hljs-keyword">val</span> onCancel: OnCancel) : Disposable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cancel函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> preState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Cancelling()<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preState <span class="hljs-keyword">is</span> CoroutineState.Incomplete) &#123;<br>        preState.notifyCancellation()<br>        preState.clear()<br>    &#125;<br>    parentCancelDisposable?.disposable()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意这里使用了getAndUpdate来流转状态，也就是说我们拿到的是旧状态，旧状态如果是Incomplete则一定发生了状态流转，调用notifyCancellation来通知取消事件。</p><h3 id="支持取消的挂起函数"><a href="#支持取消的挂起函数" class="headerlink" title="支持取消的挂起函数"></a>支持取消的挂起函数</h3><p>通常来讲，一个发生了事实上挂起的挂起函数如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nonCancellableFunction</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br><br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br><br>    completableFuture.thenApply &#123;<br>        continuation.resume(it)<br>    &#125;.exceptionally &#123;<br>        continuation.resumeWithException(it)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种情况下，及时所在的协程被取消，我们也无法取消内部的异步任务CompletableFuture。为了能够取消内部的异步任务，我们需要Continuation提供一个取消状态和回调，在协程取消，回调被通知时取消掉CompletableFuture，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancellableFunction</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br>    continuation.invokeOnCancellation &#123;<br>        completableFuture.cancel(<span class="hljs-literal">true</span>)<br>    &#125;<br>   ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这个<strong>suspendCancellableCoroutine</strong>要如何实现呢？我们可以参考官方框架中的<strong>suspendCoroutine</strong>实现来做一点修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-meta">@InlineOnly</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutine</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;<br>    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;<br>        <span class="hljs-keyword">val</span> safe = SafeContinuation(c.intercepted())<br>        block(safe)<br>        safe.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>suspendCoroutineUninterceptedOrReturn的参数是一个函数，这个函数有一个参数Continuation，实际上就是我们前面文章说的编译后生成的匿名内部类的实例。SafeContinuation的作用是确保传入的Continuation对象的恢复调用只被执行一次。如何确保的呢？当block(safe)执行过程中调用了Continuation的恢复调用时，safe.getOrThrow就会获取到结果，而不是<strong>COROUTINE_SUSPENDED</strong>，这样协程就不会真正挂起了。</p><p>那么我们要对 Continuation进行改造使其支持取消的话，就要替换到SafeContinuation了，即需要实现一下效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: T = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> cancellable = CancellableContinuation(continuation.intercepted())<br>    block(cancellable)<br>    cancellable.getResult()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关键就是CancellableContinuation的实现了。</p><h3 id="CancellableContinuation的实现"><a href="#CancellableContinuation的实现" class="headerlink" title="CancellableContinuation的实现"></a>CancellableContinuation的实现</h3><p>CancellableContinuation需要具备以下能力：</p><ul><li>支持通过invokeOnCancellation注册取消回调</li><li>支持监听对应协程的取消状态</li><li>具备SafeContinuation的功能</li></ul><p>这样的话，CancellableContinuation必然是有状态的，同样我们先给出状态的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelState</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> InComplete : CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelHandler</span></span>(<span class="hljs-keyword">val</span> onCancel: OnCancel): CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CancelState()<br>    <span class="hljs-keyword">object</span> Cancelled : CancelState()<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelDecision</span> </span>&#123;<br>    UNDECIDED, SUSPENDED, RESUMED<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的状态定义跟协程的状态时一致的，这里不多说。CancelDecision枚举用于标记对应的挂起函数是否同步返回了。</p><p>CancellableContinuation需要包装一个Continuation，这里我们直接使用接口代理即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CancelState&gt;(CancelState.InComplete)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> decision = AtomicReference(CancelDecision.UNDECIDED)<br><br>    <span class="hljs-keyword">val</span> isCompleted: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            CancelState.InComplete,<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; <span class="hljs-literal">true</span><br>        &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先看invokeOnCancellation的实现，如果当前是Incomplete状态，那么就可以注册回调，如果是Cancelled状态就直接调用回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancellation</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            CancelState.InComplete -&gt; CancelState.CancelHandler(onCancel)<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;It&#x27;s prohibited to register multiple handlers.&quot;</span>)<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newState <span class="hljs-keyword">is</span> CancelState.Cancelled) &#123;<br>        onCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来尝试去监听对应协程的取消事件，可以通过协程上下文来获取对应协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installCancelHandler</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">val</span> parent = continuation.context[Job] ?: <span class="hljs-keyword">return</span> <span class="hljs-comment">// 获取协程</span><br>    parent.invokeOnCancel &#123;<br>        doCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>取消回调中通过doCancel方法来完成状态的流转。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> prevState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>            CancelState.InComplete -&gt; &#123;<br>                CancelState.Cancelled<br>            &#125;<br>            CancelState.Cancelled,<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (prevState <span class="hljs-keyword">is</span> CancelState.CancelHandler) &#123;<br>        prevState.onCancel()<br>        resumeWithException(CancellationException(<span class="hljs-string">&quot;Cancelled.&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于两种未完成的状态，流转为Cancelled，如果刘赚钱有回调注册，就调用回调通知取消事件。</p><p>由于挂起点发生了真正的挂起后注册回调才有意义，因此无需急于注册取消回调，在getResult中注册即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    installCancelHandler()  <span class="hljs-comment">// 注册取消回调</span><br>    <span class="hljs-keyword">if</span>(decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.SUSPENDED))<br>        <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>        CancelState.InComplete -&gt; COROUTINE_SUSPENDED<br>        CancelState.Cancelled -&gt; <span class="hljs-keyword">throw</span> CancellationException(<span class="hljs-string">&quot;Continuation is cancelled.&quot;</span>)<br>        <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>            (currentState <span class="hljs-keyword">as</span> CancelState.Complete&lt;T&gt;).let &#123;<br>                it.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: it.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先注册了协程的取消回调，接着通过CAS操作判断当前decision是否为<strong>UNDECIDED</strong>，如果是UNDECIDED则表示结果还未就绪，将其设置为<strong>SUSPENDED</strong>并返回挂起标志位<strong>COROUTINE_SUSPENDED</strong>。否则decision只可能为RESUMED，即挂起函数没有真正挂起并且结果已经可以获取，那么就会在Complete分支返回结果，如果未完成则会返回挂起标志COROUTINE_SUSPENDED。</p><p>接着是resumeWith的实现。该函数被调用表示挂起函数恢复执行，此时如果dicision为<strong>UNDECIDED</strong>，表示挂起函数同步返回了，后面通过getResult来获取结果，否则只能为dicision只能为<strong>SUSPENDED</strong>，即已挂起。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> &#123;<br>        decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是UNDECIDED，则不用考虑并发安全问题</span><br>            state.<span class="hljs-keyword">set</span>(CancelState.Complete(result.getOrNull(), result.exceptionOrNull()))<br>        &#125;<br>        decision.compareAndSet(CancelDecision.SUSPENDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是SUSPENDED，使用updateAndGet来更新状态并获取结果</span><br>            state.updateAndGet &#123; prev -&gt;<br>                <span class="hljs-keyword">when</span> (prev) &#123;<br>                    <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed.&quot;</span>)<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        CancelState.Complete(result.getOrNull(), result.exceptionOrNull())<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复delegate</span><br>            continuation.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>CancellableContinuation的状态转移如下图。</p><p><img src="/img/cancellation_state_transfer.png" alt="CancellableContinuation的状态转移"></p><h3 id="改造挂起函数"><a href="#改造挂起函数" class="headerlink" title="改造挂起函数"></a>改造挂起函数</h3><p>我们之前定义的挂起函数都是使用suspendCoroutine函数来实现挂起，若要响应协程的取消，需要将其替换成上面实现好的suspendCancellableCoroutine。</p><p>以delay函数为例，改造后的delay函数如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(time: <span class="hljs-type">Long</span>, unit: <span class="hljs-type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    suspendCancellableCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> future = executor.schedule(&#123; continuation.resume(<span class="hljs-built_in">Unit</span>) &#125;, time, unit)<br>        continuation.invokeOnCancellation &#123; future.cancel(<span class="hljs-literal">true</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的异常处理"><a href="#协程的异常处理" class="headerlink" title="协程的异常处理"></a>协程的异常处理</h2><p>异常处理是异步程序需要解决的关键问题。</p><h3 id="处理协程的未捕获异常"><a href="#处理协程的未捕获异常" class="headerlink" title="处理协程的未捕获异常"></a>处理协程的未捕获异常</h3><p>先定义一个异常处理器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>要处理协程的未捕获异常，我们需要在AbstractCoroutine中定义一个子类可见的函数，提供给子类复写，返回值为true表示异常已处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>我们以AbstractCoroutine子类StandaloneCoroutine为例，StandaloneCoroutine由launch启动，协会本身没有返回结果。我们虚妄它能够在遇到未捕获异常时，调用自身的异常处理器进行处理，如果没有异常处理器就抛出给所在线程的uncaughtExceptionHandler来处理，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">super</span>.handleJobException(e)<br>    context[CoroutineExceptionHandler]?.handleException(context, e) ?: Thread.currentThread()<br>        .let &#123; it.uncaughtExceptionHandler.uncaughtException(it, e) &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="取消异常的特别处理"><a href="#取消异常的特别处理" class="headerlink" title="取消异常的特别处理"></a>取消异常的特别处理</h3><p>协程的取消类似于线程的中断，取消时通过抛出取消异常来实现对取消状态的相应，因此上节的未捕获异常不应该包含取消异常。只需要定义一个函数来分发异常即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span>(e)&#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; handleJobException(e)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着在resumeWith中添加异常处理逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    ··· ···<br>    (newState <span class="hljs-keyword">as</span> CoroutineState.Complete&lt;T&gt;).exception?.let(<span class="hljs-keyword">this</span>::tryHandleException)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的作用域"><a href="#协程的作用域" class="headerlink" title="协程的作用域"></a>协程的作用域</h2><p>协程作用域用来描述协程的作用范围，作用域既有约束作用又可以提供额外的能力。</p><h3 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h3><p>官方框架中作用域包括以下三种：</p><ol><li><strong>顶级作用域</strong>：没有父协程的协程所在的作用域。</li><li><strong>协同作用域</strong>：协程中启动新的协程，新协程未所在协程的子协程，这种情况下子协程所在的作用域默认为协同作用域。子协程抛出的未捕获异常都将传递给父协程处理，同时父协程也会被取消。</li><li><strong>主从作用域</strong>：与协程作用域在协程的父子关系一致，区别是子协程的未捕获异常将不会向上传递给父协程。</li></ol><p>父子协程之间还存在以下规则：</p><ul><li>父协程被取消，所有子协程都会被取消。</li><li>父协程需要等待子协程执行完毕才会最终进入完成状态。</li><li>子协程会继承父协程的协程上下文中的元素，如果自身有相同Key的成员，将会覆盖该Key。</li></ul><p>前面几篇文章我们已经熟悉了如何去创建一个作用域了，通常我们会将协程的启动函数定义在作用域中，同时让协程的描述类来实现作用域充当Receiver的角色，基于这两点来改造下launch函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义为CoroutineScope的扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion, completion) <span class="hljs-comment">// 带Receiver的方式启动协程</span><br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="建立父子关系"><a href="#建立父子关系" class="headerlink" title="建立父子关系"></a>建立父子关系</h3><p>前面说了，父协程取消之后，子协程也需要被取消，因此我们要对AbstractCoroutine稍加改造，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> parentJob = context[Job]<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> parentCancelDisposable : Disposable? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">init</span> &#123;<br>    ··· ···<br>    parentCancelDisposable = parentJob?.invokeOnCancel &#123; <br>        cancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过协程上下文来获取父协程，如果父协程存在，那么就需要注册一个取消回调，当父协程取消时取消掉当前协程。</p><h3 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h3><p>我们对launch函数进行改造之后，需要一个作用域来调用launch函数才能启动一个协程，但作用域又是在创建协程过程中产生的。针对这个问题，我们需要一个特殊的作用域，这个作用域不需要依赖父作用域来产生，这个作用域就叫做<strong>顶级作用域</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> scopeContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br><br>GlobalScope.launch&#123;<br>  ··· ···<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于协程描述类AbstractCoroutine本身实现了CoroutineScope，因此由GlobalScope.launch启动的协程体内部我们可以直接创建新的子协程。</p><h3 id="实现异常传播"><a href="#实现异常传播" class="headerlink" title="实现异常传播"></a>实现异常传播</h3><p>接下来考虑一下子协程如何将异常向上传递。按照现有的实现，我们已经将该异常处理传递到tryHandleException中，对于非取消异常的情况都交给了handleJobException来处理。按照协同作用域的设计，协程遇到未捕获的异常时应当优先向上传播，如果没有父协程才自行处理。因此我们添加一个函数<strong>handleChildException</strong>用于接收子协程的异常，改造一下tryHandleException：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    cancel()  <span class="hljs-comment">// 取消父协程</span><br>    <span class="hljs-keyword">return</span> tryHandleException(e) <span class="hljs-comment">// 继续向上传递或者自己处理</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span> (e) &#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; (parentJob <span class="hljs-keyword">as</span>? AbstractCoroutine&lt;*&gt;)?.handleChildException(e) <span class="hljs-comment">// 交给父协程处理</span><br>        ?.takeIf &#123; it &#125;<br>        ?: handleJobException(e)  <span class="hljs-comment">// 没有父协程 自行处理</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注释已经很完善了，当出现未捕获异常时，先尝试调用父协程的handleChildException来处理，否则自行处理。父协程也优先调用父协程的父协程来处理。</p><h3 id="主从作用域"><a href="#主从作用域" class="headerlink" title="主从作用域"></a>主从作用域</h3><p>协同作用域的效果就是父子协程绑定，父取消则子取消，子异常则父连坐。而主从作用域则可以避免子协程出现异常而导致父协程取消的情况。</p><p>我们只需要将上面的<strong>handleChildException</strong>方法返回false即可避免子协程将异常传递给父协程，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(context: CoroutineContext, continuation: Continuation&lt;T&gt;) :<br>    ScopeCoroutine&lt;T&gt;(context, continuation) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>也很容易去创建这样一个作用域，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">supervisorScope</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: R = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> coroutine = SupervisorCoroutine(continuation.context, continuation)<br>    block.startCoroutine(coroutine, coroutine)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主从作用域的应用场景多见于子协程为独立对等的任务实体的情况，例如Android平台的Jetpack开发包中ViewModel内置的viewModelScope就是主从作用域实现。</p><h3 id="完整的异常处理流程"><a href="#完整的异常处理流程" class="headerlink" title="完整的异常处理流程"></a>完整的异常处理流程</h3><p>引入作用域后完整的异常处理流程如下如所示。</p><p><img src="/img/complete_exception_handle.png" alt="完整的异常处理流程"></p><h3 id="父协程等待子协程完成"><a href="#父协程等待子协程完成" class="headerlink" title="父协程等待子协程完成"></a>父协程等待子协程完成</h3><p>作用域要求父协程必须等待子协程执行完才可以进入完成状态，因此父协程的resumeWith执行完成后需要检查子协程是否完成，未完成则需要注册完成回调，等待所有子协程状态流转为完成状态父协程才能触发完成回调并且流转为完成态。我们只需要新增一个等待的状态即可，状态流转如下所示。</p><p><img src="/img/scope_state_transfer.png" alt="完整的异常处理流程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——Kotlin协程框架初探（一）</title>
    <link href="/2021/02/16/b912c613/"/>
    <url>/2021/02/16/b912c613/</url>
    
    <content type="html"><![CDATA[<p>前面四篇文章我们了解了如何使用<strong>createCoroutine</strong>和<strong>startCoroutine</strong>这两个API来创建和启动简单协程，并且可以使用它们来构造复合协程。但客观的说，这两个API并不太适合直接在业务开发中使用，所以Kotlin协程为开发者提供了一些更贴近业务的复合协程API，即官方协程框架<a href="https://github.com/Kotlin/kotlinx.coroutines"><strong>kotlinx.coroutines</strong></a>。后面几篇文章我们就来尝试窥探一下这个庞大的框架的一角。</p><h2 id="协程的描述"><a href="#协程的描述" class="headerlink" title="协程的描述"></a>协程的描述</h2><p>对于协程的创建，官方框架中根据不同的目的提供了不同的构造器。</p><h3 id="协程的描述类"><a href="#协程的描述类" class="headerlink" title="协程的描述类"></a>协程的描述类</h3><p>Java中提供了线程的Java描述类Thread，通过调用<strong>Thread#start</strong>方法我们就可以通知系统启动一个线程，我们也知道<strong>Thread#run</strong>方法即为线程的执行代码，同时Thread也提供了类型join、interrupt、isAlive等方法来方便我们操作线程。类似的，我们也需要这样一个类来描述协程，按照官方框架的做法把它命名为Job，API设计如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;<br>        <span class="hljs-keyword">get</span>() = Job<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断协程是否扔在执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程取消回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程完成回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnCompelete</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取消协程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 与[Thread.join]类似，挂起外部协程直到当前协程完成</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>我们对协程的状态进行封装，让其状态管理更加简便。主要是<strong>未完成</strong>、<strong>已取消</strong>、<strong>已完成</strong>这三种状态。状态的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Incomplete</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cancelling</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CoroutineState()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>进一步解释下这三种状态：</p><ul><li>Incomplete：协程启动后立即进入该状态，直到完成或者被取消。</li><li>Cancelling：协程执行中被取消后进入该状态。进入该状态后，要等待协程体内部的挂起函数调用相应取消，相应后协程成功被取消或者抛出CancellationException取消，最终会流转为Complete状态。</li><li>Complete：协程执行完成进入该状态。</li></ul><h3 id="支持回调的状态"><a href="#支持回调的状态" class="headerlink" title="支持回调的状态"></a>支持回调的状态</h3><p>注册回调时，需要根据当前状态的不同采取不同的处理方式，回调注册的操作也必须是原子操作，否则会有状态不一致问题。跟上篇文章相同，我们在状态流转时采用元子类来处理原子操作，比加锁性能会有较大提升。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-comment">// 返回新状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用updateAndGet，在Lambda表达式中返回新的状态，内部会采用CAS操作来更新新状态，如果更新不成功，Lambda表达式会重复调用。</p><p>用于存放回调的数据结构也必须支持并发安全。这里我们提供一个递归列表，它具有不变形，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposableList</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> Nil : DisposableList()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span></span>(<br>        <span class="hljs-keyword">val</span> head: Disposable,<br>        <span class="hljs-keyword">val</span> tail: DisposableList<br>    ) : DisposableList()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过递归来实现对该列表的访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: DisposableList &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>        DisposableList.Nil -&gt; <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (head == disposable) tail<br>            <span class="hljs-keyword">else</span> DisposableList.Cons(head, tail.remove(disposable))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">forEach</span><span class="hljs-params">(action: (<span class="hljs-type">Disposable</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    DisposableList.Nil -&gt; <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>        action(<span class="hljs-keyword">this</span>.head)<br>        <span class="hljs-keyword">this</span>.tail.forEach(action)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Disposable&gt;</span> DisposableList.<span class="hljs-title">loopOn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> =<br>    forEach &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> T -&gt; action(it)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>我们把这个不变列表添加到状态中，在状态发生变化时，上一个状态的回调可以传递给新状态，确保已注册的回调不丢失。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> disposableList: DisposableList = DisposableList.Nil<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拿到上一个状态的所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">from</span><span class="hljs-params">(state: <span class="hljs-type">CoroutineState</span>)</span></span>: CoroutineState &#123;<br>        disposableList = state.disposableList<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">with</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = DisposableList.Cons(disposable, disposableList)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">without</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = <span class="hljs-keyword">this</span>.disposableList.remove(disposable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清除所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>        disposableList = DisposableList.Nil<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的初步实现"><a href="#协程的初步实现" class="headerlink" title="协程的初步实现"></a>协程的初步实现</h3><p>定义好状态后，接下来要为状态机输入事件，定义一个Job的抽象子类如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> context: CoroutineContext) : Job, Continuation&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子状态机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br><br>    <span class="hljs-keyword">val</span> isCompleted<br>        <span class="hljs-keyword">get</span>() = state.<span class="hljs-keyword">get</span>() <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;,<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">true</span><br>        &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        state.<span class="hljs-keyword">set</span>(CoroutineState.Incomplete()) <span class="hljs-comment">// 初始化为Incomplete状态</span><br>        <span class="hljs-keyword">this</span>.context = context + <span class="hljs-keyword">this</span><br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AbstractCoroutine同时实现了<strong>Continuation</strong>接口，这个我们已经熟悉了，是为了能够传入作为completion在启动时传入协程，以监听协程的完成事件。</p><h2 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h2><p>我们在协程的描述中定义好了协程应该具备哪些能力，接下来要考虑如何封装协程的创建。</p><h3 id="无返回值的luanch"><a href="#无返回值的luanch" class="headerlink" title="无返回值的luanch"></a>无返回值的luanch</h3><p>如果协程的返回值是为Unit，那我们可以认为它<strong>无返回值</strong>，对于这种协程只需要启动它即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>launch的实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">launch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(context: CoroutineContext) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(context)<br></code></pre></div></td></tr></table></figure><h3 id="实现invokeOnCompletion"><a href="#实现invokeOnCompletion" class="headerlink" title="实现invokeOnCompletion"></a>实现invokeOnCompletion</h3><p>用launch创建的协程可以立即运行起来，如果我们知道它什么时候结束，可以通过注册OnComplete回调来做到这一点。我们需要做两件事：</p><ol><li>将回调注册到协程中。</li><li>在协程完成时通知回调。</li></ol><p>Job接口中定义的OnComplete实际只是一个函数，声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> OnComplete = () -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></div></td></tr></table></figure><p>这里并没有携带任何参数，因为协程执行完成的结果我们有更好的方式去获取，这里的OnComplete仅仅用于通知协程执行结束。但对于协程内部来说，我们需要获取结果来进行状态流转，所以这里定义一个doOnCompleted函数在注册获取结果的回调，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnComplete</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">return</span> doOnCompleted &#123; _ -&gt; onComplete() &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnCompleted</span><span class="hljs-params">(block: (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CompletionHandlerDisposable(<span class="hljs-keyword">this</span>, block)<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Complete&lt;T&gt;)?.let &#123;<br>        block(<br>            <span class="hljs-keyword">when</span> &#123;<br>                it.value != <span class="hljs-literal">null</span> -&gt; Result.success(it.value)<br>                it.exception != <span class="hljs-literal">null</span> -&gt; Result.failure(it.exception)<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Won&#x27;t happen.&quot;</span>)<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompletionHandlerDisposable</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> job: Job,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> OnComplete: (Result&lt;T&gt;) -&gt; <span class="hljs-built_in">Unit</span><br>) : Disposable &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，<strong>除了Complete状态时我们可以直接回调OnComplete，其它状态的流转我们都需要构造一个新的状态对象来确保并发安全</strong>。</p><p>注册回调的过程分为以下三步：</p><ol><li>构造一个CompletionHandlerDisposable对象。它有一个disposable函数，用于将对应的回调移除。</li><li>检查状态，并将回调添加到状态中。</li><li>在状态流转成功后，获得最终的状态，如果是Complete状态则立即回调OnComplete。</li></ol><p>Job的remove函数还未实现，来看看。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现与doOnCompleted刚好相反。</p><p>接下来思考下如何通知回调。想一下如何知道协程执行完毕呢，没错就是当<strong>AbstractCoroutine#resumeWith</strong>函数调用时，协程执行完毕。因此我们只需要在AbstractCoroutine#resumeWith函数中将协程流转为完成状态，并且通知此前注册的完成回调即可。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Complete(result.getOrNull(), result.exceptionOrNull()).from(prev)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed!&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知完成回调</span><br>    newState.notifyCompletion(result)<br>    newState.clear()<br>&#125;<br><br>[CoroutineState.kt]<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">notifyCompletion</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.disposableList.loopOn&lt;CompletionHandlerDisposable&lt;T&gt;&gt; &#123;<br>        it.onComplete(result)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里Cancelling会流转为Complete的关键是，协程被取消后并不会立即停止执行，而是要等待内部的挂起点相应，这个我们后面再详细讨论。</p><h3 id="实现join"><a href="#实现join" class="headerlink" title="实现join"></a>实现join</h3><p>join是一个挂起函数，它被调用时会有两种情况：</p><ul><li>被等待的协程已经完成，join不会挂起而是立即返回。</li><li>被等待的协程未完成，join立即挂起，直到协程完成。</li></ul><p>由于上面已经实现了完成回调，因此join只需要判断是否挂起，以及在挂起后被等待协程完成时回调中使用resume恢复挂起即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-keyword">return</span> joinSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt;<br>        continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="有返回值的async"><a href="#有返回值的async" class="headerlink" title="有返回值的async"></a>有返回值的async</h3><p>现在我们已经知道如何启动协程并等待协程执行完成，不过很多时候我们更想拿到协程的返回值，因此我们基于Job再定义一个接口Deferred如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deferred</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Job &#123;</span></span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里多了一个泛型参数T，T表示返回值类型，通过它的await函数也可以拿到这个返回值，await的作用主要是：</p><ol><li>在协程已经执行完成时，立即返回协程的结果，或者异常。</li><li>如果协程未完成，则挂起直到当前协程执行完成。</li></ol><p>该方法与join类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (currentState) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; awaitSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>            currentState.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: (currentState.value <span class="hljs-keyword">as</span> T)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt; continuation.resumeWith(result) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来可以写出有返回值的async函数的实现了，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Deferred&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> completion = DeferredCoroutine&lt;T&gt;(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">val</span> deferred = async &#123;<br>    getValue()<br>&#125;<br><span class="hljs-keyword">val</span> result = deferred.await()<br>println(result)<br></code></pre></div></td></tr></table></figure><p>这与我们前几篇实现的async/await仅有细节的差别。</p><h2 id="协程的调度"><a href="#协程的调度" class="headerlink" title="协程的调度"></a>协程的调度</h2><p>我们已经大致实现了一个比较完整的复合协程，不过还要一个问题，如何指定协程的运行线程，或者说如何对协程进行线程调度？</p><h3 id="协程的调度位置"><a href="#协程的调度位置" class="headerlink" title="协程的调度位置"></a>协程的调度位置</h3><p>协程在挂起点位置可能需要进行调度，为什么说可能，前几篇文章已经说过了，只有发生了事实上的异步行为时，才需要调度。我们再来回顾一下什么是事实上的异步：</p><ul><li>挂起点对应的挂起函数内部切换了线程，并在该线程内部调用Continuation#resume来恢复。</li><li>挂起函数内部通过事件循环机制将Continuation的恢复调用转移到了新的线程调用栈上，例如Android平台上的Handler#post。</li><li>挂起函数内部将Continuation实例白村，在后续某个时间再恢复调用。</li></ul><p>综上所述，只有恢复和挂起不在同一个函数调用栈执行的情况，我们才有机会实现调度，而实现调度需要使用协程的<strong>拦截器</strong>。</p><h3 id="协程的调度器设计"><a href="#协程的调度器设计" class="headerlink" title="协程的调度器设计"></a>协程的调度器设计</h3><p><strong>调度的本质是利用拦截器将协程的恢复调用转移到一个特定的线程上</strong>，由此可以写出下列代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContext</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatcherContinuation(continuation, dispatcher)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> delegate: Continuation&lt;T&gt;, <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = delegate.context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        dispatcher.dispatch &#123;<br>            delegate.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基于线程池的调度器"><a href="#基于线程池的调度器" class="headerlink" title="基于线程池的调度器"></a>基于线程池的调度器</h3><p>我们最常见的调度场景就是制定代码的执行线程，而在Java平台上使用线程池是比较好的做法，官方调度器也是如此。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DefaultDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadGroup = ThreadGroup(<span class="hljs-string">&quot;DefaultDispatcher&quot;</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadIndex = AtomicInteger(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executor =<br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>) &#123; runnable -&gt;<br>            Thread(<br>                threadGroup,<br>                runnable,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;threadGroup.name&#125;</span>-worker-<span class="hljs-subst">$&#123;threadIndex.getAndDecrement()&#125;</span>&quot;</span><br>            ).apply &#123; isDaemon = <span class="hljs-literal">true</span> &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        executor.submit(block)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-keyword">val</span> Default <span class="hljs-keyword">by</span> lazy &#123;<br>        DispatcherContext(DefaultDispatcher)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里我们创建了一个CPU密集型线程池，并且线程全部设置为守护线程。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch(Dispatchers.Default) &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">2000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>println(1)和println(2)都将运行在Default调度器对应线程上。</p><h3 id="基于UI事件循环的调度器"><a href="#基于UI事件循环的调度器" class="headerlink" title="基于UI事件循环的调度器"></a>基于UI事件循环的调度器</h3><p>Android开发者比较关心如何将协程调度到主线程上。这个比较简单，直接使用Handler#post即可将协程体发送到主线程消息循环中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidMainDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = Handler(Looper.getMainLooper())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——复合协程</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将基于简单协程实现几种复合协程。</p><h2 id="序列生成器"><a href="#序列生成器" class="headerlink" title="序列生成器"></a>序列生成器</h2><h3 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h3><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums: (<span class="hljs-built_in">Int</span>) -&gt; Generator&lt;<span class="hljs-built_in">Int</span>&gt; = generator &#123; start: <span class="hljs-built_in">Int</span> -&gt;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) &#123;<br>        yield(start + i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> gen: Generator&lt;<span class="hljs-built_in">Int</span>&gt; = nums(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> gen) &#123;<br>    println(j)<br>&#125;<br><br><span class="hljs-comment">// 运行结果 </span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt; = GeneratorIterator(block, parameter)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建一个序列生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReady</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : State()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ready</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, <span class="hljs-keyword">val</span> nextValue: T) : State()<br>    <span class="hljs-keyword">object</span> Done : State()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取下一个元素</span><br><span class="hljs-comment"> * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程</span><br><span class="hljs-comment"> * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; &#123;<br>            resume()<br>            <span class="hljs-keyword">return</span> next()<br>        &#125;<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;<br>            state = State.NotReady(currentState.continuation)<br>            (currentState <span class="hljs-keyword">as</span> State.Ready&lt;T&gt;).nextValue<br>        &#125;<br>        State.Done -&gt; &#123;<br>            <span class="hljs-keyword">throw</span>  IndexOutOfBoundsException(<span class="hljs-string">&quot;No value left.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用suspendCoroutine挂起当前协程</span><br><span class="hljs-comment"> * 并将当前状态流转为[State.Ready]状态，返回value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    state = <span class="hljs-keyword">when</span> (state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;cannot yield while ready.&quot;</span>)<br>        <span class="hljs-keyword">is</span> State.Done -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;cannot yield while done.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    resume()<br>    <span class="hljs-keyword">return</span> state != State.Done<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动或者恢复协程</span><br><span class="hljs-comment"> * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建协程的completion回调</span><br><span class="hljs-comment"> * 协程执行完成后回调</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    state = State.Done<br>    println(result.getOrThrow())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; block(parameter) &#125;<br>    <span class="hljs-comment">// 带Receiver的方式创建协程</span><br>    <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 初始化状态</span><br>    state = State.NotReady(start)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorIterator</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : GeneratorScope&lt;T&gt;, Iterator&lt;T&gt;, Continuation&lt;Any?&gt;<br></code></pre></div></td></tr></table></figure><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h3 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h3><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sequence = sequence &#123;<br>        yield(<span class="hljs-number">1</span>)<br>        yield(<span class="hljs-number">2</span>)<br>        yield(<span class="hljs-number">3</span>)<br>        yieldAll(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>&#125;<br><br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">in</span> sequence) &#123;<br>    println(num)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fibonacci = sequence &#123;<br>    yield(<span class="hljs-number">1L</span>)<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">var</span> next = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        yield(next)<br>        next += current<br>        current = next - current<br>    &#125;<br>&#125;<br><br>fibonacci.take(<span class="hljs-number">10</span>).forEach(::println) <span class="hljs-comment">// 使用take(10)获取前10个元素</span><br></code></pre></div></td></tr></table></figure><h2 id="Promise-模型"><a href="#Promise-模型" class="headerlink" title="Promise 模型"></a>Promise 模型</h2><p>Promise模型又叫async/await，是目前最常见也最容易理解和上手的协程实现。</p><p>async/await的设计可以在async函数内部对复合Promise协议的异步回调进行await，使得异步逻辑变成了同步代码。这是目前主流的协程实现，它的关键在于将函数分为两种：</p><ul><li>普通函数：只能够调用普通函数，不存在协程的挂起和恢复逻辑。</li><li>async函数：既可以调用普通函数，也可以调用async函数，且可以将回调通过await同步化。</li></ul><p>async和wait各司其职，分别实现协程的挂起和恢复的逻辑，上手几乎没有成本。</p><h3 id="仿JavaScript的async-await实现"><a href="#仿JavaScript的async-await实现" class="headerlink" title="仿JavaScript的async/await实现"></a>仿JavaScript的async/await实现</h3><p>利用kotlin协程实现一个async/await的复合协程，效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">async &#123;<br>    <span class="hljs-keyword">val</span> user = await &#123; gitHubApi.getUserCallback(<span class="hljs-string">&quot;sukaidev&quot;</span>) &#125;<br>    println(user)<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>User(userName=sukaidev, blog=https:<span class="hljs-comment">//www.sukaidev.top, location=GuangZhou,China, bio=Focus on Jetpack)</span><br></code></pre></div></td></tr></table></figure><p>先思考下async如何实现。async接收一个函数作为参数，这个函数即协程体，必然是个挂起函数。async创建成功后协程即启动，并且内部可以使用await方法来挂起协程。async函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">AsyncScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> completion = AsyncCoroutine(context)<br>    block.startCoroutine(completion, completion)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCoroutine</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext) :<br>    Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, AsyncScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        result.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于async启动的协程不需要返回值，所以作为completion存在的AsyncCoroutine没有泛型参数。</p><p>await函数定义在AsyncScope中，使得它可以在async构造的协程中调用，它主要的作用就是将网络请求的回调转为协程，使用suspendCoroutine实现即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncScope</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">await</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> call = block()<br>        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                    response.body()?.let(continuation::resume)<br>                        ?: continuation.resumeWithException(NullPointerException())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                continuation.resumeWithException(HttpException(response))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                continuation.resumeWithException(t)<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>async/await的状态比较简单，只有挂起以及被封装的回调完成状态，状态之间的流转由await单独来完成，因此不需要额外的状态机实现。当我们引入了协程的取消处理、异常处理等逻辑后，状态机的存在就至关重要了。</p><h2 id="Luna风格的协程API"><a href="#Luna风格的协程API" class="headerlink" title="Luna风格的协程API"></a>Luna风格的协程API</h2><p>我们在使用Kotlin协程时，总是说创建了一个协程，不像创建线程会有一个对应的类或者对象。在之前的复合协程中，我们总是把协程的状态机封装在协程的完成回调Continuation实例competition中，由于这个实例提供了各种的协程能力，所以我们一般它当做复合协程本身。</p><p>使用Luna API创建协程与创建线程一样，只需提供一个函数，返回一个协程的控制类来控制协程的执行，我们可以基于Kotlin的简单协程来实现这样的一套API。</p><h3 id="非对称API实现"><a href="#非对称API实现" class="headerlink" title="非对称API实现"></a>非对称API实现</h3><p>非对称协程的主要特点就是在协程挂起时，协程控制权返回给了调用者，我们先看下实现效果，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer = Coroutine.create&lt;<span class="hljs-built_in">Unit</span>, <span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        println(<span class="hljs-string">&quot;send <span class="hljs-variable">$i</span>&quot;</span>)<br>        yield(i)<br>    &#125;<br>    <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = Coroutine.create&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Unit</span>&gt; &#123; parameter: <span class="hljs-built_in">Int</span> -&gt;<br>    println(<span class="hljs-string">&quot;start <span class="hljs-variable">$parameter</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">val</span> value = yield(<span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;receive <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive) &#123;<br>    <span class="hljs-keyword">val</span> result = producer.resume(<span class="hljs-built_in">Unit</span>)<br>    consumer.resume(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过Coroutine的伴生对象来创建协程，参数为协程体，协程体的参数类型和返回值类型由泛型参数指定。create的返回值用来控制协程的执行，结合前面几篇文章，我们知道这个返回值其实就是封装了协程状态机的实例，与SafeContinuation的作用十分类似，我们也习惯于将这个实例作为协程的完成回调，即competition。yield函数类似于序列生成器中的yield的作用，将当前协程挂起并将它的参数作为协程这一次resume调用的返回值。</p><p>状态机的状态设计是关键点，有如下几个状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Created</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yielded</span>&lt;<span class="hljs-type">P</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;P&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resumed</span>&lt;<span class="hljs-type">R</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;R&gt;) : Status()<br>    <span class="hljs-keyword">object</span> Dead : Status()<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>Created：</strong>协程处于刚刚被创建状态，需要等待resume函数的调用来启动协程。</li><li><strong>Yielded：</strong>协程内部调用yield函数后挂起，泛型参数P表示协程的参数类型。</li><li><strong>Resumed：</strong>协程外部调用resume函数之后协程恢复执行，泛型参数R表示协程的返回值类型。</li><li><strong>Dead：</strong>表示协程已经执行完毕。</li></ul><p>状态之间的转移如下所示。</p><p><img src="/img/state_transfer_02.png" alt="状态流转图"></p><p>创建一个CoroutineScope来约束yield的调用范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span>&lt;<span class="hljs-type">P, R</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">val</span> parameter: P?   <span class="hljs-comment">// 协程体启动时的参数</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于Coroutine的对象需要返回给调用者，所以我们这里不能让Coroutine来直接实现CoroutineScope，而是在内部创建了一个CoroutineScope的匿名内部类。协程描述类的部分代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coroutine</span>&lt;<span class="hljs-type">P, R</span>&gt; <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.(P) -&gt; R<br>) : Continuation&lt;R&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P, R&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>&lt;<span class="hljs-type">P</span>, R&gt;.(P)</span></span> -&gt; R<br>        ): Coroutine&lt;P, R&gt; &#123;<br>            <span class="hljs-keyword">return</span> Coroutine(context, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = <span class="hljs-keyword">object</span> : CoroutineScope&lt;P, R&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> parameter: P? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>          ... ...<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: AtomicReference&lt;Status&gt;<br>  <br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>      <span class="hljs-keyword">get</span>() = status.<span class="hljs-keyword">get</span>() != Status.Dead<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.() -&gt; R = &#123; block(parameter!!) &#125;<br>        <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(scope, <span class="hljs-keyword">this</span>)<br>        status = AtomicReference(Status.Created(start))<br>    &#125;<br>  ... ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码结构与之前的序列生成器的迭代器类似，不过有两点区别：</p><ol><li>提供了一个工厂方法create函数，用于手动创建Coroutine对象，同时返回该对象，使得外部可以控制Coroutine对象的恢复逻辑。</li><li>状态机status我们使用了AtomicReference<Status>，这是为了确保状态机的流转在多线程情况下仍然能够保证原子性。</li></ol><p>我们再来看下yield的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)  <span class="hljs-comment">// 恢复外部协程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数使用<strong>suspendCoroutine</strong>来挂起函数，这个我们已经很熟悉了。与序列生成器的yield实现不同的是，这里yield是有返回值的，为P类型也就是协程的入参类型，这使得yield同时也可以作为消费者来使用。</p><p>status.getAndUpdate接收一个参数为上一个状态，并要求返回新的状态，这个函数可能会被执行多次。当previousStatus确实是Resumed，就调用它的continuation.resume来<strong>恢复此前恢复执行当前协程的协程</strong>，这里有点绕，其实就是恢复外部协程的执行，外部协程指我们创建producer和consumer的协程。外部协程为什么会挂起跟我们的resume函数实现有关，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;  <span class="hljs-comment">// 挂起外部协程</span><br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; &#123;<br>                scope.parameter = value<br>                Status.Resumed(continuation)<br>            &#125;<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; Status.Resumed(continuation)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already resumed!&quot;</span>)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (previousStatus) &#123;  <span class="hljs-comment">// 恢复当前协程</span><br>        <span class="hljs-keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>        <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="hljs-keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当外部调用resume恢复该协程时，当前状态可能为：</p><ul><li>Created，协程只是创建，并未启动。</li><li>Yielded，协程已执行处于挂起状态。</li></ul><p>resume函数的作用是挂起外部协程，并且启动或恢复当前协程的执行。外部协程挂起后，我们将其continuation实例存入到状态机中，当当前协程yield函数被调用时，又会将外部协程恢复，使得外部协程可以继续执行后续工作，例如调用另一个协程的resume函数。文字说起来可能比较抽象，这里画了一个时序图，如下。</p><p><img src="/img/asymmetric_api.png" alt="非对称API时序图"></p><p>最后就是resumeWith的实现了，它的调用表示该协程已经执行完毕，需要将状态流转为State.Dead，同时不要忘记恢复外部协程执行，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Dead<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此，Lua风格的非对称协程API完成。</p><h3 id="对称API实现"><a href="#对称API实现" class="headerlink" title="对称API实现"></a>对称API实现</h3><p>对称协程意味着协会可以任意、平等地传递调度权。在传递过程过，调度权转出的协程需要提供目标协程的对象及参数，目标协程应处于挂起状态等待接收调度权，中间应当有一个控制中心来协助完成调度权的转移。控制中心需要具备以下能力：</p><ul><li>在当前协程挂起时接收调度权。</li><li>根据目标协程对象来完成调度权的最终转移。</li></ul><p>这个控制中心显然是一个可以恢复（当前协程挂起）和挂起（传递调度权给目标协程）的协程，实际上我们之前的非对称API中的外部协程已经具备了一些控制中心的能力，我们只需要对其进行改造即可。效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SymCoroutines &#123;<br>    <span class="hljs-keyword">val</span> coroutine0: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; params: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-0 <span class="hljs-variable">$params</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine2, <span class="hljs-number">0</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(SymCoroutine.main, <span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine1: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-1 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> result = transfer(coroutine0, <span class="hljs-number">1</span>)<br>        println(<span class="hljs-string">&quot;coroutine-1 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine2: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-2 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine1, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(coroutine0, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 2 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br>SymCoroutine.main &#123;<br>    println(<span class="hljs-string">&quot;main 0&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="hljs-number">3</span>)<br>    println(<span class="hljs-string">&quot;main end <span class="hljs-variable">$result</span>&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用<strong>SymCoroutine.create</strong>创建了多个协程，并且使用<strong>SymCoroutine.main</strong>创建了一个外部协程，这个外部协程就是控制中心，后文简称为 Main协程。Main协程通过<strong>transfer</strong>函数将调度权转移给coroutine2，从而开始了对称协程的调度权转移过程。</p><p><img src="/img/sym_coroutine_sequence_diagram.png" alt="调度权转移时序图"></p><p>与之前一样，我们定义一个作用域接口来提供transfer函数，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，泛型参数T为对称协程的参数类型，而transfer函数的泛型参数P表示目标协程的参数类型，对称协程自身的定义决定了它不存在返回值，这点与非对称协程不同。</p><p>接下来就是协程描述类SymCoroutine以及它的create和main函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> main: SymCoroutine&lt;Any?&gt;<br><br>        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">Any</span>?&gt;.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span> &#123;<br>            SymCoroutine&lt;Any?&gt; &#123;<br>                block()<br>            &#125;.also &#123;<br>                main = it<br>            &#125;.start(<span class="hljs-built_in">Unit</span>)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: SymCoroutine&lt;T&gt; = SymCoroutine(context, block)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        ... ...<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> isMain: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span> == main<br>    ... ... <br>&#125;<br></code></pre></div></td></tr></table></figure><p>main函数的作用是创建Main协程，同时会将其赋值给伴生对象属性main，方便其他协程将调度权归还给控制中心。</p><p>接下来我们思考下当前协程如何将调度权转出。<strong>由于当前协程本质上是由Main协程启动的协程，因此只要调用内部的非对称协程的yield函数将自身挂起，调度权自然就交回到了Main协程手中</strong>。Main协程只需要读取它自己的resume的返回值即可得到目标协程对象及参数。因此yield的参数类型定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameter</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="hljs-keyword">val</span> value: T)<br></code></pre></div></td></tr></table></figure><p>SymCoroutin内部的非对称协程的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    ... ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coroutine = Coroutine.create&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;<br>        Parameter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>, <span class="hljs-keyword">suspend</span> &#123;<br>            block(body, it)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) <span class="hljs-built_in">Unit</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>        &#125;() <span class="hljs-keyword">as</span> T)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        coroutine.resume(value)<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于内部的非对称协程而言，yield函数的参数类型**Parameter<T>**自然就是它的返回值类型，因此我们看到携程体内构造了一个Parameter的实例。不过我们在传入Parameter参数的时候，应传入目标协程和目标协程的参数，但这里我们传入了this，这是为什么呢？因为这是协程执行完后的最后一行代码，由于对称协程在执行完成之前必须交出调度权，所以这段代码只会被特权协程执行。第二个参数也是如此，创建了一个Lambda表达式并且理解调用了它，并在其中执行了block触发协程体的执行，普通的对称协程在block内部就会通过调用transfer交出调度权。</p><p>接下来是最关键的transfer函数的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">tailrec</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transferInner</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">            value: <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) &#123; <span class="hljs-comment">// Main协程在转移调度权</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (symCoroutine.isMain) &#123;<br>                    value <span class="hljs-keyword">as</span> T  <span class="hljs-comment">// ... ③</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="hljs-keyword">as</span> P)  <span class="hljs-comment">// ... ①</span><br>                    transferInner(parameter.coroutine, parameter.value)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 对称协程转移调度权到其他协程或者Main协程</span><br>                coroutine.run &#123;<br>                    <span class="hljs-keyword">return</span> yield(Parameter(symCoroutine, value <span class="hljs-keyword">as</span> P))  <span class="hljs-comment">// ... ②</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T &#123;<br>            <span class="hljs-keyword">return</span> transferInner(symCoroutine, value)<br>        &#125;<br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们按照之前代码的执行逻辑来分析一下transfer的调用逻辑。</p><ul><li>程序开始执行时，调度权最开始在特权协程手中，调用transfer将调度权转给coroutine2，transferInner入参symCoroutine为coroutine2，在①处调用coroutine2的resume挂起Main协程，coroutine2开始执行。</li><li>接下来coroutine2调用transfer函数转给coroutine1时，先将调度权交出，实际上就是在②处调用yield将自己挂起，此时接收调度权的Main协程在①处的resume函数返回，parameter中携带的其实就是coroutine1和它的参数。</li><li>此时Main协程中递归调用transferInner并再次进入①处挂起自己，由于coroutine1尚未启动，因此直接开始执行，直到调用transfer转给coroutine0。</li><li>最终，在coroutine()中将调度权归还给Main协程，transferInner落入③处分支直接返回。</li></ul><p>至此，基于非对称协程API实现的对称协程API原理分析完毕。</p><h2 id="复合协程的实现模式"><a href="#复合协程的实现模式" class="headerlink" title="复合协程的实现模式"></a>复合协程的实现模式</h2><p>结合本篇几个案例的实现，我们可以把<strong>复合协程实现模式</strong>归纳如下。</p><ul><li><strong>协程的构造器</strong>。我们总是需要一套更好更简便的API来创建协程，例如async{ … }或者Coroutine.create{ … }。</li><li><strong>协程的返回值</strong>。协程可以有返回值，这一点主要是由协程完成时对completion的调用来保证的。</li><li><strong>协程的状态机</strong>。在Kotlin协程的基础设施中，协程本身已经存在创建、执行、挂起、完成等状态了，我们通常需要对这些状态进行管理以控制协程的执行逻辑。状态流转过程在并发环境下需要考虑并发安全问题，我们可以在状态流转时通过加锁来确保这一点，也可以采用更高效的CAS算法来确保状态流转的原子性。</li><li><strong>协程的作用域</strong>。作用域主要用作协程体的Receiver，从而令协程体能够方便地获得协程自身的信息或者调用协程体专属的函数（例如yield）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念与原理</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p><strong>Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现</strong>。不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br> SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></div></td></tr></table></figure><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)<br>    <span class="hljs-string">&quot;return value.&quot;</span><br>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><br><br><span class="hljs-comment">// 控制台输出：</span><br>Coroutine Start.<br>Coroutine End : Success(<span class="hljs-keyword">return</span> value.)<br></code></pre></div></td></tr></table></figure><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br> createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)<br></code></pre></div></td></tr></table></figure><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br></code></pre></div></td></tr></table></figure><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(value.toString())<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)<br>        print(<span class="hljs-number">1000</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        hashCode(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们<strong>main</strong>函数可以直接被声明为suspend：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.result = result<br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    continuation.resume(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即连续传递样式变换。CPS是一种编程风格，用来将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者，这就将它的程序流程显式的暴露给程序员。而CPS变换就是将原本不是CPS风格的代码转变为CPS风格，通常由编译器来对代码进行优化，<strong>而Kotlin协程能够采用同步的方式书写异步代码的原理正是由于编译器使用了CPS变换</strong>。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend</strong>函数发现，<strong>notSuspend()**函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，就是</strong>CPS变换**。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));<br>   Continuation continuation = (Continuation)var4;<br>   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;<br>   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;<br>   Companion var10 = Result.Companion;<br>   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;<br>   continuation.resumeWith(Result.constructor-impl(var8));<br>   Object var10000 = var4.getOrThrow();<br>   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>      DebugProbesKt.probeCoroutineSuspended($completion);<br>   &#125;<br>   <span class="hljs-keyword">return</span> var10000;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span><br>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;<br>        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;<br>        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span><br>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception<br>        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    <span class="hljs-keyword">val</span> deferred = async &#123;<br>        <span class="hljs-comment">// 发起了一个网络请求</span><br>        ......<br>    &#125;<br>    <span class="hljs-comment">// 做了一些操作</span><br>    ......<br>    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span><br>    <span class="hljs-comment">// 后续的一些操作</span><br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br></code></pre></div></td></tr></table></figure><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span><br>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span><br></code></pre></div></td></tr></table></figure><p>我们来看下协程上下文中的元素类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element<br></code></pre></div></td></tr></table></figure><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :<br>    AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)<br>coroutineContext += CoroutineExceptionHandler&#123;<br>    <span class="hljs-comment">//  ... ...</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        println(context[CoroutineName]?.name)<br>        result.onFailure &#123;<br>            context[CoroutineExceptionHandler]?.onError(it)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :<br>    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br></code></pre></div></td></tr></table></figure><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));<br></code></pre></div></td></tr></table></figure><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
