<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解JVM（六）——字节码进阶</title>
    <link href="/2021/04/28/d39e151e/"/>
    <url>/2021/04/28/d39e151e/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章熟悉了字节码的基础指令之后，一些以往难懂的、被编译器隐藏的“黑盒子”知识点就可以尝试通过字节码去分析了。下面尝试分析 Java 8 中 Lambda 表达式与 Kotlin 中 Lambda 表达式的区别、JDK 5 中引入的泛型以及 Kotlin 协程的原理来加深对 Java 、Kotlin 语言的理解。</p><h2 id="Lambda表达式原理"><a href="#Lambda表达式原理" class="headerlink" title="Lambda表达式原理"></a>Lambda表达式原理</h2><p>Java 在 1.8 版本中引用了一个重要特性——Lambda表达式。该特性允许我们将 符合 <strong>SAM（Single Abstract Method）</strong>格式的接口转换为更优雅的 Lambda 表达式，同时也支持在打码中直接使用 Lambda 表达式来替代以往的 SAM 接口。</p><p>同样的，Kotlin在创作中就明确了会支持<strong>函数式编程（Functional Programming）</strong>，同时也对 Lambda 表达式的支持更加灵活，下面就来对比一下这两种语言中对于 Lambda表达式 的实现有何异同。</p><h3 id="Java-中的-Lambda"><a href="#Java-中的-Lambda" class="headerlink" title="Java 中的 Lambda"></a>Java 中的 Lambda</h3><p>Java 8 中只允许将 SAM 接口转换为 Lambda 表达式，例如 Runnable：</p><p><img src="/img/jvm/image-20210426205953036.png" alt="SAM转换为Lambda"></p><p>对于左边的情况相信大家已经熟悉了，javac 会将匿名内部类编译为一个单独的class文件，并且名字也是由规律的：OuterClassName$n。例如该例中会生成一个名为 JavaLambda$1.class 的文件。</p><p>而右边采用了JDK 8 中的新特性 Lambda 表达式，直觉告诉我们跟匿名内部类肯定不会是一回事。观察字节码实际上生成了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>       0: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;<br>       <span class="hljs-number">5</span>: astore_1<br>       <span class="hljs-number">6</span>: aload_1<br>       7: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V<br>      <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>                <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>  descriptor: ()V<br>  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: ldc           #5                  // String 123<br>       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>在上一章详细讨论了 invokedynamic 指令，来看看常量池第 2 项：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Constant pool:<br>   #1 = Methodref          #8.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = InvokeDynamic      #0:#30         // #0:run:()Ljava/lang/Runnable;<br>   ··· ···<br>   #30 = NameAndType        #42:#43        // run:()Ljava/lang/Runnable;<br></code></pre></div></td></tr></table></figure><p>#0是一个特殊查找，指向 BootstrapMethods 中第0行：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BootstrapMethods:<br>  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;<br>    Method arguments:<br>      #28 ()V<br>      #29 invokestatic JavaLambda.lambda$main$0:()V<br>      #28 ()V<br></code></pre></div></td></tr></table></figure><p>可以看到这是对静态方法 LambdaMetaFactory.metafactory() 的调用，这个类定义在 rt.jar 包中，方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title">metafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   String invokedName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType invokedType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType samMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodHandle implMethod,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType instantiatedMethodType)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> LambdaConversionException </span><br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li>caller：MethodHandles.Lookup对象，即 JVM 提供的查找上下文。</li><li>invokedName：调用函数名，本例中为“run”。</li><li>samMethodType：SAM 函数方法签名，本例中为“()void”。</li><li>implMethod：SAM 函数的具体实现方法，即我们编写在 lambda 表达式中，本例中为 invokestatic JavaLambda.lambda$main$0:()V。</li><li>instantiatedMethodType：一般和 samMethodType 相同，或是特例，本例中为“()void”。</li></ul><p>metafactory 方法是整个 Lambda 表达式实现最核心和最复杂的地方。它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">mf = <span class="hljs-keyword">new</span> InnerClassLambdaMetafactory(caller, invokedType,<br>                                     invokedName, samMethodType,<br>                                     implMethod, instantiatedMethodType,<br>                                     <span class="hljs-keyword">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);<br>mf.validateMetafactoryArgs();<br><span class="hljs-keyword">return</span> mf.buildCallSite();<br></code></pre></div></td></tr></table></figure><p>InnerClassLambdaMetafactory 中使用 ASM 技术动态生成字节码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClassLambdaMetafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType invokedType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   String samMethodName,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType samMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodHandle implMethod,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType instantiatedMethodType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-keyword">boolean</span> isSerializable,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   Class&lt;?&gt;[] markerInterfaces,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   MethodType[] additionalBridges)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> LambdaConversionException </span>&#123;<br>    <span class="hljs-keyword">super</span>(caller, invokedType, samMethodName, samMethodType,<br>          implMethod, instantiatedMethodType,<br>          isSerializable, markerInterfaces, additionalBridges);<br>    implMethodClassName = implDefiningClass.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    implMethodName = implInfo.getName();<br>    implMethodDesc = implMethodType.toMethodDescriptorString();<br>    implMethodReturnClass = (implKind == MethodHandleInfo.REF_newInvokeSpecial)<br>            ? implDefiningClass<br>            : implMethodType.returnType();<br>    <span class="hljs-comment">// 返回值类型</span><br>    constructorType = invokedType.changeReturnType(Void.TYPE);<br>    <span class="hljs-comment">// 生成类的类名</span><br>    lambdaClassName = targetClass.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&quot;$$Lambda$&quot;</span> + counter.incrementAndGet();<br>    cw = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);<br>    <span class="hljs-keyword">int</span> parameterCount = invokedType.parameterCount();<br>    <span class="hljs-keyword">if</span> (parameterCount &gt; <span class="hljs-number">0</span>) &#123;<br>        argNames = <span class="hljs-keyword">new</span> String[parameterCount];<br>        argDescs = <span class="hljs-keyword">new</span> String[parameterCount];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterCount; i++) &#123;<br>            argNames[i] = <span class="hljs-string">&quot;arg$&quot;</span> + (i + <span class="hljs-number">1</span>);<br>            argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        argNames = argDescs = EMPTY_STRING_ARRAY;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可看到这里将生成类的类名定为：OutterClassName$$Lambda$n ，具体生成类的实现我们可以通过 java -Djdk.internal.lambda.dumpProxyClasses JavaLambda 来运行 JavaLambda 类，会发现其在运行期间生成了一个新的类，将其反编译后会发现其实现了 Runnable 接口，并且实现了run方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaLambda</span>$$<span class="hljs-title">Lambda</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Runnable</span></span><br><span class="hljs-class">  </span><br><span class="hljs-class">  <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">run</span>()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">0</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: invokestatic  #17                 // Method JavaLambda.lambda$main$0:()V<br>         <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>run 方法中调用了 JavaLambda.lambda$main$0 方法，从而执行了我们定义在Lambda表达式中的逻辑。</p><p>总结一下 Java 中的 Lambda表达式：</p><ol><li>Lambda 表达式声明的地方会生成一个 invokedynamic 指令，同时编译器生成一个对应的引导方法（Bootstrap Method）。</li><li>第一次执行 invokedynamic 指令时，会调用对应的引导方法，该引导方法会调用 LambdaMetafactory.metafactory 方法动态生成内部类。</li><li>引导方法会返回一个动态调用 CallSite 对象，这个CallSite 最终调用实现了 Runnable接口的内部类。</li><li>Lambda 表达式中的代码会被编译成静态方法，动态生成的内部类会直接调用该静态方法。</li><li>真正执行 lambda 调动的还是 invokeinterface 指令。</li></ol><h3 id="Kotlin-中的-Lambda"><a href="#Kotlin-中的-Lambda" class="headerlink" title="Kotlin 中的 Lambda"></a><strong>Kotlin 中的 Lambda</strong></h3><p>Kotlin 中的 Lambda表达式就比 Java 8 中的要强大得多了，几乎可以在任何地方使用 Lambda 表达式，下面同样来看一例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> sum = &#123; a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span> -&gt;<br>        a + b<br>    &#125;<br>    println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 javac 编译后生成了两个文件：</p><p><img src="/img/jvm/image-20210426221656230.png" alt="KotlinLambda"></p><p>根据命名猜测到正是 Lambda 表达式生成的内部类，其命名规律为：<strong>OuterClassName$OuterFunctionName$LambdaExpressionName$n</strong>。先将其反编译，发现这个内部类继承自 kotlin.jvm.internal.Lambda，并且实现了 kotlin.jvm.functions.Function2 接口。</p><p>kotlin.jvm.internal.Lambda 类是 Kotlin 中所有 Lambda 表达式的抽象父类，其实现很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span>&lt;<span class="hljs-type">out R</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> arity: <span class="hljs-built_in">Int</span>) : FunctionBase&lt;R&gt;, Serializable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = Reflection.renderLambdaToString(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>熟悉 Kotlin 的话就知道 FunctionN 这类接口是 Kotlin 用于实现函数式编程而表示函数类型的接口，其签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function2</span>&lt;<span class="hljs-type">in P1, in P2, out R</span>&gt; : <span class="hljs-type">Function</span>&lt;<span class="hljs-type">R</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/** Invokes the function with the specified arguments. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(p1: <span class="hljs-type">P1</span>, p2: <span class="hljs-type">P2</span>)</span></span>: R<br>&#125;<br></code></pre></div></td></tr></table></figure><p>知道了这个内部类是 Function2 类型的话，那么具体实现只需要看 invoke 函数就行了：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(java.lang.Object, java.lang.Object)</span></span>;<br>  descriptor: (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;<br>  flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: aload_1<br>       2: checkcast     #11                 // class java/lang/Number<br>       5: invokevirtual #15                 // Method java/lang/Number.intValue:()I<br>       <span class="hljs-number">8</span>: aload_2<br>       9: checkcast     #11                 // class java/lang/Number<br>      12: invokevirtual #15                 // Method java/lang/Number.intValue:()I<br>      15: invokevirtual #18                 // Method invoke:(II)I<br>      18: invokestatic  #24                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-number">21</span>: areturn<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br>  descriptor: (II)I<br>  flags: ACC_PUBLIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>       <span class="hljs-number">0</span>: iload_1<br>       <span class="hljs-number">1</span>: iload_2<br>       <span class="hljs-number">2</span>: iadd<br>       <span class="hljs-number">3</span>: ireturn<br></code></pre></div></td></tr></table></figure><p>可以看到这两个 invoke 方法就是我们的 Lambda 表达式内部的内容了，将两个整型相加。那么是如何调用的呢，回过头来看 KotlinLambdaKt.class 的内容。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>       0: getstatic     #15                 // Field KotlinLambdaKt$main$sum$1.INSTANCE:LKotlinLambdaKt$main$sum$1;<br>       3: checkcast     #17                 // class kotlin/jvm/functions/Function2<br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: iconst_1<br>       9: invokestatic  #23                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-number">12</span>: iconst_2<br>      13: invokestatic  #23                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      16: invokeinterface #27,  3           // InterfaceMethod kotlin/jvm/functions/Function2.invoke:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;<br>      21: checkcast     #29                 // class java/lang/Number<br>      24: invokevirtual #33                 // Method java/lang/Number.intValue:()I<br>      <span class="hljs-number">27</span>: istore_1<br>      <span class="hljs-number">28</span>: iconst_0<br>      <span class="hljs-number">29</span>: istore_2<br>      30: getstatic     #39                 // Field java/lang/System.out:Ljava/io/PrintStream;<br>      <span class="hljs-number">33</span>: iload_1<br>      34: invokevirtual #45                 // Method java/io/PrintStream.println:(I)V<br>      <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>main 方法首先获取了 KotlinLambdaKt$main$sum$1 的静态单例，接着同样使用 invokeinterface 指令来执行 接口Function2中的invoke 方法，执行 Lambda 表达式内部的操作。</p><p>可以看到 Kotlin 的 Lambda 表达式实现还是比较简单的，它采用了内部类的方式来代理 Lambda 表达式的内容，而 Java 8 则是利用了 invokedynamic 指令，通过 LambdaMetaFactory 来处理，这样做的好处是整个调用流程通过 LambdaMetaFactory 来完成，整个方法分派的流程从编译器转移到了运行时，后续只需调整 LambdaMetaFactory 里面的代码即可改变现有实现。</p><h2 id="泛型与字节码"><a href="#泛型与字节码" class="headerlink" title="泛型与字节码"></a>泛型与字节码</h2><h3 id="Java-中的泛型"><a href="#Java-中的泛型" class="headerlink" title="Java 中的泛型"></a>Java 中的泛型</h3><p>Java 在 JDK 1.5 时引入了<strong>泛型（Generic Type）</strong>的概念，泛型存在使得我们可以更好的使用集合框架，避免了很多强制的类型转换，并且将很多错误暴露在了编译阶段。不过老鸟都知道 Java 为了兼容 1.5 之前的 JDK 版本，并没有真正引入泛型类型，而是采用一种叫<strong>类型擦除</strong>的机制，在编译时将泛型相关的全部擦除为基本类型。例如 List&lt;String&gt; 编译后会被擦除为 List 类型，这也导致了一些问题，例如无法使用泛型类型来做方法重载：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;Integer&gt; list)</span></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当这样编写代码时会编译报错，提示 ”’print(List&lt;String&gt;)’ clashes with ‘print(List&lt;Integer&gt;)’; both methods have same erasure“，两个方法编译后的字节码也是一模一样的。</p><p>除此之外，泛型还有无法实例化、无法判断泛型类型等缺点，如下面代码所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">genericMethod</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-comment">// 无法创建对象</span><br>    T newInstance = <span class="hljs-keyword">new</span> T();<br>    <span class="hljs-comment">// 无法创建数组类型</span><br>    T[] array = <span class="hljs-keyword">new</span> T[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 无法获得Class对象</span><br>    Class c = T.class;<br>    List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 无法使用instanceof判断类型</span><br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过如果没有泛型的话，我们操作集合类就比较麻烦了，例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List strings = <span class="hljs-keyword">new</span> ArrayList();<br>strings.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>String value = (String) strings.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><p>每次从 strings 中获取元素都需要显式的强转为 String 类型才能正常使用，如果使用泛型的话就不需要了，不过虚拟机还是会帮我们进行类型的转换：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>strings.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>String value = strings.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 字节码中依然需要强转</span><br>INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object; (itf)<br>CHECKCAST java/lang/String<br></code></pre></div></td></tr></table></figure><h3 id="字节码中留存的泛型信息"><a href="#字节码中留存的泛型信息" class="headerlink" title="字节码中留存的泛型信息"></a>字节码中留存的泛型信息</h3><p>Javac 虽然会在编译时将所有泛型类型擦除，但是它依然在字节码中保留了一些关于泛型的信息，以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Map&lt;String, Integer&gt;&gt; getValue() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 javap 查看 SubClass 的字节码，发现 getValue 方法相比普通无泛型方法多了一条 Signature 信息，而 Signature 中指向的常量池信息刚好是我们的泛型实际类型：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.util.List&lt;java.util.Map&lt;java.lang.String, java.lang.Integer&gt;&gt; getValue();<br>  descriptor: ()Ljava/util/List;<br>  flags: ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aconst_null<br>       <span class="hljs-number">1</span>: areturn<br>    LineNumberTable:<br>      line <span class="hljs-number">11</span>: <span class="hljs-number">0</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/sukaidev/fuckingaosp/SubClass;<br>  Signature: #14                          // ()Ljava/util/List&lt;Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/Integer;&gt;;&gt;;<br></code></pre></div></td></tr></table></figure><p>Signature 指向常量池14号表项，值为  ()Ljava/util/List&lt;Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/Integer;&gt;;&gt;;。同样的，整个 Class 文件也存在一个 Signature：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Signature: #15                          // Lcom/sukaidev/fuckingaosp/SuperClass&lt;Ljava/lang/String;&gt;;<br></code></pre></div></td></tr></table></figure><p>指向了常量池15号表项，内容为带泛型的父类实际类型。</p><p>现在我们知道字节码中通过附加的签名信息保留的泛型的实际类型，那么在运行时去获取泛型的实际类型就存在理论上的可能了。不过有一点要注意的是，签名可能会被混淆，注意keep住：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">-keepattributes Signature<br>-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">Metadata</span> </span>&#123;*;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="运行时获取泛型实际类型"><a href="#运行时获取泛型实际类型" class="headerlink" title="运行时获取泛型实际类型"></a>运行时获取泛型实际类型</h3><blockquote><p>注意！！！：以下分析是基于 Android SDK 30，源码可能会与主流 JDK（Oracle、OpenJDK等）中有所出入，例如 Class 类中获取泛型签名的方法名就不同，不过原理是一样的。</p></blockquote><p>如果经常使用 Gson 来作为序列化/反序列化 Json 工具的话，一定经常使用这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Type type = <span class="hljs-keyword">new</span> TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType();<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> Gson().fromJson(json, type);<br></code></pre></div></td></tr></table></figure><p>Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。如果将 type 打印的话，会发现它是我们传入 TypeToken 中的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.List&lt;? extends java.lang.String&gt;<br></code></pre></div></td></tr></table></figure><p>那么为何通过 TypeToken 可以拿到这个泛型类型呢？看看 TypeToken 的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">TypeToken</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 获取超类泛型实际类型</span><br>  <span class="hljs-keyword">this</span>.type = getSuperclassTypeParameter(getClass());<br>  <span class="hljs-keyword">this</span>.rawType = (Class&lt;? <span class="hljs-keyword">super</span> T&gt;) $Gson$Types.getRawType(type);<br>  <span class="hljs-keyword">this</span>.hashCode = type.hashCode();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>TypeToken 通过 getSuperclassTypeParameter 方法来获取父类的泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> Type <span class="hljs-title">getSuperclassTypeParameter</span><span class="hljs-params">(Class&lt;?&gt; subclass)</span> </span>&#123;<br>  <span class="hljs-comment">// 获取父类泛型类型</span><br>  Type superclass = subclass.getGenericSuperclass();<br>  <span class="hljs-keyword">if</span> (superclass <span class="hljs-keyword">instanceof</span> Class) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing type parameter.&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 强转为参数化类型，即泛型</span><br>  ParameterizedType parameterized = (ParameterizedType) superclass;<br>  <span class="hljs-comment">// 返回第一个泛型实际类型</span><br>  <span class="hljs-keyword">return</span> $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>重点在 getGenericSuperclass 方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getGenericSuperclass</span><span class="hljs-params">()</span> </span>&#123;<br>  Type genericSuperclass = getSuperclass();<br>  <span class="hljs-comment">// 没有父类的话直接返回null，例如基本类型，接口，void，和Object</span><br>  <span class="hljs-keyword">if</span> (genericSuperclass == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// getSignatureAttribute是个native方法，用于获取泛型签名</span><br>  String annotationSignature = getSignatureAttribute();<br>  <span class="hljs-keyword">if</span> (annotationSignature != <span class="hljs-keyword">null</span>) &#123;<br>      GenericSignatureParser parser = <span class="hljs-keyword">new</span> GenericSignatureParser(getClassLoader());<br>      parser.parseForClass(<span class="hljs-keyword">this</span>, annotationSignature);<br>      genericSuperclass = parser.superclassType;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Types.getType(genericSuperclass);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>getSignatureAttribute 是个 Native 方法最终通过 GenericSignatureParser 解析泛型签名而得到我们传给父类的泛型实际类型。</p><p>我们可以总结一下如何获取父类的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ParameterizedType genericType = (ParameterizedType) SubClass.class.getGenericSuperclass();<br>System.out.println(genericType.getActualTypeArguments()[<span class="hljs-number">0</span>].getTypeName());<br><br><span class="hljs-comment">// 控制台输出</span><br>java.lang.String<br></code></pre></div></td></tr></table></figure><p>同样我们也可以获取方法中的泛型实际类型：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ParameterizedType methodType = (ParameterizedType) SubClass.class.getMethod(<span class="hljs-string">&quot;getValue&quot;</span>).getGenericReturnType();<br>    System.out.println(methodType.getActualTypeArguments()[<span class="hljs-number">0</span>].getTypeName());<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>java.util.Map&lt;java.lang.String, java.lang.Integer&gt;<br></code></pre></div></td></tr></table></figure><h3 id="Kotlin-中的泛型特化"><a href="#Kotlin-中的泛型特化" class="headerlink" title="Kotlin 中的泛型特化"></a>Kotlin 中的泛型特化</h3><p>Kotlin 作为一种 JVM 语言，其泛型同样会进行类型擦除。不过 Kotlin 中提供了一个关键字：<strong>reified</strong>，在内联函数中使用该关键字可以实现 Java 中实现不了的效果，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reifiedGeneric(<span class="hljs-string">&quot;hello kotlin.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">reifiedGeneric</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 可以获取Class对象，反射创建对象</span><br>    <span class="hljs-keyword">val</span> newInstance = T::<span class="hljs-keyword">class</span>.java.newInstance()<br>    <span class="hljs-comment">// 可以创建数组</span><br>    <span class="hljs-keyword">val</span> arrayOfT = arrayOf&lt;T&gt;()<br>    <span class="hljs-keyword">val</span> list = ArrayList&lt;T&gt;()<br>    <span class="hljs-comment">// 依然无法使用instanceof判断类型，编译报红</span><br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">is</span> List&lt;String&gt;)&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>反编译后 main 方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">0</span><br>       0: ldc           #11                 // String hello kotlin.<br>       <span class="hljs-number">2</span>: astore_0<br>       <span class="hljs-number">3</span>: iconst_0<br>       <span class="hljs-number">4</span>: istore_1<br>       5: ldc           #13                 // class java/lang/String<br>       7: invokevirtual #19                 // Method java/lang/Class.newInstance:()Ljava/lang/Object;<br>      <span class="hljs-number">10</span>: astore_2<br>      <span class="hljs-number">11</span>: iconst_0<br>      12: anewarray     #13                 // class java/lang/String<br>      <span class="hljs-number">15</span>: astore_3<br>      <span class="hljs-number">16</span>: nop<br>      <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>原本 main 方法应该直接调用 reifiedGeneric 方法才对，但实际上编译后 reifiedGeneric 方法中的代码完全被编译进了 main 方法内，这其实就是 <strong>inline（内联）</strong>的含义。</p><p>内联方法通过 kotlinc 编译器内联到调用处，其字节码完全合并到调用处中，这也是 kotlin 泛型特化能够实现的原因。内联函数的泛型在编译期编译器就可以通过上下文推导出其实际类型，因此可以获取其 Class 对象，也能进行实例化。</p><h2 id="从字节码角度理解协程"><a href="#从字节码角度理解协程" class="headerlink" title="从字节码角度理解协程"></a>从字节码角度理解协程</h2><p>之前的协程实现分析中没有采用字节码来分析，原因一是当时对字节码不是很熟悉，二是不好用一个更难的概念来解释一个没那么难的概念。我们知道协程的关键实现都是由 kotlinc 即编译器来完成，而 IDE 反编译的代码阅读性很差，那么现在学习了字节码之后就可以通过 javap 来一探究竟了。</p><h3 id="suspend-fuction"><a href="#suspend-fuction" class="headerlink" title="suspend fuction"></a>suspend fuction</h3><p>kotlin协程的”黑魔法“基础是 suspend 关键字，先来这个方法看看背后做了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestUserToken</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>  = <span class="hljs-string">&quot;faketoken&quot;</span><br></code></pre></div></td></tr></table></figure><p>requestUserToken 方法虽然声明为 suspend，但并没有发生<strong>”事实上的挂起“</strong>，使用 javap 编译后字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">requestUserToken</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, kotlin.coroutines.Continuation&lt;? <span class="hljs-keyword">super</span> java.lang.String&gt;)</span></span>;<br>  descriptor: (ILkotlin/coroutines/Continuation;)Ljava/lang/Object;<br>  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>       0: ldc           #11                 // String faketoken<br>       <span class="hljs-number">2</span>: areturn<br></code></pre></div></td></tr></table></figure><p>可以看到 requestUserToken 方法的实现并没有什么特殊，但是我们只定义了一个 int 型参数，而方法签名中多了一个参数，为Continuation类型，显然这就是编译器为 suspend function 添加的一个额外参数。至于这个 Continuation 对象的作用我们后面再说。</p><h3 id="suspend-main"><a href="#suspend-main" class="headerlink" title="suspend main"></a>suspend main</h3><p>在<a href="https://sukaidev.github.io/2021/02/01/595755ca/#%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84main%E5%87%BD%E6%95%B0">《深入理解Kotlin协程（一）——基本概念与原理》</a>一文中我们简单分析了可挂起的 main 函数的实现方式，下面就通过字节码来验证文中的分析过程。</p><p>以下面代码为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;suspend main.&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译后生成两个 class 文件，分别为 CoroutineTestKt.class 和 CoroutineTestKt$$$main.class。先来看看编译生成的 CoroutineTestKt$$$main.class 文件，这 class 文件的名字第一眼看过去觉得毫无头绪，为什么会有 3 个 $ 符号呢？</p><p>在第一节我们讲过 Kotlin 中 Lambda 表达式的原理，其中说到了 kotlinc 生成的 实现 Lambda 表达式的类的命名规则为：<strong>OuterClassName$OuterFunctionName$LambdaExpressionName$n</strong>。我们把本例的 suspend man 方法带入会发现恰好符合这个规则。</p><p>我们猜到了 CoroutineTestKt$$$main 实际由 Lambda 表达式生成，继续来看 CoroutineTestKt$$$main.class 的字节码，发现该类确实继承自 Lambda 类，并且实现了 Function1接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">coroutine</span>.<span class="hljs-title">CoroutineTestKt</span>$$$<span class="hljs-title">main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">internal</span>.<span class="hljs-title">Lambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">kotlin</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">functions</span>.<span class="hljs-title">Function1</span></span><br></code></pre></div></td></tr></table></figure><p>虽然验证了我们的猜想，但实际上我们并没有编写任何 Lambda 表达式，这显然编译器对 <strong>suspend main</strong> 做的特殊处理。既然实现了 Function1 接口，那么就来看下 invoke 方法是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(java.lang.Object)</span></span>;<br>    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;<br>    flags: ACC_PUBLIC, ACC_FINAL, ACC_SYNTHETIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: aload_1<br>         1: checkcast     #19                 // class kotlin/coroutines/Continuation<br>         4: invokestatic  #25                 // Method coroutine/CoroutineTestKt.main:(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;<br>         <span class="hljs-number">7</span>: areturn<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第 0~1 行将参数中加载到栈中并强转为 <strong>Continuation</strong> 类型，然后调用了 CoroutineTestKt.main 方法将 Continuation 对象传入。</p><p>这里需要注意的是，invoke 方法携带一个 Continuation 类型的参数，跟我们上一节讨论的被 <strong>suspend</strong> 关键字修饰的方法是相同的，那么它也能作为一个挂起函数来使用。</p><p>CoroutineTestKt$$$main 中的字节码就只有 invoke 一个方法了，接下来就要去 CoroutineTestKt 中寻找哪个地方调用了 <strong>CoroutineTestKt$$$main.invoke</strong>。先来看 Java 入口 main 方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: new           #10                 // class coroutine/CoroutineTestKt$$$main<br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: aload_0<br>         5: invokespecial #13                 // Method coroutine/CoroutineTestKt$$$main.&quot;&lt;init&gt;&quot;:([Ljava/lang/String;)V<br>         8: invokestatic  #19                 // Method kotlin/coroutines/jvm/internal/RunSuspendKt.runSuspend:(Lkotlin/jvm/functions/Function1;)V<br>        <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>main 方法中创建了 CoroutineTestKt$$$main 对象并且将其传给了 <strong>RunSuspendKt.runSuspend</strong> 方法，来看看这个方法做了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码已经很熟悉了，其实就是使用 suspend {} 代码块来启动一个协程，而这段协程的回调是 RunSuspend 对象，并且在启动协程后调用了 <strong>RunSuspend#await</strong> 方法。这个方法在<a href="https://sukaidev.github.io/2021/02/01/595755ca/#%E5%8F%AF%E6%8C%82%E8%B5%B7%E7%9A%84main%E5%87%BD%E6%95%B0">《深入理解Kotlin协程（一）——基本概念与原理》</a>一文中已经分析了，这里再贴出它的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">this</span>.result = result<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>                <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际上就是用 <strong>wait/notify</strong> 来控制虚拟机执行流程，等待协程运行完再退出。</p><p>而这个传进来的 suspend {} 代码块实际上就是 CoroutineTestKt.class 中的另一个 main 方法，这个方法包含了协程需要执行的所有代码，具体内容下节讨论。现在我们可以用伪代码来表示整个 suspend main 的被编译后的逻辑了：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 继承自 Continuation</span><br>    <span class="hljs-keyword">val</span> run = Runsuspend()<br>    <span class="hljs-comment">// suspend &#123;&#125; 被编译为 CoroutineTestKt$$$main</span><br>    <span class="hljs-keyword">suspend</span> main&#123;<br>        <span class="hljs-comment">// lambda体 被编译为CoroutineTestKt$$$main.class</span><br>        <span class="hljs-comment">// 此 main 方法由编译器额外生成</span><br>        CoroutineTestKt.main()<br>    &#125;.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="同步方式写异步代码的秘密"><a href="#同步方式写异步代码的秘密" class="headerlink" title="同步方式写异步代码的秘密"></a>同步方式写异步代码的秘密</h3><p>我们都知道 kotlin 协程可以以同步方式编写异步代码是 kotlinc 所做的”黑魔法“，但是具体是怎么做的，以及协程具体如何执行我们还是一概不知，而对协程 debug 也会经常出现代码与字节码不匹配的情况，因此要搞懂具体的原理还是要从字节码来入手。</p><p>先来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> token = requestUserToken(<span class="hljs-number">0</span>)<br>    println(<span class="hljs-string">&quot;user token is : <span class="hljs-variable">$token</span>&quot;</span>)<br>    <span class="hljs-keyword">val</span> userInfo = fetchUserInfo(token)<br>    println(<span class="hljs-string">&quot;user info is : <span class="hljs-variable">$userInfo</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestUserToken</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-string">&quot;faketoken&quot;</span><br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserInfo</span><span class="hljs-params">(token: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;UserInfo&gt; &#123;<br>    thread &#123;<br>        Thread.sleep(<span class="hljs-number">1000L</span>)<br>        it.resumeWith(Result.success(UserInfo(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>)))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码编译后生成了好几个 class 文件，如图所示：</p><p><img src="/Users/sukaidev/HexoBlog/source/img/jvm/image-20210430234107202.png" alt="生成Class文件"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kotlinlang.org/">Kotlin语言官方站</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bytecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（五）——字节码基础</title>
    <link href="/2021/04/18/b6905ec7/"/>
    <url>/2021/04/18/b6905ec7/</url>
    
    <content type="html"><![CDATA[<p>上篇文章中了解了虚拟机执行子系统中的栈和栈帧结构，并且学习了一些方法调用相关的字节码指令，对于方法的分派过程有了更深入的理解，接下来这篇文章来了解一下基础的字节码指令。</p><h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>字节码指令主要有<strong>加载和存储指令</strong>、<strong>操作数栈指令</strong>、<strong>运算和类型转换指令</strong>、<strong>控制转移指令</strong>等，这一部分是了解字节码的基础。</p><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p><strong>加载（load）</strong>和<strong>存储（store）</strong>相关的指令是使用得最频繁的指令，分为load类、store类、常量加载这三种。</p><ul><li>load类指令：将局部变量表中的变量加载到操作数栈，比如iload_0将局部变量表中下表为0的int型变量加载到操作数栈上，类似的还有lload、fload、dload、aload，分别表示加载局部变量表中long、float、double、引用类型的变量。</li><li>store类指令：将操作数栈栈顶的数据存储到局部变量表中，比如istore_0将操作数栈顶的元素存储到局部变量表中下表为0的位置，类似的还有lstore、fstore、dstore、astore这些指令。</li><li>常量加载相关的指令，常见的有const类、push类、ldc类。const、push类指令是将常数值直接加载到操作数栈顶，ldc指令是从常量池加载对应的常量到操作数栈顶。</li></ul><p>存储指令列表如下所示。</p><table><thead><tr><th align="center">指  令  名</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">aconst_null</td><td align="center">将null入栈到栈顶</td></tr><tr><td align="center">iconst_m1</td><td align="center">将int类型值-1压栈到栈顶</td></tr><tr><td align="center">iconst_&lt;n&gt;</td><td align="center">将int类型值n（0~5）压栈到栈顶</td></tr><tr><td align="center">lconst_&lt;n&gt;</td><td align="center">将long类型值n（0~1）压栈到栈顶</td></tr><tr><td align="center">fconst_&lt;n&gt;</td><td align="center">将float类型值n（0~2）压栈到栈顶</td></tr><tr><td align="center">dconst&lt;n&gt;</td><td align="center">将double类型值n（0~1）压栈到栈顶</td></tr><tr><td align="center">bipush</td><td align="center">将范围在-128~127的整型值压栈到栈顶</td></tr><tr><td align="center">sipush</td><td align="center">将范围在-32768~32767的整型值压栈到栈顶</td></tr><tr><td align="center">ldc</td><td align="center">将int、float、String类型的常量值从常量池压栈到栈顶</td></tr><tr><td align="center">ldc_w</td><td align="center">作用同ldc，不同的是ldc的操作码是一个字节，ldc_w的操作码是两个字节，即ldc只能寻址255个常量池的索引值，而ldc_w可以覆盖常量池所有的值</td></tr><tr><td align="center">ldc2_w</td><td align="center">将long或double类型的常量值从常量池压栈到栈顶</td></tr><tr><td align="center">&lt;T&gt;load</td><td align="center">将局部变量表中指定位置的int、long、float、double、引用类型、boolean、byte、char、short类型变量加载到栈上</td></tr><tr><td align="center">&lt;T&gt;load_&lt;n&gt;</td><td align="center">将局部变量表中下标为n（0~3）的变量加载到栈上，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;aload</td><td align="center">将指定数组中特定位置的数据加载到栈上，T可以为i、l、f、d、a、b、c、s</td></tr><tr><td align="center">&lt;T&gt;store</td><td align="center">将栈顶数据存储到局部变量表中的特定位置，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;store_&lt;n&gt;</td><td align="center">将栈顶变量数据存储到局部变量表中下标为n（0~3）的位置，T可以为i、l、f、d、a</td></tr><tr><td align="center">&lt;T&gt;astore</td><td align="center">将栈顶数据存储到数组的指定位置，T可以为i、l、f、d、a、b、c、s</td></tr></tbody></table><h3 id="操作数栈指令"><a href="#操作数栈指令" class="headerlink" title="操作数栈指令"></a>操作数栈指令</h3><p>常见的操作数栈指令有pop、dup和swap。pop指令用于将栈顶的值出栈，dup指令用来复制栈顶的元素并压入栈顶，swap用于交换栈顶的两个元素，如下图所示。</p><p><img src="/img/jvm/dup_pop_swap.png" alt="dup、pop、swap指令"></p><p>另外还有几个复杂一点的指令，如下操作数栈指令列表所示。</p><table><thead><tr><th align="center">指 令 名</th><th align="center">字 节 码</th><th align="center">描 述</th></tr></thead><tbody><tr><td align="center">pop</td><td align="center">0x57</td><td align="center">将栈顶数据（非long和double）出栈</td></tr><tr><td align="center">pop2</td><td align="center">0x58</td><td align="center">弹出栈顶一个long或double类型的数据或者两个其他类型的数据</td></tr><tr><td align="center">dup</td><td align="center">0x59</td><td align="center">复制栈顶数据并将复制的数据入栈</td></tr><tr><td align="center">dup_x1</td><td align="center">0x5A</td><td align="center">复制栈顶数据并将复制的数据插入到栈顶第二个元素之下</td></tr><tr><td align="center">dup_x2</td><td align="center">0x5B</td><td align="center">复制栈顶数据并将复制的数据插入到栈顶第三个元素之下</td></tr><tr><td align="center">dup2</td><td align="center">0x5C</td><td align="center">复制栈顶两个数据并将复制的数据入栈</td></tr><tr><td align="center">dup2_x1</td><td align="center">0x5D</td><td align="center">复制栈顶两个数据并将复制的数据插入到栈第二个元素之下</td></tr><tr><td align="center">dup2_x2</td><td align="center">0x5E</td><td align="center">复制栈顶两个数据并将复制的数据插入到栈第三个元素之下</td></tr><tr><td align="center">swap</td><td align="center">0x5F</td><td align="center">交换栈顶两个元素</td></tr></tbody></table><h3 id="运算和类型转换指令"><a href="#运算和类型转换指令" class="headerlink" title="运算和类型转换指令"></a>运算和类型转换指令</h3><p>针对Java中的加减乘除相关语法，字节码也有对应的运算指令，如下表示所示。</p><table><thead><tr><th align="center">运算符</th><th align="center">int</th><th align="center">long</th><th align="center">float</th><th align="center">double</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">iadd</td><td align="center">ladd</td><td align="center">fadd</td><td align="center">dadd</td></tr><tr><td align="center">-</td><td align="center">isub</td><td align="center">lsub</td><td align="center">fsub</td><td align="center">dsub</td></tr><tr><td align="center">/</td><td align="center">idiv</td><td align="center">ldiv</td><td align="center">fdiv</td><td align="center">ddiv</td></tr><tr><td align="center">*</td><td align="center">imul</td><td align="center">lmul</td><td align="center">fmul</td><td align="center">dmul</td></tr><tr><td align="center">%</td><td align="center">irem</td><td align="center">lrem</td><td align="center">frem</td><td align="center">drem</td></tr><tr><td align="center">negate(-)</td><td align="center">ineg</td><td align="center">lneg</td><td align="center">fneg</td><td align="center">dneg</td></tr><tr><td align="center">&amp;</td><td align="center">iand</td><td align="center">land</td><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">|</td><td align="center">ior</td><td align="center">lor</td><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">^</td><td align="center">ixor</td><td align="center">lxor</td><td align="center">–</td><td align="center">–</td></tr></tbody></table><p>这里需要注意的是，如果需要进行运算的数据类型不一样，会涉及到类型转换（cast），例如1.0 + 1 对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">fconst_1 <span class="hljs-comment">// 将1.0入栈</span><br>iconst_1 <span class="hljs-comment">// 将1入栈</span><br>fadd  <span class="hljs-comment">// 栈顶两个元素相加</span><br></code></pre></div></td></tr></table></figure><p>这里fadd指令只支持对两个float类型的数据做相加操作，为了支持这种运算，JVM会先把int类型的数据转为float类型然后再相加，这种类型转换称为<strong>宽化类型转换（widening）</strong>。</p><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>控制转移指令用于有条件和无条件的分支跳转，常见的if-then-else、三目表达式、for循环、异常处理等都属于这个范畴。对应的指令集包括：</p><ul><li>条件转移：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。</li><li>复合条件转移：tableswitch、lookupswitch。</li><li>无条件转移：goto、goto_w、jsr、jsr_w、ret。</li></ul><p>以下面代码为例来分析字节码，它的作用是判断一个整数是否为整数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对应的字节码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>: iload_1  <span class="hljs-comment">// 将局部变量表中下标为1的int变量加载到操作数栈上</span><br><span class="hljs-number">1</span>: ifle <span class="hljs-number">6</span>   <span class="hljs-comment">// 将操作数栈顶元素出栈与0比较，如果小于等于0则跳转到字节码第六行</span><br><span class="hljs-number">4</span>: iconst_1 <span class="hljs-comment">// 4~5行对应代码”return 1“，这里先将常量1压到栈顶</span><br><span class="hljs-number">5</span>: ireturn  <span class="hljs-comment">// 将栈顶整数1出栈并返回</span><br><span class="hljs-number">6</span>: iconst_0  <span class="hljs-comment">// 将常量0压入栈顶</span><br><span class="hljs-number">7</span>: ireturn  <span class="hljs-comment">// 将栈顶整数0出栈返回</span><br></code></pre></div></td></tr></table></figure><p>假设n等于20，调用isPositive(20)方法操作数栈的变化情况如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_ispositive.png" alt="isPositive(/img/jvm/jvm_bytecode_ispositive.png)操作数栈变化">所所有控制转移指令如下表所示。</p><table><thead><tr><th align="center">指 令 名</th><th align="center">字 节 码</th><th align="center">描 述</th></tr></thead><tbody><tr><td align="center">ifeq</td><td align="center">0x99</td><td align="center">如果栈顶int型变量等于0，则跳转</td></tr><tr><td align="center">ifne</td><td align="center">0x9A</td><td align="center">如果栈顶int型变量不等于0，则跳转</td></tr><tr><td align="center">iflt</td><td align="center">0x9B</td><td align="center">如果栈顶int型变量小于0，则跳转</td></tr><tr><td align="center">ifge</td><td align="center">0x9C</td><td align="center">如果栈顶int型变量大于等于0，则跳转</td></tr><tr><td align="center">ifgt</td><td align="center">0x9D</td><td align="center">如果栈顶int型变量大于0，则跳转</td></tr><tr><td align="center">ifle</td><td align="center">0x9E</td><td align="center">如果栈顶int型变量小于等于0，则跳转</td></tr><tr><td align="center">if_icmpeq</td><td align="center">0x9F</td><td align="center">比较栈顶两个int型变量，如果相等则跳转</td></tr><tr><td align="center">if_icmpne</td><td align="center">0xA0</td><td align="center">比较栈顶两个int型变量，如果不相等则跳转</td></tr><tr><td align="center">if_icmplt</td><td align="center">0xA1</td><td align="center">比较栈顶两个int型变量，如果小于则跳转</td></tr><tr><td align="center">if_icmpge</td><td align="center">0xA2</td><td align="center">比较栈顶两个int型变量，如果大于等于则跳转</td></tr><tr><td align="center">if_icmpgt</td><td align="center">0xA3</td><td align="center">比较栈顶两个int型变量，如果大于则跳转</td></tr><tr><td align="center">if_icmple</td><td align="center">0xA4</td><td align="center">比较栈顶两个int型变量，如果小于等于则跳转</td></tr><tr><td align="center">if_acmpeq</td><td align="center">0xA5</td><td align="center">比较栈顶两个引用类型变量，如果相等则跳转</td></tr><tr><td align="center">if_acmpne</td><td align="center">0xA6</td><td align="center">比较栈顶两个引用类型变量，如果不相等则跳转</td></tr><tr><td align="center">goto</td><td align="center">0xA7</td><td align="center">无条件跳转</td></tr><tr><td align="center">tableswitch</td><td align="center">0xAA</td><td align="center">switch条件跳转，case值紧凑的情况下使用</td></tr><tr><td align="center">lookupswitch</td><td align="center">0xAB</td><td align="center">switch条件跳转，case值稀疏的情况下使用</td></tr></tbody></table><h3 id="for语句的字节码原理"><a href="#for语句的字节码原理" class="headerlink" title="for语句的字节码原理"></a>for语句的字节码原理</h3><p>下面通过分析一段for循环代码来理解上述字节码指令。</p><p>纵观所有的字节码指令，并没有与for名字相关的指令，那么for循环的实现原理是怎样的呢？</p><p>以下列为例，看看JVM是如何处理高级for循环的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : numbers) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同样的，使用 javac -p 命令编译后，通过javap -c -v -l 来查看字节码：</p><p><img src="/img/jvm/jvm_bytecode_sum.png" alt="sum方法字节码"></p><p>为了方便理解，我们可以把局部变量表画出来，如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_sum_op.png" alt="sum方法局部变量表"></p><p>下面以执行sum(new int[]{0,20,30});为例来逐行分析字节码执行过程。</p><p>第0~1行：把常量0加载到操作数栈上，随后通过istore_2指令将0出栈赋值给局部变量表中下标为2的元素，就是将sum赋值为0。此时的局部变量表和操作数栈如下图所示。</p><p><img src="/img/jvm/image-20210410104512311.png" alt="for循环执行细节（1）"></p><p>第2~9行：初始化循环控制变量，可以使用如下伪代码表示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">$array = numbers;<br>$len = $array.arraylength<br>$i = <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>第2~3行：aload_1指令的作用是加载局部变量表中下标为1的变量（参数numbers），astore_3指令的作用是将栈顶元素存储到局部变量表下标为3的位置上，这里记为$array，如下图所示。</p><p><img src="/img/jvm/image-20210410111449022.png" alt="for循环执行细节（2）"></p><p>第4~6行：计算数据的长度，astore_3加载$array到栈顶，调用arrayLength指令获取数组长度存储到栈顶，随后调用istore 4将数组长度存储到局部变量表的第4个位置，这里记为$len，如下图所示。</p><p><img src="/img/jvm/image-20210410123456070.png" alt="for循环执行细节（3）"></p><p>第8~9行：初始化数组遍历的下标初始值。iconst_0将0加载到操作数栈上，随后istore 5将栈顶的0存储到局部变量表中的第5个位置，这个局部变量是数据变量的下表初始值，这里记为$i，如下图所示。</p><p><img src="/img/jvm/image-20210410123800666.png" alt="for循环执行细节（4）"></p><p>第11~32行是循环体执行过程。</p><p>第11~15行的作用是判断循环能否继续：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">11</span>: iload         <span class="hljs-number">5</span><br><span class="hljs-number">13</span>: iload         <span class="hljs-number">4</span><br><span class="hljs-number">15</span>: if_icmpge     <span class="hljs-number">35</span><br></code></pre></div></td></tr></table></figure><p>首先通过iload 5和iload 4加载局部变量表中下标5和4的变量到栈顶，参照上图中的局部变量表我们知道下标5和下标4的变量分别是数组下标$i和数组长度$len。</p><p>接着会调用if_icmpge进行条件判断，如果$i &gt;= $len，则直接跳转到第35行指令处，for循环结束，否则继续往下执行。过程如下图所示。</p><p><img src="/img/jvm/image-20210410141322131.png" alt="for循环执行细节（5）"></p><p>第18~22行的作用是把$array[$i]赋值给number。aload_3加载$array到栈上，iload 5加载$i到栈上，然后iaload指令把下标为$i的数组元素加载到操作数栈上，随后istore 6将栈顶元素存储到局部变量表下标为6的位置上，如下图所示。</p><p><img src="/img/jvm/image-20210410145943441.png" alt="for循环执行细节（6）"></p><p>第24~28行：iload_2 和 iload 6指令把sum和number值加载到操作数栈上，然后执行iadd指令进行整数相加，如下图所示。</p><p><img src="/img/jvm/image-20210410164045262.png" alt="for循环执行细节（7）"></p><p>第29行：”iinc 5,1“指令对执行循环后的$i加一。iinc指令比较特殊，它并不依赖于操作数栈，而是直接对局部变量进行自增，再将结果出栈存储到局部变量表，因此效率非常高。</p><p><img src="/img/jvm/image-20210410164642263.png" alt="for循环执行细节（8）"></p><p>第32行：goto 11指令无条件跳转到第11行继续进行循环条件判断。</p><p>经过上述分析，很容易发现所谓”高级”for循环翻译成字节码后实际上与普通的for循环并无差别，只是个语法糖而已。</p><h3 id="swtich-case底层实现原理"><a href="#swtich-case底层实现原理" class="headerlink" title="swtich-case底层实现原理"></a>swtich-case底层实现原理</h3><p>switch-case语法实现原理依赖于tableswitch和lookupswtich两条字节码指令。先来看下面的与其字节码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseNear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (i) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">101</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">104</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对应字节码</span><br><span class="hljs-number">0</span>: iload_1<br><span class="hljs-number">1</span>: tableswitch   &#123; <span class="hljs-comment">// 100 to 104</span><br>             <span class="hljs-number">100</span>: <span class="hljs-number">36</span><br>             <span class="hljs-number">101</span>: <span class="hljs-number">38</span><br>             <span class="hljs-number">102</span>: <span class="hljs-number">42</span><br>             <span class="hljs-number">103</span>: <span class="hljs-number">42</span><br>             <span class="hljs-number">104</span>: <span class="hljs-number">40</span><br>         <span class="hljs-keyword">default</span>: <span class="hljs-number">42</span><br>    &#125;<br><span class="hljs-number">36</span>: iconst_0<br><span class="hljs-number">37</span>: ireturn<br><span class="hljs-number">38</span>: iconst_1<br><span class="hljs-number">39</span>: ireturn<br><span class="hljs-number">40</span>: iconst_4<br><span class="hljs-number">41</span>: ireturn<br><span class="hljs-number">42</span>: iconst_m1<br><span class="hljs-number">43</span>: ireturn<br></code></pre></div></td></tr></table></figure><p>这里使用了tableswitch指令，之前说过tableswitch指令在case比较紧凑的情况下使用。这里需要特别注意的是，代码中并没有102和103两个case，字节码中却自动帮我们“补齐”了，实际上是编译器对“紧凑”case的优化：一是使用tableswitch；二是case出现断层时自动补齐为连续的值。这样的好处是由于case是连续的所以可以以O(1)的时间复杂度来进行查找。</p><p>再看一个case比较“稀疏”的情况：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseFar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (i) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对应字节码</span><br><span class="hljs-number">0</span>: iload_1<br><span class="hljs-number">1</span>: lookupswitch  &#123; <span class="hljs-comment">// 3</span><br>               <span class="hljs-number">1</span>: <span class="hljs-number">36</span><br>              <span class="hljs-number">10</span>: <span class="hljs-number">38</span><br>             <span class="hljs-number">100</span>: <span class="hljs-number">41</span><br>         <span class="hljs-keyword">default</span>: <span class="hljs-number">44</span><br>    &#125;<br><span class="hljs-number">36</span>: iconst_1<br><span class="hljs-number">37</span>: ireturn<br><span class="hljs-number">38</span>: bipush        <span class="hljs-number">10</span><br><span class="hljs-number">40</span>: ireturn<br><span class="hljs-number">41</span>: bipush        <span class="hljs-number">100</span><br><span class="hljs-number">43</span>: ireturn<br><span class="hljs-number">44</span>: iconst_m1<br><span class="hljs-number">45</span>: ireturn<br></code></pre></div></td></tr></table></figure><p>可以看到这种情况case将不会被补齐，而且没有使用tableswitch而是lookupswitch字节码指令，并且case会经过排序，使得lookupswitch可以以二分查找的方式进行case的查找，时间复杂度为O(log n)。</p><h3 id="String的switch-case实现的字节码原理"><a href="#String的switch-case实现的字节码原理" class="headerlink" title="String的switch-case实现的字节码原理"></a>String的switch-case实现的字节码原理</h3><p>上面讨论的两种情况都是基于case是整形数值的情况，Java中支持在Swtich中使用String，那么这是如何实现的呢？</p><p>同样以一段代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">stringSwitch</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (name) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Java&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Kotlin&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对应字节码如下图：</p><p><img src="/img/jvm/image-20210410173623801.png" alt="对String进行switch对应字节码"></p><p>这里有几个比较关键的点，第5行中调用了String#hashCode()方法，并且选择使用lookupswitch指令，判断case后跳转到对应的行数。</p><p>由于hash值相同的String也有可能是不同字符串，因此随后会调用String#equals()方法来判断是否是相等。这里使用了ifeq指令，ifeq用于判断栈顶数据是否等于0，是则跳转到对应的行数，相当于等于false时跳转。如果相等将会继续执行，使用iconst_0将常量0压入栈顶，表示匹配了case0，或者使用iconst_1将常量1压入栈顶，表示匹配了case1，随后使用istore_3存入局部变量表。</p><p>接着就是第61~96行的处理了。61行拿到刚刚存入的0或者1，通过lookupswitch来判断跳转到不同的字节码行数执行case里面的操作。</p><h3 id="i和i-的字节码源码"><a href="#i和i-的字节码源码" class="headerlink" title="++i和i++的字节码源码"></a>++i和i++的字节码源码</h3><p>在日常开发中我们通常不会使用++i和i++这两种容易让人困惑的自增方式，而使用更加清晰的i = i + 1，不过它们很容易在面试中作为陷阱题出现，例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>        i = i++;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码的输出结果是什么呢？答案是0，查看 i = i++ 的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">···<br><span class="hljs-number">10</span>: iload_1<br><span class="hljs-number">11</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">14</span>: istore_1<br>···<br></code></pre></div></td></tr></table></figure><p>第10行：iload_1把局部变量表slot = 1的变量(i)加载到操作数栈上。</p><p>第11行：“iinc 1,1”对局部变量表slot = 1的变量(i)直接加1，但是这时候栈顶的元素没有变化，还是0.</p><p>第14行：istore_1 将栈顶元素出栈赋值给局部变量表slot = 1的变量，也就是i。此时，局部变量i又被赋值为0，前面的iinc指令对i的加一操作被覆盖。</p><p>整个过程局部变量表和操作数栈的变化如下图所示。</p><p><img src="/img/jvm/image-20210411010713498.png" alt="i = i++ 字节码执行过程"></p><p>如果把上面代码的i = i++替换成 i  = ++i，则可以正常输出打印50。替换后的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">···<br><span class="hljs-number">10</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-number">13</span>: iload_1<br><span class="hljs-number">14</span>: istore_1<br>···<br></code></pre></div></td></tr></table></figure><p>与上面i++的字节码不同的是，这里先对局部变量表中第1位变量进行了加一，然后将其加载到操作数栈，随后重新存储到局部变量表中。</p><h3 id="对象相关的字节码指令"><a href="#对象相关的字节码指令" class="headerlink" title="对象相关的字节码指令"></a>对象相关的字节码指令</h3><h4 id="1-lt-init-gt-方法"><a href="#1-lt-init-gt-方法" class="headerlink" title="1.&lt;init&gt;方法"></a>1.&lt;init&gt;方法</h4><p>&lt;init&gt;方法是对象初始化方法，类的构造方法、非静态变量的初始化、对象初始化代码块都会被编译进这个方法中。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Initializer</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 构造器方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Initializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">30</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对象初始化代码块</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对应字节码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Initializer</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: aload_0<br>       <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>       7: putfield      #2                  // Field a:I<br>      <span class="hljs-number">10</span>: bipush        <span class="hljs-number">20</span><br>      <span class="hljs-number">12</span>: istore_1<br>      <span class="hljs-number">13</span>: bipush        <span class="hljs-number">30</span><br>      <span class="hljs-number">15</span>: istore_1<br>      <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>Initializer()方法对应&lt;init&gt;对象初始化方法，其中5<del>7行将成员变量a赋值为10，10</del>12行将b赋值为10，13~15行将c赋值为30。可以看到，虽然我们将变量a和变量b分别放在构造方法外和构造代码块中初始化，实际上也会统一编译到&lt;init&gt;方法里面。</p><h4 id="2-new、dup、invokespecial对象创建三条指令"><a href="#2-new、dup、invokespecial对象创建三条指令" class="headerlink" title="2.new、dup、invokespecial对象创建三条指令"></a>2.new、dup、invokespecial对象创建三条指令</h4><p>Java 中通过 new 关键字来创建对象，字节码中也有一个叫 new 的指令，但两者不是一回事。以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Initializer initializer = <span class="hljs-keyword">new</span> Initializer();<br></code></pre></div></td></tr></table></figure><p>编译后对应字节码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">0: new           #3                  // class Initializer<br><span class="hljs-number">3</span>: dup<br>4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">7</span>: astore_1<br></code></pre></div></td></tr></table></figure><p>出去第 7 行的存储指令，new 关键字经过编译后实际上生成了 new-dup-invokespecial 3行字节码。new指令很容易理解，invokespecial 则是用于调用对象&lt;init&gt;方法来初始化对象，那么中间这个dup指令的作用是什么呢？</p><p>dup指令的含义是复制栈顶的数据并且插入到栈顶，在第0行时通过new指令创建了</p><p>Initializer的一个实例然后加入到栈顶，接着如果直接通过invokespecial调用其构造方法，由于invokespecial会消耗栈顶的类实例引用，会导致操作数栈为空，使得刚刚创建的对象丢失。因此在invokespecial调用前需使用dup复制一份实例，随后就可以通过astore_1指令将其存入局部变量表了。</p><h4 id="3-lt-clinit-gt-方法"><a href="#3-lt-clinit-gt-方法" class="headerlink" title="3.&lt;clinit&gt;方法"></a>3.&lt;clinit&gt;方法</h4><p>&lt;clinit&gt;是类的静态初始化方法，同样的，类静态初始化代码块、静态变量初始化都会被编译进这个方法中。javap输出字节码中的 static{} 表示&lt;cinit&gt;方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bytecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（四）——虚拟机执行子系统</title>
    <link href="/2021/04/10/6e2382e5/"/>
    <url>/2021/04/10/6e2382e5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java 虚拟机的指令由一个操作码（opcode）和紧随其后的可选操作数（operand）组成，占一个字节长度，故称其为“字节码（bytecode）“。</p></blockquote><h2 id="Java虚拟机栈和栈帧"><a href="#Java虚拟机栈和栈帧" class="headerlink" title="Java虚拟机栈和栈帧"></a>Java虚拟机栈和栈帧</h2><p>虚拟机常见的实现方式有两种：<strong>基于栈（Stack based）</strong>和<strong>基于寄存器（Register based）</strong>。Hotspot JVM是一种典型的基于栈的虚拟机，而Android开发者熟知的DalvikVM则是基于寄存器的虚拟机。</p><p>这两种实现方式各有优缺点：</p><ul><li>基于栈的指令集架构的优点是移植性更好、指令更短、实现简单，但是不能随机访问堆栈中的元素，完成相同功能所需的指令数一般比寄存器架构多，需要频繁的入栈出栈，不利于代码优化。</li><li>基于寄存器的指令集架构的优点是速度快，可以充分利用寄存器，有利于程序做运行速度优化，但操作数需要显式指定，指令较长。</li></ul><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，<strong>“栈帧”（Stack Frame）</strong>则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p><p>每一个栈帧中都包含了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回地址</strong>和一些额外的<strong>附加信息</strong>。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><strong>局部变量表（Local Variables Table）</strong>是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的<strong>max_locals</strong>数据项中确定了该方法所需分配的局部变量表的最大容量。</p><p>以下列代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        String temp = <span class="hljs-string">&quot;A&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用javac -p TestClass.java进行编译，然后执行javap -c -v -l TestClass查看字节码，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, java.lang.String)</span></span>;<br>  descriptor: (ILjava/lang/String;)V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">3</span><br>       0: ldc           #2                  // String A<br>       <span class="hljs-number">2</span>: astore_3<br>       <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span><br>    LineNumberTable:<br>      line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">4</span>: <span class="hljs-number">3</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   LTestClass;<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">1</span>    id   I<br>          <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>  name   Ljava/lang/String;<br>          <span class="hljs-number">3</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>  temp   Ljava/lang/String;<br></code></pre></div></td></tr></table></figure><p>可以看到Code属性中有<strong>stack</strong>、<strong>locals</strong>、<strong>args_size</strong>分别对应操作数栈的容量、<strong>局部变量表容量</strong>以及<strong>参数长度</strong>。<strong>LineNumberTable</strong>属性表存放方法的行号信息，<strong>LocalVariableTable</strong>属性表中存放方法的局部变量信息。</p><p>foo方法中只有两个参数，但实际args_size的大小为3，这是因为foo作为实例方法（非静态方法）被调用时，第0个局部变量实际上固定为调用这个实例方法的对象的引用，也就是我们所说的this。</p><p>局部变量表的容量以<strong>变量槽（Variable Slot）</strong>为最小单位，示例中局部变量表容量为4个slot。这里需要注意的是，局部变量表的容量并不等于实际局部变量的个数。这是因为有些局部变量占用的槽位在其作用域结束时可以被复用，例如if-else代码块中声明的变量在if-else执行完毕时占用槽位就可以被复用。另外并不是每一个变量都只会占用一个slot，例如double类型就会占用两个slot。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p><strong>操作数栈（Operand Stack）</strong>也常被称为操作栈，它是一个<strong>后入先出（Last In First Out，LIFO）</strong>栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的<strong>max_stacks</strong>数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。例如iadd指令，它要求操作数栈中已经存在两个int型整数，在iadd执行时，两个int数值从操作数栈中出栈，相加求和后将结果入栈，如下图所示。</p><p><img src="/img/jvm/jvm_bytecode_1_plus_2.png" alt="1+2指令执行过程"></p><p>整个JVM指令执行的过程实际上就是局部变量表与操作数栈之间不断加载、存储的过程。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方 调用过程中的<strong>动态连接（Dynamic Linking）</strong>。通过上面文章对于Class文件的解析，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。<strong>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</strong></p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>“正常调用完成”（Normal Method Invocation Completion）</strong>。</p><p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<strong>“异常调用完成（Abrupt Method Invocation Completion）”</strong>。</p><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li><li>… …等等</li></ul><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。<strong>在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</strong></p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>JVM中的方法调用字节码指令都以 “invoke” 开头，一共有5种。</p><ul><li>invokestatic：用于调用静态方法。</li><li>invokevirtual：用于调用非私有实例方法。</li><li>invokespecial：用于调用私有实例方法、构造器方法以及使用 super 关键字调用父类的实例方法等。</li><li>invokeinterface：用于调用接口方法。</li><li>invokedynamic：用于支撑动态类型语言，先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li></ul><p>Java 中将使用 invokestatic 调用的静态方法、使用 invokespecial 调用的私有实例方法、构造器方法和父类实例方法以及使用 invokevirtual 使用的被 final 修饰的不可覆盖方法统称为<strong>”非虚方法（Non-Virtual Method）”</strong>，与之相反，其他方法就被称为<strong>“虚方法”（Virtual Method）</strong>。</p><h3 id="invokestatic指令"><a href="#invokestatic指令" class="headerlink" title="invokestatic指令"></a>invokestatic指令</h3><p>invokestatic用来调用static关键字修饰的方法，即静态方法。静态方法在编译期就已经确定，且运行时不会修改，属于静态绑定。调用 invokestatic 不需要将对象加载到操作数栈，只需要将所需要的参数入栈就可以执行 invokestatic 指令了。</p><h3 id="invokevirtual指令"><a href="#invokevirtual指令" class="headerlink" title="invokevirtual指令"></a>invokevirtual指令</h3><p>invokevirtual 指令用于调用普通实例方法，它调用的目标方法在运行时才能根据对象实际的类型来确定，编译期无法知道，类似于 C++ 中的虚方法。</p><p>在调用 invokevirtual 指令前，需要将<strong>对象的引用</strong>和<strong>方法参数</strong>入栈，调用结束将对象引用和方法参数出栈，如果方法有返回值，返回值会入栈到栈顶。</p><h3 id="invokespecial指令"><a href="#invokespecial指令" class="headerlink" title="invokespecial指令"></a>invokespecial指令</h3><p>invokespecial 用于调用”特殊“的实例方法，包括如下三种：</p><ul><li>实例构造器方法&lt;init&gt;。</li><li>private 修饰的私有实例方法。</li><li>使用 super 关键字调用的父类方法。</li></ul><p>这三种方法的特殊之处在于，其方法调用在编译期就可以确定，所以 JVM 单独使用了 invokespecial 指令来调用者三种实例方法来提升效率。</p><h3 id="invokeinterface指令"><a href="#invokeinterface指令" class="headerlink" title="invokeinterface指令"></a>invokeinterface指令</h3><p>invokeinterface 用于调用接口方法，同 invokevirtual 一样，也是需要在运行时根据对象的类型确定目标方法，以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AutoCloseable autoCloseable;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    autoCloseable.close();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>foo 方法对应的字节码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> java.lang.Exception</span>;<br>  descriptor: ()V<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: getfield      #17                 // Field autoCloseable:Ljava/lang/AutoCloseable;<br>       4: invokeinterface #18,  1           // InterfaceMethod java/lang/AutoCloseable.close:()V<br>       <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>可以看到这里使用了 invokeinterface 指令来调用 close 方法。</p><h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>invokedynamic 是在JDK 7上添加的一个重量级的指令，它为指令多语言在 JVM 上的实现提供了技术支撑。</p><p>invokedynamic与其他四条方法执行指令不同的是，它会先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面 4 条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。具体的细节将在下下节<strong>“动态类型语言支持”</strong>中讨论。</p><h2 id="方法分派"><a href="#方法分派" class="headerlink" title="方法分派"></a>方法分派</h2><p>Java中多态的重要表现包括方法的重载和重写，那么虚拟机是如何确定正确的目标方法的呢？这涉及到一个概念：<strong>方法分派（Method Dispatch）</strong>。</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>所有依赖静态类型来决定方法执行版本的分派动作，都称为<strong>静态分派</strong>。静态分派的最典型应用表现就是方法重载。它在编译期间由编译器来确定应该编写哪个方法的字节码，对于虚拟机来说只需要执行指定的字节码即可，并不存在“分派”行为，因此被称为“静态分派”。来看一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDispatch</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Human guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,human!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Man guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,man!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Woman guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,woman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br>        StaticDispatch dispatch = <span class="hljs-keyword">new</span> StaticDispatch();<br>        dispatch.sayHello(man);<br>        dispatch.sayHello(woman);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">hello,human! <br>hello,human!<br></code></pre></div></td></tr></table></figure><p>实际上如果使用IDEA来编写上面的代码的话，编译器就已经提示了哪个方法被调用了：</p><p><img src="/img/jvm/image-20210416231911611.png" alt="IDEA静态分派提示"></p><p>这充分说明了对于重载方法的分派在编译期就已经确定。</p><p>对于一个对象引用的类型，我们称其为变量的“静态类型”（Static Type），例如上面代码中的 man 和 woman 的静态类型为 Human。而引用指向的具体类型称为“实际类型”（Actual Type），例如上面代码中 man 的实际类型为 Man，woman 的实际类型为 Woman。</p><p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下列代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 实际类型变化</span><br>Human human = (<span class="hljs-keyword">new</span> Random()).nextBoolean() ? <span class="hljs-keyword">new</span> Man() : <span class="hljs-keyword">new</span> Woman();<br><span class="hljs-comment">// 静态类型变化 </span><br>dispatch.sayHello((Man) human) <br>dispatch.sayHello((Woman) human)<br></code></pre></div></td></tr></table></figure><p>对象 human 的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行代码的时候才能确定。而 human 的静态类型是 Human，也可以在使用时确定，例如通过<strong>类型强转（Cast）</strong>可以将其强转为 Man 类型或者 Woman类型，但这个改变仍是在编译期可知的，两次 sayHello 的调动都可以在编译期明确类型是 Man 还是 Woman。</p><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p><strong>动态分派</strong>与Java语言多态性的另外一个重要体现——重写（Override）有着很密切的关联。依旧先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;man say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;woman say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br>        man.sayHello();<br>        woman.sayHello();<br>        man = <span class="hljs-keyword">new</span> Woman();<br>        man.sayHello();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">man say hello <br>woman say hello<br>woman say hello<br></code></pre></div></td></tr></table></figure><p>这个运行结果相信不出乎意料，依照经验就可以无需运行知道其结果。</p><p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 say Hello() 方法时产生了不同的行为，甚至变量 man 在两次调用中还执行了两个不同的方法。</p><p>要搞懂虚拟机如何判断应该调用哪个方法，我们可以通过 javap 输出字节码来寻找答案。main 方法的字节码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       0: new           #2                  // class DynamicDispatch$Man<br>       <span class="hljs-number">3</span>: dup<br>       4: invokespecial #3                  // Method DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">7</span>: astore_1<br>       8: new           #4                  // class DynamicDispatch$Woman<br>      <span class="hljs-number">11</span>: dup<br>      12: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V<br>      <span class="hljs-number">15</span>: astore_2<br>      <span class="hljs-number">16</span>: aload_1<br>      17: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      <span class="hljs-number">20</span>: aload_2<br>      21: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      24: new           #4                  // class DynamicDispatch$Woman<br>      <span class="hljs-number">27</span>: dup<br>      28: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V<br>      <span class="hljs-number">31</span>: astore_1<br>      <span class="hljs-number">32</span>: aload_1<br>      33: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V<br>      <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span><br></code></pre></div></td></tr></table></figure><p>0<del>15 行是我们熟悉的对象创建相关的字节码，接下来的16</del>21行是关键部分，16和20行的 aload 指令分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为<strong>接收者（Receiver）</strong>；17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从 invokevirtual 指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。</p><p>invoke 指令的运行解析大致分为以下几步：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</li></ol><p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。<strong>我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</strong></p><h2 id="动态类型语言的支持"><a href="#动态类型语言的支持" class="headerlink" title="动态类型语言的支持"></a>动态类型语言的支持</h2><p>动态类型语言指的是类型检查的主体过程是发生在运行期而不是编译期进行的，例如：Lua，JS，PHP，Python等，相对的C++和Java就是常见的静态类型语言。Kotlin也是静态类型语言的一种，不过Kotlin仍然可以支持<strong>无类型或者弱类型</strong>的调用，这个将在稍后进行演示。</p><p>如何理解这个“动态类型”？以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">obj.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>假设这是一行Java代码，并且变量obj的静态类型为java.io.PrintStream，那么变量obj的实际类型就必须是PrintStream的实现类或子类，否则编译期间就会报错。哪怕obj中确实包含有println(String)方法相同签名方法的类型，但它与PrintStream没有实现或者继承关系，代码依然不会正确运行。</p><p>但如果是相同的代码运行在JS平台，例如Kotlin：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> obj: <span class="hljs-keyword">dynamic</span> = <span class="hljs-literal">null</span><br>obj.println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>obj.whatever(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 实际不存在whatever这个方法</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意：dynamic不支持JVM平台。</p></blockquote><p>这段代码可以顺利通过编译，并且只要obj对象中确实存在 println(String)和 whatever(int) 方法，调用便可成功。</p><p>产生这种差别产生的根本原因是 Java 语言在编译期间却已将 println(String) 方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中，例如下面这个样子：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br></code></pre></div></td></tr></table></figure><p>这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。而 JS 等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，变量obj的值才具有类型，所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型 （即方法接收者不固定)。<strong>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</strong></p><h3 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h3><p>为了在 Java 虚拟机层面解决动态类型语言支持的问题，JDK 7时JSR-292提案首次出现了额外的方法调用指令——invokedynamic指令，并且提供了java.lang.invoke包来动态确定目标方法的机制，称为<strong>“方法句柄（Method Handle）”</strong>。</p><p>举个例子，如果我们要实现一个带谓词（谓词就是由外部传入的排序时比较大小的动作）的排序函数，在C/C++中的常用做法是把谓词定义为函数，用函数指针来把谓词传递到排序方法，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>))</span></span><br></code></pre></div></td></tr></table></figure><p>但在 Java 语言中做不到这一点，没有办法单独把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现这个接口的对象作为参数，例如Java类库中的Collections::sort()方法就是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, Comparator c)</span></span><br></code></pre></div></td></tr></table></figure><p>不过，使用invoke包中的方法句柄同样可以实现类似的效果了，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodHandleTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object obj = System.currentTimeMillis() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? System.out : <span class="hljs-keyword">new</span> ClassA();<br>        <span class="hljs-comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span><br>        getPrintlnMH(obj).invokeExact(<span class="hljs-string">&quot;sukaidev&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">getPrintlnMH</span><span class="hljs-params">(Object receiver)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// MethodType:代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)和具体参数(methodType()第二个及以后的参数)。</span><br>        MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class);<br>        <span class="hljs-comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span><br>        <span class="hljs-comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者</span><br>        <span class="hljs-comment">// 也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span><br>        <span class="hljs-keyword">return</span> lookup().findVirtual(receiver.getClass(), <span class="hljs-string">&quot;println&quot;</span>, mt).bindTo(receiver);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法 getPrintlnMH() 中实际上是模拟了 invokevirtual 指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的 Java 方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了 MethodHandle 就可以写出类似于C/C++那样的函数声明了:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, MethodHandle compare)</span></span><br></code></pre></div></td></tr></table></figure><h3 id="invokedynamic指令-1"><a href="#invokedynamic指令-1" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>前面说到 JDK 7中引入了 Java诞生以来的唯一一条新加入的字节码指令：invokedynamic 指令，不过如果我们把查看上面的 MethodHandle 例子字节码会发现并没有找到 invokedynamic 的影子。那么 invokedynamic 到底有什么应用呢?</p><p>某种意义上可以说 invokedynamic 指令与 MethodHandle 机制的作用是一样的，都是为了解决原有4 条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现， 另一个用字节码和Class中其他属性、常量来完成。</p><p>每一处含有 invokedynamic 指令的位置都被称作<strong>“动态调用点(Dynamically-Computed CallSite)”</strong>， 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 7 时新加入的<strong>CONSTANT_InvokeDynamic_info</strong>常量，从这个新常量中可以得到3项信息：<strong>引导方法</strong> (<strong>Bootstrap Method</strong>，该方法存放在新增的BootstrapMethods属性中)、<strong>方法类型（MethodType）</strong>和方法名称。</p><p>invokedynamic指令的调用流程如下。</p><ol><li>JVM 首次执行 invokedynamic 指令时会调用引导方法（Bootstrap Method）。</li><li>引导方法返回一个 CallSite 对象，CallSite 内部根据方法签名进行目标方法查找。它的 getTarget 方法返回方法句柄（MethodHandle）对象。</li><li>在 CallSite 没有变化的情况下，MethodHandle 可以一直被调用，如果 CallSite 有变化，重新查找即可。</li></ol><p>它们之间的关系如下图所示。</p><p><img src="/img/jvm/image-20210418204411595.png" alt="invokedynamic"></p><p>下面通过一个 Groovy 的例子来模拟这个过程：</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> add(a, b)&#123;<br>    <span class="hljs-keyword">new</span> Exception().printStackTrace()<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br>add(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>使用 groovyc –indy 命令编译后查看字节码如下：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  descriptor: ()Ljava/lang/Object;<br>  flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: aload_0<br>       1: ldc           #44                 // String hello<br>       3: ldc           #46                 // String world<br>       5: invokedynamic #52,  0             // InvokeDynamic #1:invoke:(LTest;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;<br>      <span class="hljs-number">10</span>: areturn<br>        <br>ConstantPool:<br>  #52 = InvokeDynamic      #1:#51         // #1:invoke:(LTest;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;<br>    <br>BootstrapMethods:<br>  ··· ···<br>  1: #34 REF_invokeStatic org/codehaus/groovy/vmplugin/v8/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;<br>    Method arguments:<br>      #48 add<br>      #49 2<br></code></pre></div></td></tr></table></figure><p>add(“hello”, “world”)这条调用被编译为 invokedynamic 指令，第一个参数是常量池中的#52，又指向了 BootsrapMethods 中的 #1 的元素，调用静态方法 IndyInterface.bootstrap，返回一个 CallSite 对象。最后，这个对象返回给invokedynamic 指令实现对add()方法的调用，invokedynamic 指令的调用过程到此就宣告完成了。可以把上面的过程翻译为 Java 代码，更清楚整个调用过程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MethodHandles.Lookup lookup = MethodHandles.lookup();<br>    MethodType mt = MethodType.methodType(Object.class, Object.class, Object.class);<br>    CallSite callSite = IndyInterface.bootstrap(lookup, <span class="hljs-string">&quot;invoke&quot;</span>, mt, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">0</span>);<br>    MethodHandle mh = callSite.getTarget();<br>    mh.invokeExact(obj, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实例：调用祖父方法"><a href="#实例：调用祖父方法" class="headerlink" title="实例：调用祖父方法"></a>实例：调用祖父方法</h3><p>invokedynamic指令与此前4条传统的“invoke*”指令的最大区别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。下面通过一个例子来实例我们如何做到改变虚拟机的分派规则。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;i am grandfather&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;i am father&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 如何调用GrandFather中的thinking()方法？</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中Son类的thinking()方法可以通过super关键字很容易的调用到Father中的thinking()方法，但要调用 GrandFather#thinking 的话传统方法就做不到了，因是在Son类的thinking()方法中根本无法获取到一个实际类型是GrandFather的对象引用。不过在拥有方法句柄之后，我们就可以通过 MethodType.Lookup 来找到祖父类中的方法句柄了：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class);<br>        Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="hljs-string">&quot;IMPL_LOOKUP&quot;</span>);<br>        lookupImpl.setAccessible(<span class="hljs-keyword">true</span>);<br>        MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="hljs-keyword">null</span>)).findSpecial(GrandFather.class, <span class="hljs-string">&quot;thinking&quot;</span>, mt, GrandFather.class);<br>        mh.invoke(<span class="hljs-keyword">this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行成功输出：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">i am grandfather<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Execution Subsystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（三）——类加载机制</title>
    <link href="/2021/03/30/d90e9b80/"/>
    <url>/2021/03/30/d90e9b80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。——《深入理解Java虚拟机》</p></blockquote><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载 （Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initializ ation）</strong>、<strong>使用（Using）</strong>和<strong>卸载（Unloading）</strong>七个阶段，其中验证、准备、解析三个部分统称为<strong>连接（Linking）</strong>。这七个阶段的发生顺序如下图所示。</p><p><img src="/img/jvm/jvm_class_loading_process.png" alt="类加载流程"></p><p>需要注意的是，在上述7个阶段中，只有加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，并且是互相交叉地混合式进行。解析阶段在某些情况下可以在初始化阶段之后再开始，直接是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><p>那么什么时候会触发这个流程呢？《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。不过，规范中严格规定了有且只有以下六种情况必须立即对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：    <ul><li>使用new关键字实例化对象时。</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）时。</li><li>调用一个类型的静态方法时。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_p utStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>这六种场景中的行为称为对一个类型进行<strong>主动引用</strong>，那么对应的就存在<strong>被动引用</strong>了，被动引用时将不会触发初始化过程。例如有三个被动引用的场景：</p><ol><li>通过子类引用父类的静态字段，不会导致子类初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>接下来我们详细了解下Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化这五个阶段所执行的具体动作。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>“加载”（Loading）</strong>阶段是整个<strong>“类加载”（Class Loading）</strong>过程中的第一个阶段。</p><p>在加载阶段，Java虚拟机需要完成以下三件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>《Java虚拟机规范》对这三点要求其实是很灵活的，例如第一条规则，它并没有规定二进制字节流必须得从某个Class文件中获取，确切地是说根本没有指明要从哪里获取、如何获取。仅仅这一点就能玩出很多花样，例如：</p><ul><li>从Zip包中获取，例如jar包、aar包、war包等。</li><li>从网络中获取。</li><li>运行时计算生成，这种场景使用的最多就是动态代理，例如我们Android开发者最熟悉的JW大佬的Retrofit，它通过动态代理来生成一个“*$Proxy”的代理类的二进制字节流，通过这个类来真正发起网络请求。</li><li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li><li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li><li>… …</li></ul><p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的<strong>findClass</strong>()或<strong>loadClass</strong>()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p><strong>对于数组类的话，数组类的元素类型本身也需要进行类加载，不过数组类本身并不通过类加载器创建，而是直接由Java虚拟机在内存中动态构造出来。</strong></p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，然后会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口，也是我们能够使用反射的主要原理。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。如果虚拟机验证到输入的字节流如不符合Class文件格式的约束，就应当抛出一个java.lang.VerifyError异常或其子类异常，此阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证</strong>、<strong>元数据验证</strong>、<strong>字节码验证</strong>和<strong>符号引用验证</strong>。</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：此阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）分配内存并设置类变量初始值的阶段。这里需要着重强调的是，首先<strong>这时候进行内存分配的仅包括类变量，而不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。这里的初始化通常情况下指的是初始化为”0值“，例如int的0值为0，long为0L，boolean为false，引用类型为null等。    </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> intValue = <span class="hljs-number">123</span>;   <span class="hljs-comment">// 初始化为0</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> longValue = <span class="hljs-number">123L</span>;  <span class="hljs-comment">// 初始化为0L</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> booleanValue = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 初始化为false</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Int&gt; value = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">// 初始化为null</span><br></code></pre></div></td></tr></table></figure><p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：如果类字段 的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定 的初始值，假设上面类变量value的定义修改为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></div></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 上篇文章讲解Class文件格式的时候已经出现过多次，在Class文件中它以<strong>CONSTANT_Class_info</strong>、 <strong>CONSTANT_Fieldref_info</strong>、<strong>CONSTANT_Methodref_info</strong>等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢?</p><ul><li><strong>符号引用（Symbolic References）</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li><li><strong>直接引用（Direct References）</strong>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li></ul><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray 、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的<strong>CONSTANT_Class_info</strong>、<strong>CONSTANT_Fieldref_info</strong>、 <strong>CONSTANT_Methodref_info</strong>、<strong>CONSTANT_InterfaceMethodref_info</strong>、 <strong>CONSTANT_MethodType_info</strong>、<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_Dynamic_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong> 8种常量类型。</p><h4 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1.类或接口的解析"></a>1.类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个 类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。</li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类<br>似“ [Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了， 但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h4 id="2-字段解析"><a href="#2-字段解析" class="headerlink" title="2.字段解析"></a>2.字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功完成，那把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="3-方法解析"><a href="#3-方法解析" class="headerlink" title="3.方法解析"></a>3.方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ol><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的 方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.Incomp atibleClassChangeError 异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则 返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="4-接口方法解析"><a href="#4-接口方法解析" class="headerlink" title="4.接口方法解析"></a>4.接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p><ol><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那 么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化阶段是类加载过程的最后一个步骤。在进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。<strong>更直接的说，初始化阶段就是执行类构造器<cinit>()方法的过程</strong>。</p><ul><li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li><li><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在J ava虚拟机中第一个被执行的<clinit> ()方法的类型肯定是java.lang.Object 。</li><li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也 一样不会执行接口的<clinit>()方法。</li><li>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，不过在某个线程执行完<clinit>()后，其他线程都不会再执行<clinit>()方法。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载流程中的“加载”阶段被放在了Java虚拟机外部实现，实现这个阶段的工具称为<strong>“类加载器（Class Loader）“</strong>。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。通俗的讲，就是两个类是否”相等“的一个大前提是这两个类是由同一类加载器加载而来，不同类加载器加载出的Class对象一定不是同一个对象。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p><p>站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。这三层类加载器如下：</p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt .jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li><strong>应用程序类加载器（Application Class Loader）</strong>：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>这些类加载器之间的协作关系通常情况下如下图所示：</p><p><img src="/img/jvm/parents_delegate_model.png" alt="双亲委派模型"></p><p>这个模型被称为<strong>”双亲委派模型（Parents Delegation Model）“</strong>。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>以类java.lang.Object为例，它存放在rt .jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委派的代码只有短短十余行，全部集中在java.lang.ClassLoader的loadClass()方法之中，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                   <span class="hljs-comment">// 委派父类加载器加载</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">// 如果父类加载器为空</span><br>                   <span class="hljs-comment">// 使用启动类加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException </span><br>                <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 在父类加载器无法加载时</span><br>                <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 统计</span><br>                PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>这里要注意的是，实际开发中如果我们需要破坏双亲委派模型，那么我们就需要重写loadClass方法，否则应该重写findClass方法</strong>。</p><h3 id="Android中的类加载器"><a href="#Android中的类加载器" class="headerlink" title="Android中的类加载器"></a>Android中的类加载器</h3><p>Android 和传统的 JVM 是一样的，也需要通过 ClassLoader 将目标类加载到内存，类加载器之间也符合双亲委派模型。但是在 Android 中，ClassLoader 的加载细节有略微的差别。</p><p>在 Android 虚拟机里是无法直接运行 .class 文件的，Android 会将所有的 .class 文件转换成一个 .dex 文件，并且 Android 将加载 .dex 文件的实现封装在 <strong>BaseDexClassLoader</strong> 中，而我们一般只使用它的两个子类：<strong>PathClassLoader</strong> 和 <strong>DexClassLoader</strong>。</p><h4 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h4><p>PathClassLoader 的源码中只有两个构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath  包含.dex文件的jar/apk文件路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, parent);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath  包含.dex文件的jar/apk文件路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> librarySearchPath C/C++ native库的路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-keyword">null</span>, librarySearchPath, parent);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>PathClassLoader继承自BaseDexClassLoader，BaseDexClassLoader中dexPath受到限制，一般只能是已经安装应用的apk路径。不过PathClassLoader情况比较特殊：</p><ul><li>在Android 4.4以下版本时，PathClassLoader只能加载已安装到系统中的apk/dex文件。</li><li>Android 5.0~Android 8.0，PathClassLoader没有限制必须已安装的apk，并且PathClassLoader中optimizedDirectory固定为null，所以无法进行dex2oat操作，最后会直接加载原始dex，达到了禁用dex2oat以实现加载加速的效果。</li><li>Android 8.1或更高，此时DexClassLoader中optimizedDirectory同样固定传递null，oat输出目录在dex目录/oat/下，此时DexClassLoader与PathClassLoader相同。</li></ul><p>当一个 App 被安装到手机后，apk 里面的 class.dex 中的 class 均是通过 PathClassLoader 来加载的，可以通过如下代码验证：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-keyword">val</span> loader = MainActivity::<span class="hljs-keyword">class</span>.java.classLoader<br>        println(loader.toString())<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>打印结果如下：</p><p><img src="/img/jvm/print_path_class_loader.png" alt="打印结果"></p><h4 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h4><p>对比 PathClassLoader 在Android 4.4以下只能加载已经安装应用的 dex 或 apk 文件，<strong>DexClassLoader</strong> 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载。</p><p>DexClassLoader 的源码里面只有一个构造方法，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dexPath 包含 class.dex 的 apk、jar 文件路径 ，多个路径用文件分隔符（默认是“:”）分隔</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> optimizedDirectory 用来缓存优化的 dex 文件的路径，即从 apk 或 jar 文件中提取出来的 dex 文件。该路径不可以为空，且应该是应用私有的，有读写权限的路径。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> DexClassLoader(String dexPath, String optimizedDirectory,<br>        String librarySearchPath, ClassLoader parent) &#123;<br>    <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-literal">null</span>, librarySearchPath, parent);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来我们尝试使用DexClassLoader来自定义一个类加载器实现热修复。</p><h2 id="类加载器实践案例"><a href="#类加载器实践案例" class="headerlink" title="类加载器实践案例"></a>类加载器实践案例</h2><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>我们尝试使用自己的类加载器来加载本地磁盘上的类文件。</p><p>首先创建一个测试类，并将其复制到磁盘的某一处，这里我创建了一个Test类，编译后将其复制到”~/Downloads”目录下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testPrint</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;This class is load from custom class loader.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来，创建一个DiskClassLoader继承自ClassLoader，重写其findClass方法，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加载本地磁盘中的class文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskClassLoader</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> filePath: String) : ClassLoader() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findClass</span><span class="hljs-params">(name: <span class="hljs-type">String</span>?)</span></span>: Class&lt;*&gt; &#123;<br>        <span class="hljs-keyword">val</span> newPath = <span class="hljs-string">&quot;<span class="hljs-variable">$filePath</span><span class="hljs-variable">$name</span>.class&quot;</span><br>        <span class="hljs-keyword">var</span> classBytes: ByteArray? = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">val</span> path: Path<br>        <span class="hljs-keyword">try</span> &#123;<br>            path = Paths.<span class="hljs-keyword">get</span>(URI(newPath))<br>            classBytes = Files.readAllBytes(path)<br>        &#125; <span class="hljs-keyword">catch</span> (e: URISyntaxException) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>        <span class="hljs-comment">// 创建Class对象</span><br>        <span class="hljs-keyword">return</span> defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes?.size ?: <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来尝试使用这个类加载器：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> loader = DiskClassLoader(<span class="hljs-string">&quot;file:///User/sukaidev/Downloads/&quot;</span>)<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">val</span> c = loader.loadClass(<span class="hljs-string">&quot;Test&quot;</span>)<br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 反射创建对象</span><br>        <span class="hljs-keyword">val</span> obj = c.newInstance()<br>        <span class="hljs-comment">// 反射调用testPrint()方法</span><br>        c.getDeclaredMethod(<span class="hljs-string">&quot;testPrint&quot;</span>).invoke(obj)<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>    e.printStackTrace()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><p><img src="/img/jvm/image-20210330224020652.png" alt="运行结果"></p><p>类加载器成功加载了路径为”User/sukaidev/Downloads/Test.class”的文件。</p><h3 id="热修复实践"><a href="#热修复实践" class="headerlink" title="热修复实践"></a>热修复实践</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>先来创建一个创建 Android 项目，名字随意，项目结构如下：</p><p><img src="/img/jvm/project_hot_fix_demo.png" alt="项目结构"></p><p>ISay.java 是一个接口，内部只定义了一个方法 saySomething。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String<br>&#125;<br></code></pre></div></td></tr></table></figure><p>SayException.java 实现了 ISay 接口，但是在 saySomething 方法中，打印“Oops! Something went wrong.”来模拟一个线上的 bug。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayException</span> : <span class="hljs-type">ISay &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Oops! Something went wrong.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后在 MainActivity.java 中，当点击 Button 的时候，将 saySomething 返回的内容通过 Toast 显示在屏幕上。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    <span class="hljs-keyword">val</span> say: ISay = SayException()<br>    findViewById&lt;AppCompatButton&gt;(R.id.btn).setOnClickListener &#123;<br>      Toast.makeText(<span class="hljs-keyword">this</span>, say.saySomething(), Toast.LENGTH_SHORT).show()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>点击按钮模拟线上报错，效果如下。</p><div align=center>  <img src="/img/jvm/online_bug.png" alt="" style="zoom:50%;" /></div><p>接下来尝试对其进行热修复。</p><h4 id="创建热修复补丁"><a href="#创建热修复补丁" class="headerlink" title="创建热修复补丁"></a>创建热修复补丁</h4><p>新建一个Java module用于制作热修复补丁，新建ISay和SayHotFix两个类，注意包名必须保持与上面一致。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String<br>&#125;<br></code></pre></div></td></tr></table></figure><p>SayHotFix 实现 ISay 接口，并在 saySomething 中返回了新的结果，用来模拟 bug 修复后的结果。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.sukaidev.dexclassloaderhotfix<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SayHotFix</span> : <span class="hljs-type">ISay &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saySomething</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Everything is OK.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来只需要build一下项目，就会在模块的build/libs目录下生成jar包。</p><p><img src="/img/jvm/image-20210330225038974.png" alt="build生成jar包"></p><p>这个<strong>hotfix.jar</strong>就是我们需要的补丁包了，但是光有jar包是不行的，DexClassLoader只能加载.dex类型的包，因此接下来通过dx工具将生成的hotfix.jar优化为dex文件。</p><p>dx工具可以在Android Sdk目录下的build-tools目录中找到各版本的dx程序，例如我的电脑可以在版本号为30.0.3的build-tools中找到：</p><p><img src="/img/jvm/image-20210330225744386.png" alt="dx工具"></p><p>使用命令优化jar包：</p><blockquote><p>dx –dex –output=hotfix_dex.jar  hotfix.jar</p></blockquote><p> 这样我们就拿到了最终需要的补丁包<strong>hotfix_dex.jar</strong>。</p><h4 id="加载补丁包"><a href="#加载补丁包" class="headerlink" title="加载补丁包"></a>加载补丁包</h4><p>正常来讲我们的补丁包是通过后端下发，然后客户端使用DexClassLoader来加载的，这里为了方便模拟，直接通过adb命令push到sdk卡中：</p><blockquote><p>adb push hotfix_dex.jar /storage/emulated/0/</p></blockquote><p>接着修改 MainActivity 中的逻辑，使用DexClassLoader加载HotFix patch中的 SayHotFix类，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    <span class="hljs-keyword">var</span> say: ISay<br>    findViewById&lt;AppCompatButton&gt;(R.id.btn).setOnClickListener &#123;<br>      <span class="hljs-keyword">val</span> jarFile =<br>        File(Environment.getExternalStorageDirectory().path + File.separator + <span class="hljs-string">&quot;hotfix_dex.jar&quot;</span>)<br><br>      <span class="hljs-keyword">if</span> (!jarFile.exists()) &#123;<br>        say = SayException()<br>        Toast.makeText(<span class="hljs-keyword">this</span>, say.saySomething(), Toast.LENGTH_SHORT).show()<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@setOnClickListener</span><br>      &#125;<br><br>      <span class="hljs-keyword">val</span> dexClassLoader =<br>        DexClassLoader(jarFile.absolutePath, filesDir.absolutePath, <span class="hljs-literal">null</span>, classLoader)<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> clazz = dexClassLoader.loadClass(<span class="hljs-string">&quot;com.sukaidev.dexclassloaderhotfix.SayHotFix&quot;</span>)<br>        <span class="hljs-keyword">val</span> iSay: ISay = clazz.newInstance() <span class="hljs-keyword">as</span> ISay<br>        Toast.makeText(<span class="hljs-keyword">this</span>, iSay.saySomething(), Toast.LENGTH_SHORT).show()<br>      &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        e.printStackTrace()<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>注意这里需求读取SD卡上的补丁包，API 23以上需要动态申请权限。运行后效果如下：</p><div align=center>  <img src="/img/jvm/image-20210331094356020.png" alt="" style="zoom:50%;" /></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClassLoader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（二）——类文件结构</title>
    <link href="/2021/03/19/233d21b7/"/>
    <url>/2021/03/19/233d21b7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“Class 文件”并非特指某个存在于具体磁盘中的问题，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。</p></blockquote><p>Java 能够实现”一次编译，到处运行”，这其中 class 文件要占大部分功劳。为了让 Java 语言具有良好的跨平台能力，Java 独具匠心的提供了一种可以在所有平台上都能使用的一种中间代码——字节码类文件（.class文件）。有了字节码，无论是哪种平台（如：Mac、Windows、Linux 等），只要安装了虚拟机都可以直接运行字节码。</p><p>有了字节码，也解除了 Java 虚拟机和 Java 语言之间的耦合。Java虚拟机并不一定只能运行Java语言编写的程序，而是只认Class文件，其他语言如Kotlin、Groovy、Scala等都可以只需要编译成符合《Java虚拟机规范》的Class文件都可以运行在Java虚拟机中。如下图所示：</p><p><img src="/img/jvm/language_independence.png" alt="JVM的语言无关性"></p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>Class文件是一组以 8 个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程运行的必要数据，没有空隙存在。当遇到需要占用 8 个字节以上空间的数据项时，则会按照<strong>高位在前（Big-Endian，大端）</strong>的方式分割成若干个 8 个字节进行存储。结构如下图所示。</p><p><img src="/img/jvm/class_file_structure.png" alt="class文件结构"></p><p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符值。</li><li>表示由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以”_info“结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由下表所示的数据项按严格顺序排列构成。</li></ul><table><thead><tr><th align="center">类    型</th><th align="center">字   段   名</th><th align="center">数    量</th><th>名   称</th></tr></thead><tbody><tr><td align="center">u4</td><td align="center">magic</td><td align="center">1</td><td>魔数</td></tr><tr><td align="center">u2</td><td align="center">minor_version</td><td align="center">1</td><td>主版本号</td></tr><tr><td align="center">u2</td><td align="center">major_version</td><td align="center">1</td><td>副版本号</td></tr><tr><td align="center">u2</td><td align="center">constant_pool_count</td><td align="center">1</td><td>常量池大小</td></tr><tr><td align="center">cp_info</td><td align="center">constant_pool</td><td align="center">constant_pool_count-1</td><td>常量池</td></tr><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">1</td><td>访问标志</td></tr><tr><td align="center">u2</td><td align="center">this_class</td><td align="center">1</td><td>当前类索引</td></tr><tr><td align="center">u2</td><td align="center">super_class</td><td align="center">1</td><td>父类索引</td></tr><tr><td align="center">u2</td><td align="center">interfaces_count</td><td align="center">1</td><td>接口索引集合大小</td></tr><tr><td align="center">u2</td><td align="center">interfaces</td><td align="center">interfaces_count</td><td>接口索引集合</td></tr><tr><td align="center">u2</td><td align="center">fields_count</td><td align="center">1</td><td>字段索引集合大小</td></tr><tr><td align="center">field_info</td><td align="center">fields</td><td align="center">fields_count</td><td>字段索引集合</td></tr><tr><td align="center">u2</td><td align="center">methods_count</td><td align="center">1</td><td>方法索引集合大小</td></tr><tr><td align="center">method_info</td><td align="center">methods</td><td align="center">methods_count</td><td>方法索引集合</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td><td>属性索引集合大小</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attribute_count</td><td>属性索引集合</td></tr></tbody></table><p>无符号数和表的关系可以用下图表示：</p><p><img src="/img/jvm/relationship_between_two.png" alt="表和无符号数之间的关系"></p><p>可以看出，在一张表中可以包含其他无符号数和其他表格。伪代码可以如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 无符号数</span><br>u1 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span>];<br>u2 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>];<br>u4 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];<br>u8 = <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// 表</span><br>class_table &#123;<br>    <span class="hljs-comment">// 表中可以引用各种无符号数，</span><br>    u1 tag;<br>    u2 index2;<br>    ...<br><br>    <span class="hljs-comment">// 表中也可以引用其它表</span><br>    method_table mt;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来，我们通过编写一个例子来看看这个表中各个数据项的具体含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Cloneable</span></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br> <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>          <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;<br>          num = num + i;<br>          <span class="hljs-keyword">return</span> num;<br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们通过 javac 编译下列代码生成 Test.class 字节码文件，然后使用 16 进制编辑器打开 class 文件查看内容：</p><p><img src="/img/jvm/class_file_content.png" alt="class文件内容"></p><p>上图中都是一些 16 进制数字，每两个字符代表一个字节。</p><h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><p>每个Class文件的头 4 个字节被称为<strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。魔数被用作格式标准校验是很常见的行为，Class 文件中的魔数值为 0xCAFEBABE ，跟 Java 的”咖啡豆“含义相互呼应。</p><p><img src="/img/jvm/class_file_magic_number.png" alt="魔数"></p><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节（<strong>0000</strong>）是次版本号，第 7 和第 8 个字节（<strong>0034</strong>）是主版本号。0034 对应的十进制是 52，也就是  <strong>jdk1.8.0</strong> 。</p><p><img src="/img/jvm/class_file_version.png" alt="版本号"></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧跟在版本号之后的是一个叫作<strong>常量池</strong>的表（cp_info）。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中的。</p><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表<strong>常量池容量计数值（constant_pool_count）</strong>。例如本例中常量池大小为 <strong>0x001D</strong> ，即 <strong>29</strong> ，表示常量池中有 <strong>28</strong> 项常量，索引值范围为 <strong>1~28</strong> 。这里将 0 空出来是为了后面有表的索引值为 0 时，可以表达<strong>“不引用任何一个常量池项目”的含义。</strong></p><p><img src="/img/jvm/class_file_constant_pool_size.png" alt="常量池大小"></p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）</strong>。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量(Dynamically-Computed Call Site、Dynamically-Computed Constant)</li></ul><p>常量池中的每一项都是一个表，截止至 JDK13 ，常量表中分别有17种不同的项目类型。</p><table><thead><tr><th align="center">类   型</th><th align="center">标   志</th><th align="center">描   述</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8_info</td><td align="center">1</td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">5</td><td align="center">长精度型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">6</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">7</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">8</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">9</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的部分符号引用</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">表示方法类型</td></tr><tr><td align="center">CONSTANT_Dynamic_info</td><td align="center">17</td><td align="center">表示一个动态计算常量</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr><tr><td align="center">CONSTANT_Module_info</td><td align="center">19</td><td align="center">表示一个模块</td></tr><tr><td align="center">CONSTANT_Package_info</td><td align="center">20</td><td align="center">表示一个模块中开放或者导出的包</td></tr></tbody></table><p>这 17 类表都有一个共同的特点，表结构起始的第一位是个 u1 类型的标志位，即上表中的标志，代表着当前常量属于哪种常量类型。下面以<strong>CONSTANT_Class_info</strong> 和 <strong>CONSTANT_Utf8_info</strong> 这两张表为例，来分析一下表结构。</p><p>首先，CONSTANT_Class_info 表具体结构如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">table CONSTANT_Class_info &#123;<br>    u1  tag = <span class="hljs-number">7</span>;<br>    u2  name_index;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>tab：上面说过了是表示表的类型，例如7表示CONSTANT_Class_info类型表，占用一个字节大小。</li><li>name_index：是一个索引值，可以将它理解为一个指针，指向常量池中索引为name_index的常量表。比如name_index = 2，则它指向常量池中第2个常量。</li></ul><p>接下来再看CONSTANT_Utf8_info表具体结构如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">table CONSTANT_utf8_info &#123;<br>    u1  tag;<br>    u2  length;<br>    u1[] bytes;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>解释说明：</p><ul><li>tag：值为1，表示是CONSTANT_Utf8_info类型表。</li><li>length：length表示u1[]的长度，比如length=5，则表示接下来的数据是 5 个连续的u1类型数据。</li><li>bytes：u1类型数组，长度为上面第2个参数length的值。</li></ul><p>而我们在java代码中声明的String字符串最终在class文件中的存储格式就是CONSTANT_utf8_info。因此一个字符串最大长度也就是u2所能代表的最大值65536个，但是需要使用2个字节来保存null值，因此<strong>一个字符串的最大长度为 65536 - 2 = 65534</strong>。</p><p>不难看出，在常量池内部的表中也有相互之间的引用。用一张图来理解CONSTANT_Class_info和CONSTANT_utf8_info表格之间的关系，如下图所示：</p><p><img src="/img/jvm/class_file_relationship_of_constant.png" alt="常量表相互引用关系"></p><p>接下来我们继续基于上面的例子分析。上面说到版本号之后就是常量池大小，为0x001D即29，表示常量计数器为28。紧接着就是第一个常量，如下所示：</p><p><img src="/img/jvm/class_file_first_constant.png" alt="第一个常量tag"></p><p>第一个字节表示tag，<strong>0x0a</strong>转化为十进制后为10，通过上面的表格我们知道tag=10时的表类型为<strong>CONSTANT_Methodref_info</strong>，因此第一个常量表结构为方法引用表。其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CONSTANT_Methodref_info &#123;<br>    u1 tag = <span class="hljs-number">10</span>;<br>    u2 class_index;        <span class="hljs-comment">// 指向此方法的所属类</span><br>    u2 name_type_index;    <span class="hljs-comment">// 指向此方法的名称和类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在“0a”之后的2个字节指向这个方法是属于哪个类，紧接的2个字节指向这个方法的名称和类型。它们的值分别是：</p><ul><li>0006：十进制6，表示指向常量池中的第6个常量。</li><li>0015：十进制21，表示指向常量池中的第21个常量。</li></ul><p>由于每个常量表占用字节的长度是不一定的，所以我们必须顺序解析到第6个常量才能知道第6个常量是什么类型，不过这里我们可以利用javap命令来帮助我们查看常量池的内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">javap -v Test.class<br></code></pre></div></td></tr></table></figure><p>命令执行后结果如下：</p><p><img src="/img/jvm/class_file_javap.png" alt="使用javap命令查看常量池"></p><p>正如我们刚才分析的一样，常量池中第一个常量是Methodref类型，指向下标6和下标21的常量。其中下标21的常量类型为<strong>NameAndType</strong>，它对应的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CONSTANT_NameAndType_info&#123;<br>    u1 tag;<br>    u2 name_index;    <span class="hljs-comment">// 指向某字段或方法的名称字符串</span><br>    u2 type_index;    <span class="hljs-comment">// 指向某字段或方法的类型字符串</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而下标在21的NameAndType的name_index和type_index分别指向了13和14，也就是<strong>“<init>”</strong>和<strong>“()V”</strong>。因此最终解析下来常量池中第1个常量的解析过程以及最终值如下图所示：</p><p><img src="/img/jvm/class_file_first_constant_reference.png" alt="第1个常量引用链"></p><p>仔细解析层层引用，最后我们可以看出，Test.class文件中常量池的第1个常量保存的是Object中的默认构造器方法。</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表<strong>访问标志（access_flags）</strong>，如下图所示：</p><p><img src="/img/jvm/class_file_access_flag.png" alt="访问标志"></p><p>这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。具体的标志位以及标志的含义见下表：</p><table><thead><tr><th align="center">标  志  名  称</th><th align="center">标  志  值</th><th align="center">含   义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为public类型</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否被声明为final，只有类可设置</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td align="center">是否允许使用invokespecial字节码指令的新语义，JDK 1.0.2 之后默认为真</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td align="center">标识这是一个接口</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">是否为abstract类型，对于接口或抽象类来说为真</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">标识这个类并非由用户代码产生</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td align="center">标识这是一个注解</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">标识这是一个枚举</td></tr><tr><td align="center">ACC_MODULE</td><td align="center">0x8000</td><td align="center">标识这是一个模块</td></tr></tbody></table><p>我们定义的Test.java是一个普通Java类，不是接口、枚举或注解。并且被public修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它所对应的access_flags为<strong>0021</strong>（0X0001和0X0020相结合）。</p><h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>在访问标志后的 2 个字节就是<strong>类索引（this_class）</strong>，类索引后的 2 个字节就是<strong>父类索引（super_class）</strong>，父类索引后的 2 个字节则是<strong>接口索引计数器（interfaces）</strong>。<strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</strong>由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>在我们的例子中如下图所示：</p><p><img src="/img/jvm/class_file_this_super_class.png" alt="类索引、父类索引、接口索引计数器"></p><p>可以看出类索引指向常量池中的第 5 个常量，父类索引指向常量池中的第 6 个常量，并且实现的接口个数为 2 个。再回顾下常量池中的数据：</p><p><img src="/img/jvm/class_file_interfaces.png" alt="常量池中索引"></p><p>从图中可以看出，第 5 个常量和第 6 个常量均为 CONSTANT_Class_info 表类型，并且代表的类分别是“Test”和“Object”。再看接口计数器，因为接口计数器的值是 2，代表这个类实现了 2 个接口。查看在接口计数器之后的 4 个字节分别为：</p><ul><li>0007：指向常量池中的第7个常量，从图中可以看出第7个常量值为“Serializable”。</li><li>0008：指向常量池中的第8个常量，从图中可以看出第8个常量值为“Cloneable”。</li></ul><p>综上所述，可以得出如下结论：当前类为 Test 继承自 Object 类，并实现了“Serializable”和“Cloneable”这两个接口。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>紧跟在接口索引集合后面的就是<strong>字段表（field_info）</strong>了，字段表用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>同样, 一个类中的变量个数是不固定的，因此在字段表集合之前还是使用一个计数器来表示变量的个数，如下所示：</p><p><img src="/img/jvm/class_file_field_info_count.png" alt="字段表计数器"></p><p><strong>0002</strong> 表示类中声明了 2 个变量（在 class 文件中叫字段），字段计数器之后会紧跟着 2 个字段表的数据结构。</p><p>字段表的具体结构如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CONSTANT_Fieldref_info&#123;<br>    u2  access_flags        <span class="hljs-comment">// 字段的访问标志</span><br>    u2  name_index          <span class="hljs-comment">// 字段的名称索引(也就是变量名)</span><br>    u2  descriptor_index    <span class="hljs-comment">// 字段的描述索引(也就是变量的类型)</span><br>    u2  attributes_count    <span class="hljs-comment">// 属性计数器</span><br>    attribute_info attributes <span class="hljs-comment">// 属性表集合</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>字段访问标志放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如下表所示。</p><table><thead><tr><th align="center">标 志 名 称</th><th align="center">标 志 值</th><th align="center">含  义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">字段是否为public</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">字段是否为private</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">字段是否为protected</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">字段是否static</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">字段是否final</td></tr><tr><td align="center">ACC_VOLATILE</td><td align="center">0x0040</td><td align="center">字段是否volatile</td></tr><tr><td align="center">ACC_TRANSIENT</td><td align="center">0x0080</td><td align="center">字段是否transient</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">字段是否synthetic</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">字段是否为enum</td></tr></tbody></table><p>很明显，由于语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最 多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所导致的。</p><p>跟随access_flags标志的是两项索引值：<strong>name_index</strong>和<strong>descriptor_index</strong>。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，如下表所示。</p><table><thead><tr><th align="center">标  识  字  符</th><th align="center">含    义</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">基本类型byte</td></tr><tr><td align="center">C</td><td align="center">基本类型char</td></tr><tr><td align="center">D</td><td align="center">基本类型double</td></tr><tr><td align="center">F</td><td align="center">基本类型float</td></tr><tr><td align="center">I</td><td align="center">基本类型int</td></tr><tr><td align="center">J</td><td align="center">基本类型long</td></tr><tr><td align="center">S</td><td align="center">基本类型short</td></tr><tr><td align="center">Z</td><td align="center">基本类型boolean</td></tr><tr><td align="center">V</td><td align="center">特殊类型void</td></tr><tr><td align="center">L</td><td align="center">对象类型，如Ljava/lang/Object;</td></tr></tbody></table><p><strong>对于数组类型，每一维度将使用一个前置的“ [”字符来描述，如一个定义为“ jav-a.lang.String[][]”类型的二维数组将被记录成“ [[Ljava/lang/String;”，一个整型数组“ int []”将被记录成“ [I”。</strong></p><p>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String;”，方法int indexOf(char[]so-urce，int sourceOffset，int sourceCount，char[] target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p><p>继续解析 Text.class 中的字段表，其结构如下图所示：</p><p><img src="/img/jvm/class_file_field_info.png" alt="Text.class中的字段表"></p><p>图中的访问标志的值为 <strong>0002</strong>，代表它是 private 类型。变量名索引指向常量池中的第 9 个常量，变量名类型索引指向常量池中第 10 个常量。第 9 和第 10 个常量分别为“num”和“I”，如下所示：</p><p><img src="/img/jvm/class_file_field_info_name_index.png" alt="字段名称和描述符"></p><p>因此可以得知类中有一个名为 num，类型为 int 类型的变量。对于第 2 个变量的解析过程也是一样，就不再过多介绍。</p><p>注意事项：</p><ul><li><p>字段表集合中不会列出从父类或者父接口中继承而来的字段。</p></li><li><p>内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></li></ul><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引）（name_index）、描述符索引（descrip tor_index）、属性表集合（attributes）几项，如下所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CONSTANT_Fieldref_info&#123;<br>    u2  access_flags        <span class="hljs-comment">// 字段的访问标志</span><br>    u2  name_index          <span class="hljs-comment">// 字段的名称索引(也就是变量名)</span><br>    u2  descriptor_index    <span class="hljs-comment">// 字段的描述索引(也就是变量的类型)</span><br>    u2  attributes_count    <span class="hljs-comment">// 属性计数器</span><br>    attribute_info attributes <span class="hljs-comment">// 属性表集合</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为volatile关键字和transient 关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了<strong>ACC_SYNCHRONIZED</strong>、 <strong>ACC_NATIVE</strong>、<strong>ACC_STRICTFP</strong>和<strong>ACC_ABSTRACT</strong>标志。</p><table><thead><tr><th align="center">标 志 名 称</th><th align="center">标 志 值</th><th align="center">含  义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">方法是否为public</td></tr><tr><td align="center">ACC_PRIVATE</td><td align="center">0x0002</td><td align="center">方法是否为private</td></tr><tr><td align="center">ACC_PROTECTED</td><td align="center">0x0004</td><td align="center">方法是否为protected</td></tr><tr><td align="center">ACC_STATIC</td><td align="center">0x0008</td><td align="center">方法是否static</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">方法是否final</td></tr><tr><td align="center">ACC_SYNCHRONIZED</td><td align="center">0x0020</td><td align="center">方法是否synchronized</td></tr><tr><td align="center">ACC_BRIDGE</td><td align="center">0x0040</td><td align="center">方法是否是由编译器产生的桥接方法</td></tr><tr><td align="center">ACC_VARARGS</td><td align="center">0x0080</td><td align="center">方法是否接收不定参数</td></tr><tr><td align="center">ACC_NATIVE</td><td align="center">0x0100</td><td align="center">方法是否是native方法</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">方法是否是abstract</td></tr><tr><td align="center">ACC_STRICT</td><td align="center">0x0800</td><td align="center">方法是否为strictfp</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">方法是否由编译器自动产生</td></tr></tbody></table><p>我们主要来看下 add 方法，具体如下：</p><p><img src="/img/jvm/class_file_method_add.png" alt="add方法"></p><p>从图中我们可以看出 add 方法的以下字段的具体值：</p><ol><li>access_flags = 0x0001 也就是访问权限为 public。</li><li>name_index = 0x0011  指向常量池中的第 17 个常量，也就是“add”。</li><li>type_index = 0x0012   指向常量池中的第 18 个常量，也即是 (I)。这个方法接收 int 类型参数，并返回 int 类型参数。</li></ol><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在之前解析字段和方法的时候，在它们的具体结构中我们都能看到有一个叫作 attributes_info 的表，这就是属性表。</p><p>属性表并没有一个固定的结构，各种不同的属性只要满足以下结构即可：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CONSTANT_Attribute_info&#123;<br>    u2 attribute_name_index;          <span class="hljs-comment">// 属性名</span><br>    u2 attribute_length length;       <span class="hljs-comment">// 属性值长度</span><br>    u1[] info;                        <span class="hljs-comment">// 属性值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>JVM 中预定义了很多属性表，这里重点讲一下 <strong>Code 属性表</strong>。</p><p>Java程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示。</p><table><thead><tr><th align="center">类  型</th><th align="center">名  称</th><th align="center">数  量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">attribute_name_index</td><td align="center">1</td></tr><tr><td align="center">u4</td><td align="center">attribute_length</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">max_stack</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">max_locals</td><td align="center">1</td></tr><tr><td align="center">u4</td><td align="center">code_length</td><td align="center">1</td></tr><tr><td align="center">u1</td><td align="center">code</td><td align="center">code_length</td></tr><tr><td align="center">u2</td><td align="center">exception_table_length</td><td align="center">1</td></tr><tr><td align="center">exception_info</td><td align="center">exception_table</td><td align="center">exception_table_length</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attributes_count</td></tr></tbody></table><p>下面分别解释一下这些属性：</p><ul><li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，<strong>由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</strong></li><li>max_stack代表了操作数栈(Operand Stack)深度的最大值。</li><li>max_locals代表了局部变量表所需的存储空间。</li><li>code_length和code用来存储Java源程序编译后生成的字节码指令。</li></ul><p>关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</p><p>我们可以接着刚才解析方法表的思路继续往下分析：</p><p><img src="/img/jvm/class_file_attr_count.png" alt="属性计数和类型索引"></p><p>可以看到，在方法类型索引之后跟着的就是“add”方法的属性。0X0001 是属性计数器，代表只有一个属性。0X000f 是属性表类型索引，通过查看常量池可以看出它是一个 Code 属性表，如下所示：</p><p><img src="/img/jvm/class_file_attr_index_15.png" alt="索引15为Code"></p><p>通过 javap -v Test.class 之后，可以看到方法的字节码，如下图显示的是 add 方法的字节码指令：</p><p><img src="/img/jvm/class_file_attr_codebyte.png" alt="add方法字节码指令"></p><p>JVM 执行 add 方法时，就通过这一系列指令来做相应的操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35079283/">《深入理解JVM字节码》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Class File</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM（一）——自动内存管理</title>
    <link href="/2021/03/12/132bcd6f/"/>
    <url>/2021/03/12/132bcd6f/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><p>对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”， 又是从事最基础工作的劳动人民——既拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。</p><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对 的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问 题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如下所示。</p><p><img src="/img/jvm/jvm_run_time_data_areas.png" alt="JVM Run-time data areas"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个技术记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则应为空（Undefined）。此内存区是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，<strong>Java虚拟机栈（Java Virtual Machine Stack）</strong>也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧（Stack Frame）</strong>用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（<strong>boolean</strong>、<strong>byte</strong>、<strong>char</strong>、<strong>short</strong>、<strong>int</strong>、 <strong>float</strong>、<strong>long</strong>、<strong>double</strong>）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈（Native Method Stacks）</strong>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于Java应用程序来说，<strong>Java堆（Java Heap）</strong>是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域存在的唯一目的就是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的内存区域，因此有些资料也称其为<strong>”GC堆“（Garbage Collected Heap）</strong>。</p><p>从回收内存的角度看，现代垃圾收集器通常在<strong>逻辑上</strong>将Java堆分为<strong>”新生代“</strong>、<strong>”老年代“</strong>、<strong>”永久代“</strong>、”<strong>Eden空间“</strong>、<strong>”From Survivor空间“</strong>等区域，但这些区域划分仅仅是一部分垃圾收集器的共同特性或者设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，也与《Java虚拟机规范》无关。</p><p>从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB）</strong>，以提升对象分配时的效率。不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。如果堆中内有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在《Java虚拟机规范》中把方法区描述为<strong>堆的一个逻辑部分</strong>，为了与Java堆区分，通常把它叫做<strong>”非堆（Non-Heap）“</strong>。</p><p>方法区的内存使用超过限制会抛出OutOfMemory异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说<strong>，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</strong></p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>在JDK 1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMe-moryError异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>接下来我们以最常见的虚拟机HotSpot和内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p><p>先看一张图：</p><p><img src="/img/jvm/jvm_java_object_creation.png" alt="Java Object Creation"></p><p>我们来分析一下这个流程。</p><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。Java堆中有两种内存分配方式，分别是<strong>”指针碰撞“</strong>和<strong>”空闲列表“</strong>。</p><ul><li><strong>指针碰撞（Bump The Pointer）：</strong>已分配内存和空闲内存之间放置一个作为分界点的指示器，通过移动这个指示器来调整空闲空间的大小实现对象的内存分配。这种分配方式适合内存绝<strong>对规整</strong>的情况。</li><li><strong>空闲列表（Free List）：</strong>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有<strong>空间压缩整理（Compact）</strong>的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p><p>除了划分可用内存空间之外，对象的创建实际上还会有线程安全的问题：可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。要解决这个问题有两种可选方案：</p><ol><li>对分配内存空间的动作进行同步处理。实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间之中进行。这种情况需要每个线程预先在堆上分配一小块内存，称为本地线程分配缓冲<strong>（Thread Local Allocation Buffer，TLAB）</strong>，哪个线程要分配内存，就先到它的TLAB中分配，只有TLAB满了，分配新的缓存区时才需要同步锁定。</li></ol><p>分配完内存之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</p><p>接下来JVM需要对对象进行必要的设置，例如接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的<strong>对象头(Object Header)之中</strong>。</p><p>完成上面的工作之后，在虚拟机看来实际上一个新的对象已经产生了。不过从程序角度来看，还需要调用构造函数来初始化对象的资源和状态。因此new指令之后接着会执行Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。如下图所示。</p><p><img src="/img/jvm/HotSpot_object_storage_distribution.png" alt="HotSpot虚拟机对象存储分布"></p><p>其中MarkWord是一个有着动态定义的数据结构，在未开启指针压缩的情况，在32位和64位虚拟机上的长度分别为32个比特和64个比特。</p><p>例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><table><thead><tr><th align="center">存储内容</th><th align="center">标志位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象哈希码、分代年龄</td><td align="center">01</td><td align="center">未锁定</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">00</td><td align="center">轻量级锁定</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">10</td><td align="center">膨胀（重量级锁定）</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">01</td><td align="center">可偏向</td></tr></tbody></table><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li>使用句柄访问时，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自具体的地址信息，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_handles.png" alt="通过句柄访问对象"></p><ul><li>使用直接指针访问时，Java堆中对象的内存布局就必须考虑如何放置访问数据类型的相关信息，reference中存储的直接就是对象地址。如果只是访问对象本身的话，就不需要额外的间接访问开销了，如下图所示。</li></ul><p><img src="/img/jvm/access_objects_through_pointer.png" alt="通过直接指针访问对象"></p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><p><strong>垃圾收集简称GC（Garbage Collection）</strong>，它主要需要完成三件事：</p><ul><li>那些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>上面介绍了Java内存运行时区域的各个部分，我们知道线程私有的区域可以随着线程的销毁而进行内存的清理工作，而Java堆和方法区是线程共享的部分，这部分内存的分配和回收是动态的，所以是垃圾收集器重点关注的区域，本文讨论的也是这两个区域。</p><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>在Java堆中存放这Java世界中几乎所有的对象实例，垃圾收集器在堆堆进行GC钱，第一件事就是要确认哪些对象的实例”活着“，哪些对象已经”死亡“需要被回收。</p><p>目前主流的判断对象存活的算法有两种：</p><ul><li><strong>引用计数法</strong></li><li><strong>可达性分析法</strong></li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数：<strong>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</strong></p><p>此算法简单且高效，只需要占用一些额外的内存空间来进行计数，但主流的JVM都没有选用这个算法来管理内存，主要原因是：这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><p>这也是常说的”循环引用“问题，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// &lt;-- 背景 --&gt;</span><br><span class="hljs-comment">// 对象objA 和 objB 都有字段 name</span><br><span class="hljs-comment">// 两个对象相互进行引用，除此之外这两个人对象没有任何引用</span><br>objA.name = objB；<br>objB.name = objA；<br><br><span class="hljs-comment">// &lt;-- 问题 --&gt;</span><br><span class="hljs-comment">// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收</span><br><span class="hljs-comment">// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象</span><br></code></pre></div></td></tr></table></figure><p>当出现循环引用时，两个对象已经”死亡“，但实际上由于引用计数器不为0而无法被回收引起泄露。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。</p><p>可达性分析（Reachability Analysis）：<strong>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</strong></p><p><img src="/img/jvm/reachablity_analysis_process.png" alt="可达性分析法"></p><p>如上图所示，与GC Root不存在引用链的对象将会被判为“死亡”对象，在下一次GC时进行回收。</p><p>Java中固定可作为GC Root的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象，即栈帧中的本地变量表，里面存放了各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，例如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</li></ul><p>除了上述固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。例如发生局部回收（Partial GC）时，如果只针对Java堆中某一块区域发起垃圾收集，这个区域里的对象完全有可能被区域外部的其他对象引用，例如下图中的B对象。此时A对象会被一并加入到GC Roots集合中，充当临时的GC Root，才能保证可达性分析的准确性。</p><p><img src="/img/jvm/partial_gc_reachability.png" alt="局部GC"></p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>一个对象要真正被垃圾回收器回收，除了要在可达性分析判断为不可达对象外，还要经历至少两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<strong>finalize</strong>方法。如果对象没有复写finalize方法或者finalize方法已经被调用过一次了，那么这两种情况都被视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<strong>F-Queue</strong>的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，<strong>但并不承诺一定会等待它运行结束</strong>。 不承诺它一定结束的原因是，finalize()方法可能会很耗时或者存在死循环导致其他对象无法正常执行finalize()。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>圾收集算法可以划分为“<strong>引用计数式垃圾收集”（Reference Counting GC）</strong>和<strong>“追踪式垃圾收集”（Tracing GC）</strong>两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。本文主要探讨追踪式垃圾收集。</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，它建立在两个假说之上：</p><ol><li><strong>弱分代假说（Weak Generational Hypothesis）</strong>：绝大多数对象都是朝生夕灭的。</li><li><strong>强分代假说（Strong Generational Hypothesis）</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>基于这两个假说，垃圾收集器可以将 Java堆划分为不同的区域，根据对象的年龄将其分配到不同区域中，在不同的区域中采用不同的垃圾收集频率和算法。例如虚拟机中可能存在下列几种算法：</p><ul><li><strong>部分收集（Partial GC）</strong>：指目标不是完整收集整个Java堆的垃圾收集。<ul><li><strong>新生代收集（Minor GC/Young GC）</strong>：指目标只是新生代的垃圾收集。</li><li><strong>老年代收集（Major GC/Old GC）</strong>：指目标只是老年代的垃圾收集。</li><li><strong>混合收集（Mixed GC）</strong>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><strong>整堆收集（Full GC）</strong>：收集整个Java堆和方法区的垃圾收集。</li></ul><p>例如我们可以将Java堆粗略的分为<strong>新生代（Young Generation）</strong>和<strong>老年代（Old Generation）</strong>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>我们可以在新生代和老年代分别进行GC操作，这就引申出一个问题：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p><ul><li><strong>跨代引用假说（Intergenerational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>依据这条假说，我们只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-Sweep）算法是最早出现也是最基础的垃圾收集算法，它分为“标记”和“清除”两个阶段：</p><ul><li><strong>标记（Mark）</strong>：标记所有需要清除或者保留的对象。</li><li><strong>清除（Sweep）</strong>：回收所有被标记或者未被标记的对象。</li></ul><p>标记-清除算法是最基础的收集算法，后续的收集算法大多都是基于它改进产生的。为什么需要改进呢，是因为它有两个比较明显的缺点：</p><ul><li>执行效率不稳定：标记和清除两个过程的执行效率随着对象数量增长而降低。</li><li>内存空间碎片化：标记、清除之后会产生大量不连续的内存碎片，会导致后续需要分配大对象例如数组的时候无法找到连续内存而发生OOM。</li></ul><p>标记-清除算法的执行过程如下图所示。</p><p><img src="/img/jvm/mark_sweep_process.png" alt="标记-清除算法执行过程"></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记-复制（Mark-Copy）算法常被简称为复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完的时候，就将这块内存上存活的对象复制到另一块内存中，最后将之前那块内存一次清理掉。</p><p>标记-复制算法可以解决标记-清除中内存碎片过多的问题，但缺点也是显而易见的：将可用内存缩小为了原来的一半。</p><p>标记-复制算法执行过程如下图所示。</p><p><img src="/img/jvm/mark_copy_process.png" alt="标记-复制算法执行过程"></p><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，但并不按照1：1的比例来划分新生代的内存空间，而是把新生代划分为<strong>一块较大的Eden空间和两块较小的Survivor空间</strong>，每次分配内存只考虑Eden空间和其中的一块Survivor。当发生GC时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是说将原先标记-复制算法浪费一半空间的问题缩小到了10%。当然这个算法也有一个问题，就是只预留10%的新生代空间，有可能会存在这10%空间不足以将存活的对象复制过去的问题，所以实际中发生这个问题时还会有老年代参与进来接收这些不足够存放的对象。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>我们前面讨论了新生代要如何进行分区进行标记-复制算法的问题。新生代中对象“朝生夕灭”，每次GC只需要复制少量的对象即可完成算法过程。但老年代中对象存活率较高，如果需要频繁的进行复制操作，效率将会很低，因此老年代中一般不会采用标记-复制算法。</p><p>标记-整理（Mark-Compact）算法与标记清除-算法类似，不同的是在标记后不会立即进行清理，而是先进行让所有存活的对象都向内存空间的一端进行移动，即”整理“，然后直接清除掉边界以外的内存。步骤如下：</p><ol><li><strong>标记阶段</strong>：标记出所有需要回收的对象；</li><li><strong>整理阶段</strong>：让所有存活的对象都向一端移动</li><li><strong>清除阶段</strong>：统一清除（回收）端以外的对象。</li></ol><p>算法执行过程如下图所示。</p><p><img src="/img/jvm/mark_compat_process.png" alt="标记-整理算法执行过程"></p><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/34907497">《深入理解Java虚拟机》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.jianshu.com/p/0269237a229d">JVM：这是一份全面 &amp; 详细的 （GC）垃圾收集算法 讲解攻略</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://www.liuguangli.win/archives/500">Java对象之死</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（五）——官方框架</title>
    <link href="/2021/02/28/c18f109d/"/>
    <url>/2021/02/28/c18f109d/</url>
    
    <content type="html"><![CDATA[<h2 id="协程框架概述"><a href="#协程框架概述" class="headerlink" title="协程框架概述"></a>协程框架概述</h2><p>Kotlin协程的官方框架kotlin.coroutines是一套独立于标准库之外的以生产为目的的框架，框架本身提供了丰富的API来支撑生产环境中异步程序的设计和实现。主要包含以下几个部分：</p><ul><li>core：框架的核心逻辑，包含前两篇文章实现的内容和Channel、Flow等特性。</li><li>ui：包含android、javafx、swing三个库，用于提供各平台的UI调度器和一些特有的逻辑。</li><li>reactive：提供对各种响应式编程框架的协程支持。<ul><li>reactive：提供对<a href="http://www.reactive-streams.org/">Reactive Streams</a>的协程支持。</li><li>reactor：提供对<a href="https://projectreactor.io/">Reactor</a>的协程支持。</li><li>rx2：提供对<a href="https://github.com/ReactiveX/RxJava">RxJava 2.x</a>版本的协程支持。</li></ul></li><li>integration：提供与其他框架的异步回调的集成。<ul><li>jdk8：提供对CompletableFuture的协程API的支持。</li><li>guava：提供对ListenableFuture的协程API的支持。</li><li>slf4j：提供MDCContext作为协程上下文的元素。</li><li>play-services：提供对Google Play服务中的Task的协程API的支持。</li></ul></li></ul><p><img src="/img/kotlinx_coroutines_framework.png" alt="官方协程框架的结构"></p><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>kotlin官方协程框架中协程的启动多了一个start参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动模式总共有4种。</p><ul><li>DEFAULT ：协程创建后，立即开始调度，在调度前如果被取消则进入取消相应的状态。</li><li>ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点前不响应取消。</li><li>LAZY：只有协程主调调用start、join或者await等函数时才会开始调度，如果调度前被取消将进入异常结束状态。</li><li>UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个挂起点。</li></ul><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>官方框架中预置了4个调度器，我们可以通过Dispatchers对象访问它们。</p><ul><li>Default：默认调度器，适合处理后台计算，是一个CPU密集型任务调度器。</li><li>IO：IO调度器，适合执行IO相关操作，是一个IO密集型任务调度器。</li><li>Main：UI调度器，根据平台不同会被初始化为对应的UI线程的调度器，例如ANdroid平台的主线程（UI线程）。</li><li>Unconfined：未定调度器，不要求协程执行在特定的线程上。如果协程的调度器是Unconfined，那么它在挂起点恢复执行时后续代码会在恢复所在的线程上直接执行。</li></ul><p>如果内置的调度器无法满足需求，也可以自定义调度器，只需要实现CoroutineDispatcher接口即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDispatcher</span> : <span class="hljs-type">CoroutineDispatcher</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>      ... ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>更多的时候我们将自己定义好的线程池转成调度器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Executors.newSingleThreadExecutor()<br>    .asCoroutineDispatcher()<br>    .use &#123; dispatcher -&gt;<br>        <span class="hljs-keyword">val</span> result = withContext(dispatcher) &#123;<br>            delay(<span class="hljs-number">1000</span>)<br>            <span class="hljs-string">&quot;Hello World.&quot;</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里用到了<strong>asCoroutineDispatcher</strong>和<strong>withContext</strong>两个扩展函数。asCoroutineDispatcher实际上也就是把线程池转为CoroutineDispatcher接口的实现，withContext函数会将参数中的Lambda表达式调度到对应的调度器上，返回值为Lambda表达式的值，它的作用等价于async{ … }.await()，且内存开销更低，因此对于async之后立即await的情况都可以用withContext来提高性能。</p><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>官方框架中支持全局的异常处理器，在根协程（顶级协程）未设置异常处理器时，未捕获异常会优先传递给全局异常处理器处理，之后再交给线程的UncaughtExceptionHandler。</p><p>定义一个全局异常处理器与普通的异常处理器没有区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineExceptionHandler &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Global Coroutine exception:<span class="hljs-variable">$exception</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 关键在于我们需要在classpath目录下创建META-INF/services目录，在其中创建一个名为kotlinx.coroutines.CoroutineExceptionHandler的文件，文件的内容是全局异常处理器的全类名。</p><h3 id="取消检查"><a href="#取消检查" class="headerlink" title="取消检查"></a>取消检查</h3><p>协程中挂起函数可以通过suspendCancellableCoroutine来响应所在协程的取消转台，那么没有挂起点的话如何取消呢？例如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyTo</span><span class="hljs-params">(<span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>, bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    <span class="hljs-keyword">var</span> bytesCopied: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">val</span> buffer = ByteArray(bufferSize)<br>    <span class="hljs-keyword">var</span> bytes = read(buffer)<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, bytes)<br>        bytesCopied += bytes<br>        bytes = read(buffer)<br>    &#125;<br>    <span class="hljs-keyword">return</span> bytesCopied<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以效仿线程的取消，在while循环内设置一个状态监听，这里我们可以监听父协程的存活状态来判断是否取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@OptIn(InternalCoroutinesApi::class)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> InputStream.<span class="hljs-title">copyToSuspend</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">out</span>: <span class="hljs-type">OutputStream</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    bufferSize: <span class="hljs-type">Int</span> = DEFAULT_BUFFER_SIZE</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">val</span> job = coroutineContext[Job]<br>    <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>        job?.let &#123; it.takeIf &#123; it.isActive &#125; ?: <span class="hljs-keyword">throw</span>  job.getCancellationException() &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实际上这里还有更简便的方法，那就是<strong>yield</strong>函数。yield函数内部会调用CoroutineContext#checkCompletion函数来检查协程是否存活：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()  <span class="hljs-comment">// 检查协程是否存活</span><br>    <span class="hljs-keyword">val</span> cont = uCont.intercepted() <span class="hljs-keyword">as</span>? DispatchedContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">if</span> (!cont.dispatcher.isDispatchNeeded(context)) &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-keyword">if</span> (cont.yieldUndispatched()) COROUTINE_SUSPENDED <span class="hljs-keyword">else</span> <span class="hljs-built_in">Unit</span><br>    &#125;<br>    cont.dispatchYield(<span class="hljs-built_in">Unit</span>)<br>    COROUTINE_SUSPENDED<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineContext.<span class="hljs-title">checkCompletion</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">get</span>(Job)<br>    <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) <span class="hljs-keyword">throw</span> job.getCancellationException()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这点与线程的yield函数不同，线程的yield函数仅让出线程的执行权，并不会进行中断状态检查。</p><h3 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h3><p>官方提供了两个api用于超时取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> user = withTimeout(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时抛出取消异常</span><br>        getUserSuspend()<br>    &#125;<br>    <span class="hljs-keyword">val</span> userOrNull = withTimeoutOrNull(<span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 超时返回null</span><br>        getUserSuspend()<br>    &#125;<br>    println(user)<br>    println(userOrNull)<br>&#125;.join()<br></code></pre></div></td></tr></table></figure><h3 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h3><p>官方框架提供一个名为NonCancellable的上下文实现用于禁止作用范围内的协程被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">yield()<br>withContext(NonCancellable) &#123; <span class="hljs-comment">// 禁止被取消</span><br>    delay(<span class="hljs-number">10000L</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="热数据通道Channel"><a href="#热数据通道Channel" class="headerlink" title="热数据通道Channel"></a>热数据通道Channel</h2><p>Channel用于连接协程实现协程间的通信，它实际上就是一个并发安全的队列，用法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><br><span class="hljs-keyword">val</span> producer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        channel.send(i++)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = channel.receive()<br>        println(element)<br>    &#125;<br>&#125;<br>producer.join()<br>consumer.join()<br></code></pre></div></td></tr></table></figure><p>这里使用channel实现了一个简单的生产消费者模式，producer中每隔1s向Channel发送一个数字，而consumer一直在读取Channel来读取这个数字并打印。channel.receive必然是挂起的，那么channel.send一定是个挂起函数吗？</p><h3 id="Channel的容量"><a href="#Channel的容量" class="headerlink" title="Channel的容量"></a>Channel的容量</h3><p>前面说了channel本质是个队列，那么队列是有空间的，一但空间不足就可能会出现两种情况，阻塞或者直接抛异常。send在发送消息时，队列的缓冲区也可能会满，满了之后send就需要挂起协程等待外部调用receive取走元素了。来看下Channel缓冲区的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> <span class="hljs-title">Channel</span><span class="hljs-params">(capacity: <span class="hljs-type">Int</span> = RENDEZVOUS)</span></span>: Channel&lt;E&gt; =<br>    <span class="hljs-keyword">when</span> (capacity) &#123;<br>        RENDEZVOUS -&gt; RendezvousChannel()<br>        UNLIMITED -&gt; LinkedListChannel()<br>        CONFLATED -&gt; ConflatedChannel()<br>        BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY)<br>        <span class="hljs-keyword">else</span> -&gt; ArrayChannel(capacity)<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>根据传入的容量值不同，这里创建了四种不同的Channel：</p><ul><li><strong>RendezvousChannel</strong>：缓冲区大小为0或者说没有缓冲区的Channel。这意味着send调用后会马上挂起直到receive被调用，receive调用后也会马上挂起协程直到另一个协程调用send。</li><li><strong>LinkedListChannel</strong>：缓冲区是一个的LinkedList，它的send永远不会挂起协程，同时offer总是返回true，这意味着它“来者不拒”，这点跟LinkedBlockingQueue有点类似。</li><li><strong>ConflatedChannel</strong>：缓冲区仅保留最近send过来的一个元素。send函数不会挂起协程，但仅保留最近的send的一个元素，这意味这如果receive调用时机晚了会丢失早先send的数据。</li><li><strong>ArrayChannel</strong>：接收一个值作为缓冲区大小，效果类似于ArrayBlockingQueue，缓冲区满了Sender挂起，缓冲区空了Receiver挂起。</li></ul><h3 id="迭代Channel"><a href="#迭代Channel" class="headerlink" title="迭代Channel"></a>迭代Channel</h3><p>Channel重写的Iterator操作符，因此可以进行迭代。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> iterator = channel.iterator()<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">val</span> element = iterator.next()<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = GlobalScope.launch &#123;<br>    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> channel) &#123;<br>        println(element)<br>        delay(<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="produce和actor"><a href="#produce和actor" class="headerlink" title="produce和actor"></a>produce和actor</h3><p>可以使用produce或者actor快速构建一个生产者或者消费者协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer: ReceiveChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.produce &#123;<br>    repeat(<span class="hljs-number">100</span>) &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        send(it)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> consumer: SendChannel&lt;<span class="hljs-built_in">Int</span>&gt; = GlobalScope.actor &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> element = receive()<br>        println(element)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ReceiveChannel和SendChannel是Channel的父接口，分别定义了receive和send方法。produce构造除了ProducerCoroutine对象，该类是Job的实现类之一，主要工作是在协程结束或被取消时关闭Channel，send同理。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerCoroutine</span>&lt;<span class="hljs-type">E</span>&gt;</span>(<br>    parentContext: CoroutineContext, channel: Channel&lt;E&gt;<br>) : ChannelCoroutine&lt;E&gt;(parentContext, channel, active = <span class="hljs-literal">true</span>), ProducerScope&lt;E&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">super</span>.isActive<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">(value: <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        _channel.close()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>, handled: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> processed = _channel.close(cause)<br>        <span class="hljs-keyword">if</span> (!processed &amp;&amp; !handled) handleCoroutineException(context, cause)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Channel的关闭"><a href="#Channel的关闭" class="headerlink" title="Channel的关闭"></a>Channel的关闭</h3><p>Channel存在关闭的概念，所以被称为<strong>热数据流</strong>。当我们调用Channel的close方法时，它会立即停止接收元素，这个时候它的<strong>isClosedForSend</strong>会立即返回true，该属性表示发送端已经关闭。当Channel缓冲区的所有元素都被读取后，<strong>isClosedForReceive</strong>会返回true，表示接收端也已经关闭。</p><p>跟I/O流一样，我们需要在合适的时候关闭Channel，如果不关闭则会导致接收端一直处于挂起等待状态。对于单向通信的Channel，由发送端处理关闭较为合适；对于双向通信的Channel则协商关闭。</p><h3 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h3><p>前面的Channel发送端和接收端可能存在一对多的情况，不过同一元素只会被一个接收端接收到。不过<strong>BroadcastChannel</strong>中多个接收者不存在互斥行为。可以通过BroadcastChannel方法来构建一个BroadcastChannel对象，再通过这个对象来获取ReceiveChannel。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建BroadcastChannel</span><br><span class="hljs-keyword">val</span> broadcastChannel = BroadcastChannel&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// 获取一个ReceiveChannel</span><br><span class="hljs-keyword">val</span> receiveChannel = broadcastChannel.openSubscription()<br></code></pre></div></td></tr></table></figure><p>或者可以使用普通的channel转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Int</span>&gt;()<br><span class="hljs-keyword">val</span> broadcastChannel = channel.broadcast(<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p>Channel.broadcast方法实际就是读取原Channel的元素然后再通过广播发送。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E&gt;</span> ReceiveChannel<span class="hljs-type">&lt;E&gt;</span>.<span class="hljs-title">broadcast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    capacity: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.LAZY</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: BroadcastChannel&lt;E&gt; =<br>    GlobalScope.broadcast(Dispatchers.Unconfined, capacity = capacity, start = start, onCompletion = consumes()) &#123;<br>        <span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span><span class="hljs-symbol">@broadcast</span>) &#123; <span class="hljs-comment">// 读取原Channel</span><br>            send(e)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>有一点需要注意的是，由于这里读取了原Channel，所以如果有其他协程也在读取这个Channel，可能会存在互斥的情况。</p><h3 id="Channel的内部结构"><a href="#Channel的内部结构" class="headerlink" title="Channel的内部结构"></a>Channel的内部结构</h3><p>支持Channel胜任并发场景的是其内部数据结构。本节来探讨缓冲区是<strong>链表</strong>和<strong>数组</strong>的版本。链表版本的定义主要是在<strong>AbstractSendChannel</strong>中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSendChannel</span>&lt;<span class="hljs-type">E</span>&gt; : <span class="hljs-type">SendChannel</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> queue = LockFreeLinkedListHead()<br>    ··· ···<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>LockFreeLinkedListHead</strong>本身是一个双向链表的节点，Channel把它收尾相连形成循环链表，这个queue作为哨兵节点，当有新的节点插入时就插入到queue的前面，相当于在整个链表的最后插入元素。该链表节点的关键结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockFreeLinkedListNode</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _next = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed | OpDescriptor</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _prev = atomic&lt;Any&gt;(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// Node | Removed</span><br></code></pre></div></td></tr></table></figure><p><strong>_next</strong> 和 <strong>_prev</strong>表示节点的向前引用和向后引用，其使用atomic包裹仅能进行原子操作。不过CAS操作通常只能修改一个引用，对于需要同时修改前后节点引用的情形是不适用的。当我们在单链表中插入节点时，也会存在并发问题，如下图所示。</p><p><img src="/img/singly_linked_list_concurrently_insert.png" alt="单链表并发插入问题"></p><p>而无锁链表LockFreeLinked的实现是引入一个prev来辅助完成。A被移除时不会像单链表一样直接断开指针， 而是现将A.next和A.prev标记为Removed，指向的节点不变，因此即便同时有另一个线程插入一个节点X，链表同样有机会在后续通过CAS算法实现前后节点引用的修复。具体实现参照LockFreeLinkedListNode在JVM上的实现。</p><p>而对于数组版本，ArrayChannel相对就比较简单了，其内部维护了一个数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = ReentrantLock()<br><span class="hljs-comment">// 缓冲区大于8时会先分配大小为8的数组，之后再进行扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> buffer: Array&lt;Any?&gt; = arrayOfNulls&lt;Any?&gt;(min(capacity, <span class="hljs-number">8</span>))<br></code></pre></div></td></tr></table></figure><p>对这个数组的读写操作都会使用可重入锁ReentrantLock进行加锁。</p><h2 id="冷数据流Flow"><a href="#冷数据流Flow" class="headerlink" title="冷数据流Flow"></a>冷数据流Flow</h2><p>我们现在大多数App都使用了RxJava作为异步框架，而RxJava的核心就是响应式编程模型。Flow就是Kotlin协程与响应式编程模型结合的产物。</p><h3 id="认识Flow"><a href="#认识Flow" class="headerlink" title="认识Flow"></a>认识Flow</h3><p>先来使用flow创建发送序列，这里对比一下官方的序列生成器<strong>sequence</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intsSeq = sequence &#123;  <span class="hljs-comment">// 不支持设置协程上下文</span><br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        yield(it)<br>        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 编译报红</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>        delay(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// 可调用外部挂起函数</span><br>    &#125;<br>&#125;<br>intFlow.flowOn(Dispatchers.IO)  <span class="hljs-comment">// 指定在IO线程生成</span><br></code></pre></div></td></tr></table></figure><p>我们知道，sequence不支持传入协程上下文，因而无法对协程进行线程调度。而受<strong>SequenceScope</strong>的<strong>RestrictsSuspension</strong>注解的影响，其内部也无法调用外部的的挂起函数。这其中其实是有个因果关系的，假设sequence支持调用delay，由于sequence本身不支持调度，所以会导致delay执行后会有切换线程的副作用。而Flow则没有这么多限制了，我们可以内部使用emit发送元素，可调用外部的挂起函数，同时也可以使用flowOn函数进行线程调度。</p><h3 id="Flow的线程切换"><a href="#Flow的线程切换" class="headerlink" title="Flow的线程切换"></a>Flow的线程切换</h3><p>Flow的线程切换使用<strong>Flow.flowOn</strong>方法，这个方法与RxJava的subscribeOn和observeOn切换协程的方式十分类似，下面是对比代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123; e -&gt;<br>        it.onNext(e)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>    it.onComplete()<br>&#125;<br>    .subscribeOn(Schedulers.io())  <span class="hljs-comment">// 第一次有效</span><br>    .subscribeOn(Schedulers.computation())<br>    .observeOn(AndroidSchedulers.mainThread())<br>    .subscribe &#123;<br>        println(it)  <span class="hljs-comment">// Android主线程</span><br>    &#125;<br><br>flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)  <span class="hljs-comment">// io线程</span><br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO) <span class="hljs-comment">// 第一次有效</span><br>    .flowOn(Dispatchers.Default)<br>    .collect &#123; <br>        println(it)  <span class="hljs-comment">// 与所在协程调度器一致</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到flowOn方法与RxJava的subscribeOn方法十分类似，都是会只会影响其之前的代码，而且都是只有第一次调用是有效的，这个其实跟collect或者subscribe的逆序调用执行有关，代码顺序中第一次调用flowOn或者subscribeOn其实是最后才执行，所以它们是有效的，这里不深究了。另外区别是RxJava中可以使用observeOn方法来调度subscribe回调的执行线程，看起来似乎Flow的collect没有类似的调度方法，其实不然，Flow的collect是个挂起函数，其调度线程跟外部的协程调度在哪个线程是一致的。</p><h3 id="冷数据流"><a href="#冷数据流" class="headerlink" title="冷数据流"></a>冷数据流</h3><p>与RxJava类似，Flow的生产总是在消费被调用后才会执行，并且多次调用会多次生产。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .flowOn(Dispatchers.IO)<br>    .flowOn(Dispatchers.Default)<br><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br>intFlow.collect &#123; println(it) &#125;  <span class="hljs-comment">// 1 2 3</span><br></code></pre></div></td></tr></table></figure><p>所谓的冷数据流，就是只有消费时才会生产的数据流，这一点与Channel刚好相反。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Flow异常处理比较简单直接，直接调用catch函数即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    emit(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">&quot;Div 0&quot;</span>)  <span class="hljs-comment">// 抛出一个异常</span><br>&#125;.<span class="hljs-keyword">catch</span> &#123; t: Throwable -&gt;<br>    println(<span class="hljs-string">&quot;caught error : <span class="hljs-variable">$t</span>&quot;</span>)<br>&#125;.onCompletion &#123; <span class="hljs-comment">// Flow完成后回调</span><br>    println(<span class="hljs-string">&quot;onCompletion.&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用catch函数捕获flow中抛出的异常，这里需要注意的是catch<strong>只能捕获上游的异常</strong>，如果没有catch，则会在消费时抛出。</p><p><strong>onCompletion</strong>方法的作用类似于RxJava中Subscriber的OnComplete，作为整个Flow完成的回调使用，无论是否存在未捕获的异常都会被调用。</p><h3 id="末端操作符"><a href="#末端操作符" class="headerlink" title="末端操作符"></a>末端操作符</h3><p>前面我们使用了collect来消费Flow的数据，像这种包含消费含义的操作符称为<strong>末端操作符</strong>。Flow的末端操作符大体可以分为两类：</p><ul><li>集合类型转换操作符，包括toList、toSet等。</li><li>聚合操作符，包括将Flow规约到单值的reduce、fold等操作；还有获得单个元素的操作符，包括single、singleOrNull、first等。</li></ul><h3 id="分离Flow的消费和触发"><a href="#分离Flow的消费和触发" class="headerlink" title="分离Flow的消费和触发"></a>分离Flow的消费和触发</h3><p>我们除了可以在collect处消费Flow的元素之外，还可以通过onEach来消费元素，而collect只需要作为触发点就可以。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intFlow = flow &#123;<br>    (<span class="hljs-number">1.</span><span class="hljs-number">.3</span>).forEach &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .onEach &#123; println(it) &#125;  <span class="hljs-comment">// onEach中消费</span><br><br>intFlow.collect()  <span class="hljs-comment">// collect触发生产和消费</span><br></code></pre></div></td></tr></table></figure><p>另外Flow中还提供了一个launchIn方法指定一个协程作用域，使其消费在指定的协程中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123; intFlow.collect() &#125;<br>intFlow.launchIn(GlobalScope) <span class="hljs-comment">// 两种方法是一样的</span><br></code></pre></div></td></tr></table></figure><h3 id="Flow的取消"><a href="#Flow的取消" class="headerlink" title="Flow的取消"></a>Flow的取消</h3><p>Flow不存在取消的概念，因为其依托于外部协程的生命周期，所以要想取消一个Flow只需要取消其外部协程即可。</p><h3 id="其他Flow的创建方式"><a href="#其他Flow的创建方式" class="headerlink" title="其他Flow的创建方式"></a>其他Flow的创建方式</h3><p>之前我们使用了flow{…}来创建一个Flow，这种方式的缺点是当中无法随意切换调度器，如果在当中使用调度器会报错，因为emit函数不是线程安全的。如果需要在生成元素时切换调度器可以使用ChannelFlow，通过channelFlow{…}来创建。</p><h3 id="Flow的背压"><a href="#Flow的背压" class="headerlink" title="Flow的背压"></a>Flow的背压</h3><p>只要是响应式编程就会有背压问题，即生产者生产元素的速率远高于消费者的处理速率时，消费者还未处理上一个数据新数据就已经到达的情况。</p><p>为了保证数据不丢失，我们可以为Flow添加缓冲区。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;.buffer() <span class="hljs-comment">// 可以指定容量</span><br></code></pre></div></td></tr></table></figure><p>不过如果只是单纯添加缓冲，缓冲区迟早也会出现数据积压，只是治标不治本。</p><p>要从根本上解决背压问题，除了直接优化消费者的性能外，还可以采用一些取舍手段。</p><p>第一种是<strong>conflate</strong>。与Channel中的Conflate模式一直，新数据会覆盖老数据，使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">flow &#123;<br>    List(<span class="hljs-number">100</span>) &#123;<br>        emit(it)<br>    &#125;<br>&#125;<br>    .conflate()<br>    .collect &#123;<br>        println(<span class="hljs-string">&quot;Collecting <span class="hljs-variable">$it</span>&quot;</span>)<br>        delay(<span class="hljs-number">100</span>)<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> collected&quot;</span>)<br>    &#125;<br><br><span class="hljs-comment">// 输出</span><br>Collecting <span class="hljs-number">0</span><br><span class="hljs-number">0</span> collected<br>Collecting <span class="hljs-number">99</span><br><span class="hljs-number">99</span> collected<br></code></pre></div></td></tr></table></figure><p>上述代码快速发送了100个元素，最后接收到的只有2个。</p><p>第二种是<strong>collectLasted</strong>，作用是只处理最新的数据。看起来似乎与conflate是一样的，其实不然，collectLasted不会进行数据的覆盖，而是在当前数据还未处理完而新的数据来的时候，当前数据的处理逻辑会被取消，转而处理新数据。</p><p>除了collectLasted之外，还有<strong>mapLastest</strong>、<strong>flatMapLatest</strong>等。</p><h3 id="Flow的变换"><a href="#Flow的变换" class="headerlink" title="Flow的变换"></a>Flow的变换</h3><p>Flow与RxJava的Observable一样，可以使用map、flattenConcat等函数来进行变换。</p><h2 id="select表达式"><a href="#select表达式" class="headerlink" title="select表达式"></a>select表达式</h2><p>select在Java NIO里很常见，Kotlin协程中的select用于同时等待多个挂起函数，并可以选择第一个恢复的gaug挂起。</p><h3 id="复用多个await"><a href="#复用多个await" class="headerlink" title="复用多个await"></a>复用多个await</h3><p>假设我们有个常见是分别从本地和网络获取数据，哪个先返回就用哪个，那么如何做到这一点呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromApi</span><span class="hljs-params">(login: <span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    gitHubServiceApi.getUserSuspend(login)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">getUserFromLocal</span><span class="hljs-params">(login:<span class="hljs-type">String</span>)</span></span> = async(Dispatchers.IO)&#123;<br>    File(localDir, login).takeIf &#123; it.exists() &#125;?.readText()?.let &#123; gson.fromJson(it, User::<span class="hljs-keyword">class</span>.java) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以使用select来同时启动这两个挂起函数，并最终返回先恢复的那个挂起函数返回的数据，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">GlobalScope.launch &#123;<br>    <span class="hljs-keyword">val</span> localDeferred = getUserFromLocal(login)<br>    <span class="hljs-keyword">val</span> remoteDeferred = getUserFromApi(login)<br><br>    <span class="hljs-keyword">val</span> userResponse = select&lt;Response&lt;User?&gt;&gt; &#123;<br>        localDeferred.onAwait &#123; Response(it, <span class="hljs-literal">true</span>) &#125;<br>        remoteDeferred.onAwait &#123; Response(it, <span class="hljs-literal">false</span>) &#125;<br>    &#125;<br>    ...<br>&#125;.join()<br></code></pre></div></td></tr></table></figure><p>我们没有直接调用await，而是使用<strong>Deferred#onAwait</strong>方法在select中注册了回调，select总是会立即调用最先返回的事件的回调。</p><h3 id="复用多个Channel"><a href="#复用多个Channel" class="headerlink" title="复用多个Channel"></a>复用多个Channel</h3><p>对于多个Channel的情况，也比较类似：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">val channels = List(<span class="hljs-number">10</span>) &#123; Channel<span class="hljs-params">&lt;Int&gt;</span>() &#125;<br><br>select<span class="hljs-params">&lt;Int?&gt;</span> &#123;<br>    channels.<span class="hljs-class">forEach </span>&#123; channel -&gt;<br>        channel.<span class="hljs-class">onReceive </span>&#123; it &#125;<br>        <span class="hljs-comment">// OR</span><br>        channel.<span class="hljs-class">onReceiveOrNull </span>&#123; it &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于 onReceive，如果Channel被关闭，select会直接抛出异常；而对于 onReceiveOrNull如果遇到Channel被关闭的情况，it的值就是null。</p><h3 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h3><p>如何知道哪些事件可以被select呢？实际上所有能够被select的事件都是SelectClauseN类型，包括：</p><ul><li><p>SelectClause0：对应事件没有返回值，例如join没有返回值，那么onJoin就是SelectClauseN类型。使用时，onJoin的参数是一个无惨函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    job.onJoin &#123; println(<span class="hljs-string">&quot;Join resumed!&quot;</span>) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>SelectClause1：对应事件有返回值，前面的onAwait和onReceive都是此类情况。</p></li><li><p>SelectClause2：对应事件有返回值，此外还需要一个额外的参数作为回调，例如Channel.onSend有两个参数，第一个表示即将发送的值，第二个是发送成功的回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">List(<span class="hljs-number">100</span>) &#123; element -&gt;<br>    select&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>        channels.forEach &#123; channel -&gt;<br>            channel.onSend(element) &#123; sentChannel -&gt;<br>                println(<span class="hljs-string">&quot;send on  <span class="hljs-variable">$sentChannel</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>综上，如果想要确认挂起函数是否支持select，只需要查看其是否存在对应的SelectClauseN类型可回调即可。</p><h3 id="使用Flow实现多路复用"><a href="#使用Flow实现多路复用" class="headerlink" title="使用Flow实现多路复用"></a>使用Flow实现多路复用</h3><p>多数情况下，我们可以通过构造何时的Flow来实现多路复用的效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> login = <span class="hljs-string">&quot;...&quot;</span><br>    listOf(::getUserFromApi, ::getUserFromLocal)  <span class="hljs-comment">// list中存放函数引用</span><br>        .map &#123; function -&gt;<br>            function.call(login)  <span class="hljs-comment">// 调用函数，得到返回值</span><br>        &#125;<br>        .map &#123; deferred -&gt;<br>            flow &#123; emit(deferred.await()) &#125;  <span class="hljs-comment">// 创建Flow，发送deferred.await的返回结果</span><br>        &#125;<br>        .merge() <span class="hljs-comment">// 多个Flow合并成一个Flow</span><br>        .onEach &#123; user -&gt; <span class="hljs-comment">// 使用onEach来消费</span><br>            println(<span class="hljs-string">&quot;Result: <span class="hljs-variable">$user</span>&quot;</span>)<br>        &#125;.launchIn(<span class="hljs-keyword">this</span>)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码的关键之处在于，我们为每一个deferred都创建了一个单独的Flow，并在Flow内部发送了deferred.await()返回的结果，最后再通过<strong>merge</strong>函数合并成一个Flow来进行处理。</p><p><img src="/img/flow_merge.png" alt="使用merge合并Flow"></p><h2 id="协程的并发工具"><a href="#协程的并发工具" class="headerlink" title="协程的并发工具"></a>协程的并发工具</h2><p>协程框架提供了一些并发安全的工具，包括：</p><ul><li><p><strong>Channel</strong>：并发安全的消息通道。</p></li><li><p><strong>Mutex</strong>：轻量级锁，在获取不到锁时不会阻塞线程而是挂起等待锁的释放。代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> mutex = Mutex()<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        mutex.withLock &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></div></td></tr></table></figure></li><li><p>Semaphore：轻量级信号量，信号量可以有多个，协程在获取到信号量后即可执行并发操作。当Semaphore的参数为1时，效果等价于Mutex，代码示例如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> semaphore = Semaphore(<span class="hljs-number">1</span>)<br>List(<span class="hljs-number">1000</span>) &#123;<br>    GlobalScope.launch &#123;<br>        semaphore.withPermit &#123;<br>            count++<br>        &#125;<br>    &#125;<br>&#125;.joinAll()<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（四）——Kotlin协程框架初探（二）</title>
    <link href="/2021/02/21/dd192d66/"/>
    <url>/2021/02/21/dd192d66/</url>
    
    <content type="html"><![CDATA[<p>本篇继续探讨协程的取消、异常处理以及作用域问题。</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><p>协程的取消本质是协作式的取消，这点跟线程的中断一致，除了自身状态置为取消外，也需要协程体的执行逻辑能够检查状态的变化来响应取消。</p><h3 id="完善协程的取消逻辑"><a href="#完善协程的取消逻辑" class="headerlink" title="完善协程的取消逻辑"></a>完善协程的取消逻辑</h3><p>我们的Job目前还有两个函数空着没有实现，分别是cancle和invokeOnCancel。后者的实现与doOnCompleted类似，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CancellationHandlerDisposable(<span class="hljs-keyword">this</span>, onCancel)<br><br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Cancelling)?.let &#123; onCancel() &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellationHandlerDisposable</span></span>(<span class="hljs-keyword">val</span> job: Job, <span class="hljs-keyword">val</span> onCancel: OnCancel) : Disposable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cancel函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> preState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Cancelling()<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preState <span class="hljs-keyword">is</span> CoroutineState.Incomplete) &#123;<br>        preState.notifyCancellation()<br>        preState.clear()<br>    &#125;<br>    parentCancelDisposable?.disposable()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意这里使用了getAndUpdate来流转状态，也就是说我们拿到的是旧状态，旧状态如果是Incomplete则一定发生了状态流转，调用notifyCancellation来通知取消事件。</p><h3 id="支持取消的挂起函数"><a href="#支持取消的挂起函数" class="headerlink" title="支持取消的挂起函数"></a>支持取消的挂起函数</h3><p>通常来讲，一个发生了事实上挂起的挂起函数如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nonCancellableFunction</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br><br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br><br>    completableFuture.thenApply &#123;<br>        continuation.resume(it)<br>    &#125;.exceptionally &#123;<br>        continuation.resumeWithException(it)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种情况下，及时所在的协程被取消，我们也无法取消内部的异步任务CompletableFuture。为了能够取消内部的异步任务，我们需要Continuation提供一个取消状态和回调，在协程取消，回调被通知时取消掉CompletableFuture，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancellableFunction</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br>    continuation.invokeOnCancellation &#123;<br>        completableFuture.cancel(<span class="hljs-literal">true</span>)<br>    &#125;<br>   ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这个<strong>suspendCancellableCoroutine</strong>要如何实现呢？我们可以参考官方框架中的<strong>suspendCoroutine</strong>实现来做一点修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-meta">@InlineOnly</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutine</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;<br>    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;<br>        <span class="hljs-keyword">val</span> safe = SafeContinuation(c.intercepted())<br>        block(safe)<br>        safe.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>suspendCoroutineUninterceptedOrReturn的参数是一个函数，这个函数有一个参数Continuation，实际上就是我们前面文章说的编译后生成的匿名内部类的实例。SafeContinuation的作用是确保传入的Continuation对象的恢复调用只被执行一次。如何确保的呢？当block(safe)执行过程中调用了Continuation的恢复调用时，safe.getOrThrow就会获取到结果，而不是<strong>COROUTINE_SUSPENDED</strong>，这样协程就不会真正挂起了。</p><p>那么我们要对 Continuation进行改造使其支持取消的话，就要替换到SafeContinuation了，即需要实现一下效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: T = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> cancellable = CancellableContinuation(continuation.intercepted())<br>    block(cancellable)<br>    cancellable.getResult()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关键就是CancellableContinuation的实现了。</p><h3 id="CancellableContinuation的实现"><a href="#CancellableContinuation的实现" class="headerlink" title="CancellableContinuation的实现"></a>CancellableContinuation的实现</h3><p>CancellableContinuation需要具备以下能力：</p><ul><li>支持通过invokeOnCancellation注册取消回调</li><li>支持监听对应协程的取消状态</li><li>具备SafeContinuation的功能</li></ul><p>这样的话，CancellableContinuation必然是有状态的，同样我们先给出状态的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelState</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> InComplete : CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelHandler</span></span>(<span class="hljs-keyword">val</span> onCancel: OnCancel): CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CancelState()<br>    <span class="hljs-keyword">object</span> Cancelled : CancelState()<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelDecision</span> </span>&#123;<br>    UNDECIDED, SUSPENDED, RESUMED<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的状态定义跟协程的状态时一致的，这里不多说。CancelDecision枚举用于标记对应的挂起函数是否同步返回了。</p><p>CancellableContinuation需要包装一个Continuation，这里我们直接使用接口代理即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CancelState&gt;(CancelState.InComplete)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> decision = AtomicReference(CancelDecision.UNDECIDED)<br><br>    <span class="hljs-keyword">val</span> isCompleted: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            CancelState.InComplete,<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; <span class="hljs-literal">true</span><br>        &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先看invokeOnCancellation的实现，如果当前是Incomplete状态，那么就可以注册回调，如果是Cancelled状态就直接调用回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancellation</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            CancelState.InComplete -&gt; CancelState.CancelHandler(onCancel)<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;It&#x27;s prohibited to register multiple handlers.&quot;</span>)<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newState <span class="hljs-keyword">is</span> CancelState.Cancelled) &#123;<br>        onCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来尝试去监听对应协程的取消事件，可以通过协程上下文来获取对应协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installCancelHandler</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">val</span> parent = continuation.context[Job] ?: <span class="hljs-keyword">return</span> <span class="hljs-comment">// 获取协程</span><br>    parent.invokeOnCancel &#123;<br>        doCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>取消回调中通过doCancel方法来完成状态的流转。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> prevState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>            CancelState.InComplete -&gt; &#123;<br>                CancelState.Cancelled<br>            &#125;<br>            CancelState.Cancelled,<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (prevState <span class="hljs-keyword">is</span> CancelState.CancelHandler) &#123;<br>        prevState.onCancel()<br>        resumeWithException(CancellationException(<span class="hljs-string">&quot;Cancelled.&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于两种未完成的状态，流转为Cancelled，如果刘赚钱有回调注册，就调用回调通知取消事件。</p><p>由于挂起点发生了真正的挂起后注册回调才有意义，因此无需急于注册取消回调，在getResult中注册即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    installCancelHandler()  <span class="hljs-comment">// 注册取消回调</span><br>    <span class="hljs-keyword">if</span>(decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.SUSPENDED))<br>        <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>        CancelState.InComplete -&gt; COROUTINE_SUSPENDED<br>        CancelState.Cancelled -&gt; <span class="hljs-keyword">throw</span> CancellationException(<span class="hljs-string">&quot;Continuation is cancelled.&quot;</span>)<br>        <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>            (currentState <span class="hljs-keyword">as</span> CancelState.Complete&lt;T&gt;).let &#123;<br>                it.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: it.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先注册了协程的取消回调，接着通过CAS操作判断当前decision是否为<strong>UNDECIDED</strong>，如果是UNDECIDED则表示结果还未就绪，将其设置为<strong>SUSPENDED</strong>并返回挂起标志位<strong>COROUTINE_SUSPENDED</strong>。否则decision只可能为RESUMED，即挂起函数没有真正挂起并且结果已经可以获取，那么就会在Complete分支返回结果，如果未完成则会返回挂起标志COROUTINE_SUSPENDED。</p><p>接着是resumeWith的实现。该函数被调用表示挂起函数恢复执行，此时如果dicision为<strong>UNDECIDED</strong>，表示挂起函数同步返回了，后面通过getResult来获取结果，否则只能为dicision只能为<strong>SUSPENDED</strong>，即已挂起。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> &#123;<br>        decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是UNDECIDED，则不用考虑并发安全问题</span><br>            state.<span class="hljs-keyword">set</span>(CancelState.Complete(result.getOrNull(), result.exceptionOrNull()))<br>        &#125;<br>        decision.compareAndSet(CancelDecision.SUSPENDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是SUSPENDED，使用updateAndGet来更新状态并获取结果</span><br>            state.updateAndGet &#123; prev -&gt;<br>                <span class="hljs-keyword">when</span> (prev) &#123;<br>                    <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed.&quot;</span>)<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        CancelState.Complete(result.getOrNull(), result.exceptionOrNull())<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复delegate</span><br>            continuation.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>CancellableContinuation的状态转移如下图。</p><p><img src="/img/cancellation_state_transfer.png" alt="CancellableContinuation的状态转移"></p><h3 id="改造挂起函数"><a href="#改造挂起函数" class="headerlink" title="改造挂起函数"></a>改造挂起函数</h3><p>我们之前定义的挂起函数都是使用suspendCoroutine函数来实现挂起，若要响应协程的取消，需要将其替换成上面实现好的suspendCancellableCoroutine。</p><p>以delay函数为例，改造后的delay函数如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(time: <span class="hljs-type">Long</span>, unit: <span class="hljs-type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    suspendCancellableCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> future = executor.schedule(&#123; continuation.resume(<span class="hljs-built_in">Unit</span>) &#125;, time, unit)<br>        continuation.invokeOnCancellation &#123; future.cancel(<span class="hljs-literal">true</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的异常处理"><a href="#协程的异常处理" class="headerlink" title="协程的异常处理"></a>协程的异常处理</h2><p>异常处理是异步程序需要解决的关键问题。</p><h3 id="处理协程的未捕获异常"><a href="#处理协程的未捕获异常" class="headerlink" title="处理协程的未捕获异常"></a>处理协程的未捕获异常</h3><p>先定义一个异常处理器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>要处理协程的未捕获异常，我们需要在AbstractCoroutine中定义一个子类可见的函数，提供给子类复写，返回值为true表示异常已处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>我们以AbstractCoroutine子类StandaloneCoroutine为例，StandaloneCoroutine由launch启动，协会本身没有返回结果。我们虚妄它能够在遇到未捕获异常时，调用自身的异常处理器进行处理，如果没有异常处理器就抛出给所在线程的uncaughtExceptionHandler来处理，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">super</span>.handleJobException(e)<br>    context[CoroutineExceptionHandler]?.handleException(context, e) ?: Thread.currentThread()<br>        .let &#123; it.uncaughtExceptionHandler.uncaughtException(it, e) &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="取消异常的特别处理"><a href="#取消异常的特别处理" class="headerlink" title="取消异常的特别处理"></a>取消异常的特别处理</h3><p>协程的取消类似于线程的中断，取消时通过抛出取消异常来实现对取消状态的相应，因此上节的未捕获异常不应该包含取消异常。只需要定义一个函数来分发异常即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span>(e)&#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; handleJobException(e)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着在resumeWith中添加异常处理逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    ··· ···<br>    (newState <span class="hljs-keyword">as</span> CoroutineState.Complete&lt;T&gt;).exception?.let(<span class="hljs-keyword">this</span>::tryHandleException)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的作用域"><a href="#协程的作用域" class="headerlink" title="协程的作用域"></a>协程的作用域</h2><p>协程作用域用来描述协程的作用范围，作用域既有约束作用又可以提供额外的能力。</p><h3 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h3><p>官方框架中作用域包括以下三种：</p><ol><li><strong>顶级作用域</strong>：没有父协程的协程所在的作用域。</li><li><strong>协同作用域</strong>：协程中启动新的协程，新协程未所在协程的子协程，这种情况下子协程所在的作用域默认为协同作用域。子协程抛出的未捕获异常都将传递给父协程处理，同时父协程也会被取消。</li><li><strong>主从作用域</strong>：与协程作用域在协程的父子关系一致，区别是子协程的未捕获异常将不会向上传递给父协程。</li></ol><p>父子协程之间还存在以下规则：</p><ul><li>父协程被取消，所有子协程都会被取消。</li><li>父协程需要等待子协程执行完毕才会最终进入完成状态。</li><li>子协程会继承父协程的协程上下文中的元素，如果自身有相同Key的成员，将会覆盖该Key。</li></ul><p>前面几篇文章我们已经熟悉了如何去创建一个作用域了，通常我们会将协程的启动函数定义在作用域中，同时让协程的描述类来实现作用域充当Receiver的角色，基于这两点来改造下launch函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义为CoroutineScope的扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion, completion) <span class="hljs-comment">// 带Receiver的方式启动协程</span><br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="建立父子关系"><a href="#建立父子关系" class="headerlink" title="建立父子关系"></a>建立父子关系</h3><p>前面说了，父协程取消之后，子协程也需要被取消，因此我们要对AbstractCoroutine稍加改造，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> parentJob = context[Job]<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> parentCancelDisposable : Disposable? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">init</span> &#123;<br>    ··· ···<br>    parentCancelDisposable = parentJob?.invokeOnCancel &#123; <br>        cancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过协程上下文来获取父协程，如果父协程存在，那么就需要注册一个取消回调，当父协程取消时取消掉当前协程。</p><h3 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h3><p>我们对launch函数进行改造之后，需要一个作用域来调用launch函数才能启动一个协程，但作用域又是在创建协程过程中产生的。针对这个问题，我们需要一个特殊的作用域，这个作用域不需要依赖父作用域来产生，这个作用域就叫做<strong>顶级作用域</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> scopeContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br><br>GlobalScope.launch&#123;<br>  ··· ···<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于协程描述类AbstractCoroutine本身实现了CoroutineScope，因此由GlobalScope.launch启动的协程体内部我们可以直接创建新的子协程。</p><h3 id="实现异常传播"><a href="#实现异常传播" class="headerlink" title="实现异常传播"></a>实现异常传播</h3><p>接下来考虑一下子协程如何将异常向上传递。按照现有的实现，我们已经将该异常处理传递到tryHandleException中，对于非取消异常的情况都交给了handleJobException来处理。按照协同作用域的设计，协程遇到未捕获的异常时应当优先向上传播，如果没有父协程才自行处理。因此我们添加一个函数<strong>handleChildException</strong>用于接收子协程的异常，改造一下tryHandleException：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    cancel()  <span class="hljs-comment">// 取消父协程</span><br>    <span class="hljs-keyword">return</span> tryHandleException(e) <span class="hljs-comment">// 继续向上传递或者自己处理</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span> (e) &#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; (parentJob <span class="hljs-keyword">as</span>? AbstractCoroutine&lt;*&gt;)?.handleChildException(e) <span class="hljs-comment">// 交给父协程处理</span><br>        ?.takeIf &#123; it &#125;<br>        ?: handleJobException(e)  <span class="hljs-comment">// 没有父协程 自行处理</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注释已经很完善了，当出现未捕获异常时，先尝试调用父协程的handleChildException来处理，否则自行处理。父协程也优先调用父协程的父协程来处理。</p><h3 id="主从作用域"><a href="#主从作用域" class="headerlink" title="主从作用域"></a>主从作用域</h3><p>协同作用域的效果就是父子协程绑定，父取消则子取消，子异常则父连坐。而主从作用域则可以避免子协程出现异常而导致父协程取消的情况。</p><p>我们只需要将上面的<strong>handleChildException</strong>方法返回false即可避免子协程将异常传递给父协程，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(context: CoroutineContext, continuation: Continuation&lt;T&gt;) :<br>    ScopeCoroutine&lt;T&gt;(context, continuation) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>也很容易去创建这样一个作用域，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">supervisorScope</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: R = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> coroutine = SupervisorCoroutine(continuation.context, continuation)<br>    block.startCoroutine(coroutine, coroutine)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主从作用域的应用场景多见于子协程为独立对等的任务实体的情况，例如Android平台的Jetpack开发包中ViewModel内置的viewModelScope就是主从作用域实现。</p><h3 id="完整的异常处理流程"><a href="#完整的异常处理流程" class="headerlink" title="完整的异常处理流程"></a>完整的异常处理流程</h3><p>引入作用域后完整的异常处理流程如下如所示。</p><p><img src="/img/complete_exception_handle.png" alt="完整的异常处理流程"></p><h3 id="父协程等待子协程完成"><a href="#父协程等待子协程完成" class="headerlink" title="父协程等待子协程完成"></a>父协程等待子协程完成</h3><p>作用域要求父协程必须等待子协程执行完才可以进入完成状态，因此父协程的resumeWith执行完成后需要检查子协程是否完成，未完成则需要注册完成回调，等待所有子协程状态流转为完成状态父协程才能触发完成回调并且流转为完成态。我们只需要新增一个等待的状态即可，状态流转如下所示。</p><p><img src="/img/scope_state_transfer.png" alt="完整的异常处理流程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——Kotlin协程框架初探（一）</title>
    <link href="/2021/02/16/b912c613/"/>
    <url>/2021/02/16/b912c613/</url>
    
    <content type="html"><![CDATA[<p>前面四篇文章我们了解了如何使用<strong>createCoroutine</strong>和<strong>startCoroutine</strong>这两个API来创建和启动简单协程，并且可以使用它们来构造复合协程。但客观的说，这两个API并不太适合直接在业务开发中使用，所以Kotlin协程为开发者提供了一些更贴近业务的复合协程API，即官方协程框架<a href="https://github.com/Kotlin/kotlinx.coroutines"><strong>kotlinx.coroutines</strong></a>。后面几篇文章我们就来尝试窥探一下这个庞大的框架的一角。</p><h2 id="协程的描述"><a href="#协程的描述" class="headerlink" title="协程的描述"></a>协程的描述</h2><p>对于协程的创建，官方框架中根据不同的目的提供了不同的构造器。</p><h3 id="协程的描述类"><a href="#协程的描述类" class="headerlink" title="协程的描述类"></a>协程的描述类</h3><p>Java中提供了线程的Java描述类Thread，通过调用<strong>Thread#start</strong>方法我们就可以通知系统启动一个线程，我们也知道<strong>Thread#run</strong>方法即为线程的执行代码，同时Thread也提供了类型join、interrupt、isAlive等方法来方便我们操作线程。类似的，我们也需要这样一个类来描述协程，按照官方框架的做法把它命名为Job，API设计如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;<br>        <span class="hljs-keyword">get</span>() = Job<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断协程是否扔在执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程取消回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程完成回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnCompelete</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取消协程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 与[Thread.join]类似，挂起外部协程直到当前协程完成</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>我们对协程的状态进行封装，让其状态管理更加简便。主要是<strong>未完成</strong>、<strong>已取消</strong>、<strong>已完成</strong>这三种状态。状态的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Incomplete</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cancelling</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CoroutineState()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>进一步解释下这三种状态：</p><ul><li>Incomplete：协程启动后立即进入该状态，直到完成或者被取消。</li><li>Cancelling：协程执行中被取消后进入该状态。进入该状态后，要等待协程体内部的挂起函数调用相应取消，相应后协程成功被取消或者抛出CancellationException取消，最终会流转为Complete状态。</li><li>Complete：协程执行完成进入该状态。</li></ul><h3 id="支持回调的状态"><a href="#支持回调的状态" class="headerlink" title="支持回调的状态"></a>支持回调的状态</h3><p>注册回调时，需要根据当前状态的不同采取不同的处理方式，回调注册的操作也必须是原子操作，否则会有状态不一致问题。跟上篇文章相同，我们在状态流转时采用元子类来处理原子操作，比加锁性能会有较大提升。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-comment">// 返回新状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用updateAndGet，在Lambda表达式中返回新的状态，内部会采用CAS操作来更新新状态，如果更新不成功，Lambda表达式会重复调用。</p><p>用于存放回调的数据结构也必须支持并发安全。这里我们提供一个递归列表，它具有不变形，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposableList</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> Nil : DisposableList()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span></span>(<br>        <span class="hljs-keyword">val</span> head: Disposable,<br>        <span class="hljs-keyword">val</span> tail: DisposableList<br>    ) : DisposableList()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过递归来实现对该列表的访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: DisposableList &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>        DisposableList.Nil -&gt; <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (head == disposable) tail<br>            <span class="hljs-keyword">else</span> DisposableList.Cons(head, tail.remove(disposable))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">forEach</span><span class="hljs-params">(action: (<span class="hljs-type">Disposable</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    DisposableList.Nil -&gt; <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>        action(<span class="hljs-keyword">this</span>.head)<br>        <span class="hljs-keyword">this</span>.tail.forEach(action)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Disposable&gt;</span> DisposableList.<span class="hljs-title">loopOn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> =<br>    forEach &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> T -&gt; action(it)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>我们把这个不变列表添加到状态中，在状态发生变化时，上一个状态的回调可以传递给新状态，确保已注册的回调不丢失。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> disposableList: DisposableList = DisposableList.Nil<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拿到上一个状态的所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">from</span><span class="hljs-params">(state: <span class="hljs-type">CoroutineState</span>)</span></span>: CoroutineState &#123;<br>        disposableList = state.disposableList<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">with</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = DisposableList.Cons(disposable, disposableList)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">without</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = <span class="hljs-keyword">this</span>.disposableList.remove(disposable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清除所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>        disposableList = DisposableList.Nil<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的初步实现"><a href="#协程的初步实现" class="headerlink" title="协程的初步实现"></a>协程的初步实现</h3><p>定义好状态后，接下来要为状态机输入事件，定义一个Job的抽象子类如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> context: CoroutineContext) : Job, Continuation&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子状态机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br><br>    <span class="hljs-keyword">val</span> isCompleted<br>        <span class="hljs-keyword">get</span>() = state.<span class="hljs-keyword">get</span>() <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;,<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">true</span><br>        &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        state.<span class="hljs-keyword">set</span>(CoroutineState.Incomplete()) <span class="hljs-comment">// 初始化为Incomplete状态</span><br>        <span class="hljs-keyword">this</span>.context = context + <span class="hljs-keyword">this</span><br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AbstractCoroutine同时实现了<strong>Continuation</strong>接口，这个我们已经熟悉了，是为了能够传入作为completion在启动时传入协程，以监听协程的完成事件。</p><h2 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h2><p>我们在协程的描述中定义好了协程应该具备哪些能力，接下来要考虑如何封装协程的创建。</p><h3 id="无返回值的luanch"><a href="#无返回值的luanch" class="headerlink" title="无返回值的luanch"></a>无返回值的luanch</h3><p>如果协程的返回值是为Unit，那我们可以认为它<strong>无返回值</strong>，对于这种协程只需要启动它即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>launch的实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">launch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(context: CoroutineContext) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(context)<br></code></pre></div></td></tr></table></figure><h3 id="实现invokeOnCompletion"><a href="#实现invokeOnCompletion" class="headerlink" title="实现invokeOnCompletion"></a>实现invokeOnCompletion</h3><p>用launch创建的协程可以立即运行起来，如果我们知道它什么时候结束，可以通过注册OnComplete回调来做到这一点。我们需要做两件事：</p><ol><li>将回调注册到协程中。</li><li>在协程完成时通知回调。</li></ol><p>Job接口中定义的OnComplete实际只是一个函数，声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> OnComplete = () -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></div></td></tr></table></figure><p>这里并没有携带任何参数，因为协程执行完成的结果我们有更好的方式去获取，这里的OnComplete仅仅用于通知协程执行结束。但对于协程内部来说，我们需要获取结果来进行状态流转，所以这里定义一个doOnCompleted函数在注册获取结果的回调，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnComplete</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">return</span> doOnCompleted &#123; _ -&gt; onComplete() &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnCompleted</span><span class="hljs-params">(block: (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CompletionHandlerDisposable(<span class="hljs-keyword">this</span>, block)<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Complete&lt;T&gt;)?.let &#123;<br>        block(<br>            <span class="hljs-keyword">when</span> &#123;<br>                it.value != <span class="hljs-literal">null</span> -&gt; Result.success(it.value)<br>                it.exception != <span class="hljs-literal">null</span> -&gt; Result.failure(it.exception)<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Won&#x27;t happen.&quot;</span>)<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompletionHandlerDisposable</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> job: Job,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> OnComplete: (Result&lt;T&gt;) -&gt; <span class="hljs-built_in">Unit</span><br>) : Disposable &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，<strong>除了Complete状态时我们可以直接回调OnComplete，其它状态的流转我们都需要构造一个新的状态对象来确保并发安全</strong>。</p><p>注册回调的过程分为以下三步：</p><ol><li>构造一个CompletionHandlerDisposable对象。它有一个disposable函数，用于将对应的回调移除。</li><li>检查状态，并将回调添加到状态中。</li><li>在状态流转成功后，获得最终的状态，如果是Complete状态则立即回调OnComplete。</li></ol><p>Job的remove函数还未实现，来看看。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现与doOnCompleted刚好相反。</p><p>接下来思考下如何通知回调。想一下如何知道协程执行完毕呢，没错就是当<strong>AbstractCoroutine#resumeWith</strong>函数调用时，协程执行完毕。因此我们只需要在AbstractCoroutine#resumeWith函数中将协程流转为完成状态，并且通知此前注册的完成回调即可。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Complete(result.getOrNull(), result.exceptionOrNull()).from(prev)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed!&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知完成回调</span><br>    newState.notifyCompletion(result)<br>    newState.clear()<br>&#125;<br><br>[CoroutineState.kt]<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">notifyCompletion</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.disposableList.loopOn&lt;CompletionHandlerDisposable&lt;T&gt;&gt; &#123;<br>        it.onComplete(result)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里Cancelling会流转为Complete的关键是，协程被取消后并不会立即停止执行，而是要等待内部的挂起点相应，这个我们后面再详细讨论。</p><h3 id="实现join"><a href="#实现join" class="headerlink" title="实现join"></a>实现join</h3><p>join是一个挂起函数，它被调用时会有两种情况：</p><ul><li>被等待的协程已经完成，join不会挂起而是立即返回。</li><li>被等待的协程未完成，join立即挂起，直到协程完成。</li></ul><p>由于上面已经实现了完成回调，因此join只需要判断是否挂起，以及在挂起后被等待协程完成时回调中使用resume恢复挂起即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-keyword">return</span> joinSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt;<br>        continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="有返回值的async"><a href="#有返回值的async" class="headerlink" title="有返回值的async"></a>有返回值的async</h3><p>现在我们已经知道如何启动协程并等待协程执行完成，不过很多时候我们更想拿到协程的返回值，因此我们基于Job再定义一个接口Deferred如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deferred</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Job &#123;</span></span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里多了一个泛型参数T，T表示返回值类型，通过它的await函数也可以拿到这个返回值，await的作用主要是：</p><ol><li>在协程已经执行完成时，立即返回协程的结果，或者异常。</li><li>如果协程未完成，则挂起直到当前协程执行完成。</li></ol><p>该方法与join类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (currentState) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; awaitSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>            currentState.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: (currentState.value <span class="hljs-keyword">as</span> T)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt; continuation.resumeWith(result) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来可以写出有返回值的async函数的实现了，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Deferred&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> completion = DeferredCoroutine&lt;T&gt;(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">val</span> deferred = async &#123;<br>    getValue()<br>&#125;<br><span class="hljs-keyword">val</span> result = deferred.await()<br>println(result)<br></code></pre></div></td></tr></table></figure><p>这与我们前几篇实现的async/await仅有细节的差别。</p><h2 id="协程的调度"><a href="#协程的调度" class="headerlink" title="协程的调度"></a>协程的调度</h2><p>我们已经大致实现了一个比较完整的复合协程，不过还要一个问题，如何指定协程的运行线程，或者说如何对协程进行线程调度？</p><h3 id="协程的调度位置"><a href="#协程的调度位置" class="headerlink" title="协程的调度位置"></a>协程的调度位置</h3><p>协程在挂起点位置可能需要进行调度，为什么说可能，前几篇文章已经说过了，只有发生了事实上的异步行为时，才需要调度。我们再来回顾一下什么是事实上的异步：</p><ul><li>挂起点对应的挂起函数内部切换了线程，并在该线程内部调用Continuation#resume来恢复。</li><li>挂起函数内部通过事件循环机制将Continuation的恢复调用转移到了新的线程调用栈上，例如Android平台上的Handler#post。</li><li>挂起函数内部将Continuation实例白村，在后续某个时间再恢复调用。</li></ul><p>综上所述，只有恢复和挂起不在同一个函数调用栈执行的情况，我们才有机会实现调度，而实现调度需要使用协程的<strong>拦截器</strong>。</p><h3 id="协程的调度器设计"><a href="#协程的调度器设计" class="headerlink" title="协程的调度器设计"></a>协程的调度器设计</h3><p><strong>调度的本质是利用拦截器将协程的恢复调用转移到一个特定的线程上</strong>，由此可以写出下列代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContext</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatcherContinuation(continuation, dispatcher)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> delegate: Continuation&lt;T&gt;, <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = delegate.context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        dispatcher.dispatch &#123;<br>            delegate.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基于线程池的调度器"><a href="#基于线程池的调度器" class="headerlink" title="基于线程池的调度器"></a>基于线程池的调度器</h3><p>我们最常见的调度场景就是制定代码的执行线程，而在Java平台上使用线程池是比较好的做法，官方调度器也是如此。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DefaultDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadGroup = ThreadGroup(<span class="hljs-string">&quot;DefaultDispatcher&quot;</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadIndex = AtomicInteger(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executor =<br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>) &#123; runnable -&gt;<br>            Thread(<br>                threadGroup,<br>                runnable,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;threadGroup.name&#125;</span>-worker-<span class="hljs-subst">$&#123;threadIndex.getAndDecrement()&#125;</span>&quot;</span><br>            ).apply &#123; isDaemon = <span class="hljs-literal">true</span> &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        executor.submit(block)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-keyword">val</span> Default <span class="hljs-keyword">by</span> lazy &#123;<br>        DispatcherContext(DefaultDispatcher)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里我们创建了一个CPU密集型线程池，并且线程全部设置为守护线程。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch(Dispatchers.Default) &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">2000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>println(1)和println(2)都将运行在Default调度器对应线程上。</p><h3 id="基于UI事件循环的调度器"><a href="#基于UI事件循环的调度器" class="headerlink" title="基于UI事件循环的调度器"></a>基于UI事件循环的调度器</h3><p>Android开发者比较关心如何将协程调度到主线程上。这个比较简单，直接使用Handler#post即可将协程体发送到主线程消息循环中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidMainDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = Handler(Looper.getMainLooper())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——复合协程</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将基于简单协程实现几种复合协程。</p><h2 id="序列生成器"><a href="#序列生成器" class="headerlink" title="序列生成器"></a>序列生成器</h2><h3 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h3><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums: (<span class="hljs-built_in">Int</span>) -&gt; Generator&lt;<span class="hljs-built_in">Int</span>&gt; = generator &#123; start: <span class="hljs-built_in">Int</span> -&gt;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) &#123;<br>        yield(start + i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> gen: Generator&lt;<span class="hljs-built_in">Int</span>&gt; = nums(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> gen) &#123;<br>    println(j)<br>&#125;<br><br><span class="hljs-comment">// 运行结果 </span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt; = GeneratorIterator(block, parameter)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建一个序列生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReady</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : State()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ready</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, <span class="hljs-keyword">val</span> nextValue: T) : State()<br>    <span class="hljs-keyword">object</span> Done : State()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取下一个元素</span><br><span class="hljs-comment"> * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程</span><br><span class="hljs-comment"> * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; &#123;<br>            resume()<br>            <span class="hljs-keyword">return</span> next()<br>        &#125;<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;<br>            state = State.NotReady(currentState.continuation)<br>            (currentState <span class="hljs-keyword">as</span> State.Ready&lt;T&gt;).nextValue<br>        &#125;<br>        State.Done -&gt; &#123;<br>            <span class="hljs-keyword">throw</span>  IndexOutOfBoundsException(<span class="hljs-string">&quot;No value left.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用suspendCoroutine挂起当前协程</span><br><span class="hljs-comment"> * 并将当前状态流转为[State.Ready]状态，返回value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    state = <span class="hljs-keyword">when</span> (state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;cannot yield while ready.&quot;</span>)<br>        <span class="hljs-keyword">is</span> State.Done -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;cannot yield while done.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    resume()<br>    <span class="hljs-keyword">return</span> state != State.Done<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动或者恢复协程</span><br><span class="hljs-comment"> * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建协程的completion回调</span><br><span class="hljs-comment"> * 协程执行完成后回调</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    state = State.Done<br>    println(result.getOrThrow())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; block(parameter) &#125;<br>    <span class="hljs-comment">// 带Receiver的方式创建协程</span><br>    <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 初始化状态</span><br>    state = State.NotReady(start)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorIterator</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : GeneratorScope&lt;T&gt;, Iterator&lt;T&gt;, Continuation&lt;Any?&gt;<br></code></pre></div></td></tr></table></figure><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h3 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h3><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sequence = sequence &#123;<br>        yield(<span class="hljs-number">1</span>)<br>        yield(<span class="hljs-number">2</span>)<br>        yield(<span class="hljs-number">3</span>)<br>        yieldAll(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>&#125;<br><br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">in</span> sequence) &#123;<br>    println(num)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fibonacci = sequence &#123;<br>    yield(<span class="hljs-number">1L</span>)<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">var</span> next = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        yield(next)<br>        next += current<br>        current = next - current<br>    &#125;<br>&#125;<br><br>fibonacci.take(<span class="hljs-number">10</span>).forEach(::println) <span class="hljs-comment">// 使用take(10)获取前10个元素</span><br></code></pre></div></td></tr></table></figure><h2 id="Promise-模型"><a href="#Promise-模型" class="headerlink" title="Promise 模型"></a>Promise 模型</h2><p>Promise模型又叫async/await，是目前最常见也最容易理解和上手的协程实现。</p><p>async/await的设计可以在async函数内部对复合Promise协议的异步回调进行await，使得异步逻辑变成了同步代码。这是目前主流的协程实现，它的关键在于将函数分为两种：</p><ul><li>普通函数：只能够调用普通函数，不存在协程的挂起和恢复逻辑。</li><li>async函数：既可以调用普通函数，也可以调用async函数，且可以将回调通过await同步化。</li></ul><p>async和wait各司其职，分别实现协程的挂起和恢复的逻辑，上手几乎没有成本。</p><h3 id="仿JavaScript的async-await实现"><a href="#仿JavaScript的async-await实现" class="headerlink" title="仿JavaScript的async/await实现"></a>仿JavaScript的async/await实现</h3><p>利用kotlin协程实现一个async/await的复合协程，效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">async &#123;<br>    <span class="hljs-keyword">val</span> user = await &#123; gitHubApi.getUserCallback(<span class="hljs-string">&quot;sukaidev&quot;</span>) &#125;<br>    println(user)<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>User(userName=sukaidev, blog=https:<span class="hljs-comment">//www.sukaidev.top, location=GuangZhou,China, bio=Focus on Jetpack)</span><br></code></pre></div></td></tr></table></figure><p>先思考下async如何实现。async接收一个函数作为参数，这个函数即协程体，必然是个挂起函数。async创建成功后协程即启动，并且内部可以使用await方法来挂起协程。async函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">AsyncScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> completion = AsyncCoroutine(context)<br>    block.startCoroutine(completion, completion)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCoroutine</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext) :<br>    Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, AsyncScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        result.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于async启动的协程不需要返回值，所以作为completion存在的AsyncCoroutine没有泛型参数。</p><p>await函数定义在AsyncScope中，使得它可以在async构造的协程中调用，它主要的作用就是将网络请求的回调转为协程，使用suspendCoroutine实现即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncScope</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">await</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> call = block()<br>        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                    response.body()?.let(continuation::resume)<br>                        ?: continuation.resumeWithException(NullPointerException())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                continuation.resumeWithException(HttpException(response))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                continuation.resumeWithException(t)<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>async/await的状态比较简单，只有挂起以及被封装的回调完成状态，状态之间的流转由await单独来完成，因此不需要额外的状态机实现。当我们引入了协程的取消处理、异常处理等逻辑后，状态机的存在就至关重要了。</p><h2 id="Luna风格的协程API"><a href="#Luna风格的协程API" class="headerlink" title="Luna风格的协程API"></a>Luna风格的协程API</h2><p>我们在使用Kotlin协程时，总是说创建了一个协程，不像创建线程会有一个对应的类或者对象。在之前的复合协程中，我们总是把协程的状态机封装在协程的完成回调Continuation实例competition中，由于这个实例提供了各种的协程能力，所以我们一般它当做复合协程本身。</p><p>使用Luna API创建协程与创建线程一样，只需提供一个函数，返回一个协程的控制类来控制协程的执行，我们可以基于Kotlin的简单协程来实现这样的一套API。</p><h3 id="非对称API实现"><a href="#非对称API实现" class="headerlink" title="非对称API实现"></a>非对称API实现</h3><p>非对称协程的主要特点就是在协程挂起时，协程控制权返回给了调用者，我们先看下实现效果，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer = Coroutine.create&lt;<span class="hljs-built_in">Unit</span>, <span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        println(<span class="hljs-string">&quot;send <span class="hljs-variable">$i</span>&quot;</span>)<br>        yield(i)<br>    &#125;<br>    <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = Coroutine.create&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Unit</span>&gt; &#123; parameter: <span class="hljs-built_in">Int</span> -&gt;<br>    println(<span class="hljs-string">&quot;start <span class="hljs-variable">$parameter</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">val</span> value = yield(<span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;receive <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive) &#123;<br>    <span class="hljs-keyword">val</span> result = producer.resume(<span class="hljs-built_in">Unit</span>)<br>    consumer.resume(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过Coroutine的伴生对象来创建协程，参数为协程体，协程体的参数类型和返回值类型由泛型参数指定。create的返回值用来控制协程的执行，结合前面几篇文章，我们知道这个返回值其实就是封装了协程状态机的实例，与SafeContinuation的作用十分类似，我们也习惯于将这个实例作为协程的完成回调，即competition。yield函数类似于序列生成器中的yield的作用，将当前协程挂起并将它的参数作为协程这一次resume调用的返回值。</p><p>状态机的状态设计是关键点，有如下几个状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Created</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yielded</span>&lt;<span class="hljs-type">P</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;P&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resumed</span>&lt;<span class="hljs-type">R</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;R&gt;) : Status()<br>    <span class="hljs-keyword">object</span> Dead : Status()<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>Created：</strong>协程处于刚刚被创建状态，需要等待resume函数的调用来启动协程。</li><li><strong>Yielded：</strong>协程内部调用yield函数后挂起，泛型参数P表示协程的参数类型。</li><li><strong>Resumed：</strong>协程外部调用resume函数之后协程恢复执行，泛型参数R表示协程的返回值类型。</li><li><strong>Dead：</strong>表示协程已经执行完毕。</li></ul><p>状态之间的转移如下所示。</p><p><img src="/img/state_transfer_02.png" alt="状态流转图"></p><p>创建一个CoroutineScope来约束yield的调用范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span>&lt;<span class="hljs-type">P, R</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">val</span> parameter: P?   <span class="hljs-comment">// 协程体启动时的参数</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于Coroutine的对象需要返回给调用者，所以我们这里不能让Coroutine来直接实现CoroutineScope，而是在内部创建了一个CoroutineScope的匿名内部类。协程描述类的部分代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coroutine</span>&lt;<span class="hljs-type">P, R</span>&gt; <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.(P) -&gt; R<br>) : Continuation&lt;R&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P, R&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>&lt;<span class="hljs-type">P</span>, R&gt;.(P)</span></span> -&gt; R<br>        ): Coroutine&lt;P, R&gt; &#123;<br>            <span class="hljs-keyword">return</span> Coroutine(context, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = <span class="hljs-keyword">object</span> : CoroutineScope&lt;P, R&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> parameter: P? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>          ... ...<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: AtomicReference&lt;Status&gt;<br>  <br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>      <span class="hljs-keyword">get</span>() = status.<span class="hljs-keyword">get</span>() != Status.Dead<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.() -&gt; R = &#123; block(parameter!!) &#125;<br>        <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(scope, <span class="hljs-keyword">this</span>)<br>        status = AtomicReference(Status.Created(start))<br>    &#125;<br>  ... ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码结构与之前的序列生成器的迭代器类似，不过有两点区别：</p><ol><li>提供了一个工厂方法create函数，用于手动创建Coroutine对象，同时返回该对象，使得外部可以控制Coroutine对象的恢复逻辑。</li><li>状态机status我们使用了AtomicReference<Status>，这是为了确保状态机的流转在多线程情况下仍然能够保证原子性。</li></ol><p>我们再来看下yield的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)  <span class="hljs-comment">// 恢复外部协程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数使用<strong>suspendCoroutine</strong>来挂起函数，这个我们已经很熟悉了。与序列生成器的yield实现不同的是，这里yield是有返回值的，为P类型也就是协程的入参类型，这使得yield同时也可以作为消费者来使用。</p><p>status.getAndUpdate接收一个参数为上一个状态，并要求返回新的状态，这个函数可能会被执行多次。当previousStatus确实是Resumed，就调用它的continuation.resume来<strong>恢复此前恢复执行当前协程的协程</strong>，这里有点绕，其实就是恢复外部协程的执行，外部协程指我们创建producer和consumer的协程。外部协程为什么会挂起跟我们的resume函数实现有关，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;  <span class="hljs-comment">// 挂起外部协程</span><br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; &#123;<br>                scope.parameter = value<br>                Status.Resumed(continuation)<br>            &#125;<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; Status.Resumed(continuation)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already resumed!&quot;</span>)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (previousStatus) &#123;  <span class="hljs-comment">// 恢复当前协程</span><br>        <span class="hljs-keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>        <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="hljs-keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当外部调用resume恢复该协程时，当前状态可能为：</p><ul><li>Created，协程只是创建，并未启动。</li><li>Yielded，协程已执行处于挂起状态。</li></ul><p>resume函数的作用是挂起外部协程，并且启动或恢复当前协程的执行。外部协程挂起后，我们将其continuation实例存入到状态机中，当当前协程yield函数被调用时，又会将外部协程恢复，使得外部协程可以继续执行后续工作，例如调用另一个协程的resume函数。文字说起来可能比较抽象，这里画了一个时序图，如下。</p><p><img src="/img/asymmetric_api.png" alt="非对称API时序图"></p><p>最后就是resumeWith的实现了，它的调用表示该协程已经执行完毕，需要将状态流转为State.Dead，同时不要忘记恢复外部协程执行，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Dead<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此，Lua风格的非对称协程API完成。</p><h3 id="对称API实现"><a href="#对称API实现" class="headerlink" title="对称API实现"></a>对称API实现</h3><p>对称协程意味着协会可以任意、平等地传递调度权。在传递过程过，调度权转出的协程需要提供目标协程的对象及参数，目标协程应处于挂起状态等待接收调度权，中间应当有一个控制中心来协助完成调度权的转移。控制中心需要具备以下能力：</p><ul><li>在当前协程挂起时接收调度权。</li><li>根据目标协程对象来完成调度权的最终转移。</li></ul><p>这个控制中心显然是一个可以恢复（当前协程挂起）和挂起（传递调度权给目标协程）的协程，实际上我们之前的非对称API中的外部协程已经具备了一些控制中心的能力，我们只需要对其进行改造即可。效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SymCoroutines &#123;<br>    <span class="hljs-keyword">val</span> coroutine0: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; params: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-0 <span class="hljs-variable">$params</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine2, <span class="hljs-number">0</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(SymCoroutine.main, <span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine1: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-1 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> result = transfer(coroutine0, <span class="hljs-number">1</span>)<br>        println(<span class="hljs-string">&quot;coroutine-1 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine2: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-2 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine1, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(coroutine0, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 2 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br>SymCoroutine.main &#123;<br>    println(<span class="hljs-string">&quot;main 0&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="hljs-number">3</span>)<br>    println(<span class="hljs-string">&quot;main end <span class="hljs-variable">$result</span>&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用<strong>SymCoroutine.create</strong>创建了多个协程，并且使用<strong>SymCoroutine.main</strong>创建了一个外部协程，这个外部协程就是控制中心，后文简称为 Main协程。Main协程通过<strong>transfer</strong>函数将调度权转移给coroutine2，从而开始了对称协程的调度权转移过程。</p><p><img src="/img/sym_coroutine_sequence_diagram.png" alt="调度权转移时序图"></p><p>与之前一样，我们定义一个作用域接口来提供transfer函数，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，泛型参数T为对称协程的参数类型，而transfer函数的泛型参数P表示目标协程的参数类型，对称协程自身的定义决定了它不存在返回值，这点与非对称协程不同。</p><p>接下来就是协程描述类SymCoroutine以及它的create和main函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> main: SymCoroutine&lt;Any?&gt;<br><br>        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">Any</span>?&gt;.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span> &#123;<br>            SymCoroutine&lt;Any?&gt; &#123;<br>                block()<br>            &#125;.also &#123;<br>                main = it<br>            &#125;.start(<span class="hljs-built_in">Unit</span>)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: SymCoroutine&lt;T&gt; = SymCoroutine(context, block)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        ... ...<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> isMain: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span> == main<br>    ... ... <br>&#125;<br></code></pre></div></td></tr></table></figure><p>main函数的作用是创建Main协程，同时会将其赋值给伴生对象属性main，方便其他协程将调度权归还给控制中心。</p><p>接下来我们思考下当前协程如何将调度权转出。<strong>由于当前协程本质上是由Main协程启动的协程，因此只要调用内部的非对称协程的yield函数将自身挂起，调度权自然就交回到了Main协程手中</strong>。Main协程只需要读取它自己的resume的返回值即可得到目标协程对象及参数。因此yield的参数类型定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameter</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="hljs-keyword">val</span> value: T)<br></code></pre></div></td></tr></table></figure><p>SymCoroutin内部的非对称协程的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    ... ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coroutine = Coroutine.create&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;<br>        Parameter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>, <span class="hljs-keyword">suspend</span> &#123;<br>            block(body, it)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) <span class="hljs-built_in">Unit</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>        &#125;() <span class="hljs-keyword">as</span> T)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        coroutine.resume(value)<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于内部的非对称协程而言，yield函数的参数类型**Parameter<T>**自然就是它的返回值类型，因此我们看到携程体内构造了一个Parameter的实例。不过我们在传入Parameter参数的时候，应传入目标协程和目标协程的参数，但这里我们传入了this，这是为什么呢？因为这是协程执行完后的最后一行代码，由于对称协程在执行完成之前必须交出调度权，所以这段代码只会被特权协程执行。第二个参数也是如此，创建了一个Lambda表达式并且理解调用了它，并在其中执行了block触发协程体的执行，普通的对称协程在block内部就会通过调用transfer交出调度权。</p><p>接下来是最关键的transfer函数的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">tailrec</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transferInner</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">            value: <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) &#123; <span class="hljs-comment">// Main协程在转移调度权</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (symCoroutine.isMain) &#123;<br>                    value <span class="hljs-keyword">as</span> T  <span class="hljs-comment">// ... ③</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="hljs-keyword">as</span> P)  <span class="hljs-comment">// ... ①</span><br>                    transferInner(parameter.coroutine, parameter.value)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 对称协程转移调度权到其他协程或者Main协程</span><br>                coroutine.run &#123;<br>                    <span class="hljs-keyword">return</span> yield(Parameter(symCoroutine, value <span class="hljs-keyword">as</span> P))  <span class="hljs-comment">// ... ②</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T &#123;<br>            <span class="hljs-keyword">return</span> transferInner(symCoroutine, value)<br>        &#125;<br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们按照之前代码的执行逻辑来分析一下transfer的调用逻辑。</p><ul><li>程序开始执行时，调度权最开始在特权协程手中，调用transfer将调度权转给coroutine2，transferInner入参symCoroutine为coroutine2，在①处调用coroutine2的resume挂起Main协程，coroutine2开始执行。</li><li>接下来coroutine2调用transfer函数转给coroutine1时，先将调度权交出，实际上就是在②处调用yield将自己挂起，此时接收调度权的Main协程在①处的resume函数返回，parameter中携带的其实就是coroutine1和它的参数。</li><li>此时Main协程中递归调用transferInner并再次进入①处挂起自己，由于coroutine1尚未启动，因此直接开始执行，直到调用transfer转给coroutine0。</li><li>最终，在coroutine()中将调度权归还给Main协程，transferInner落入③处分支直接返回。</li></ul><p>至此，基于非对称协程API实现的对称协程API原理分析完毕。</p><h2 id="复合协程的实现模式"><a href="#复合协程的实现模式" class="headerlink" title="复合协程的实现模式"></a>复合协程的实现模式</h2><p>结合本篇几个案例的实现，我们可以把<strong>复合协程实现模式</strong>归纳如下。</p><ul><li><strong>协程的构造器</strong>。我们总是需要一套更好更简便的API来创建协程，例如async{ … }或者Coroutine.create{ … }。</li><li><strong>协程的返回值</strong>。协程可以有返回值，这一点主要是由协程完成时对completion的调用来保证的。</li><li><strong>协程的状态机</strong>。在Kotlin协程的基础设施中，协程本身已经存在创建、执行、挂起、完成等状态了，我们通常需要对这些状态进行管理以控制协程的执行逻辑。状态流转过程在并发环境下需要考虑并发安全问题，我们可以在状态流转时通过加锁来确保这一点，也可以采用更高效的CAS算法来确保状态流转的原子性。</li><li><strong>协程的作用域</strong>。作用域主要用作协程体的Receiver，从而令协程体能够方便地获得协程自身的信息或者调用协程体专属的函数（例如yield）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念与原理</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p><strong>Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现</strong>。不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br> SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></div></td></tr></table></figure><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)<br>    <span class="hljs-string">&quot;return value.&quot;</span><br>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><br><br><span class="hljs-comment">// 控制台输出：</span><br>Coroutine Start.<br>Coroutine End : Success(<span class="hljs-keyword">return</span> value.)<br></code></pre></div></td></tr></table></figure><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br> createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)<br></code></pre></div></td></tr></table></figure><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br></code></pre></div></td></tr></table></figure><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(value.toString())<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)<br>        print(<span class="hljs-number">1000</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        hashCode(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们<strong>main</strong>函数可以直接被声明为suspend：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.result = result<br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    continuation.resume(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即连续传递样式变换。CPS是一种编程风格，用来将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者，这就将它的程序流程显式的暴露给程序员。而CPS变换就是将原本不是CPS风格的代码转变为CPS风格，通常由编译器来对代码进行优化，<strong>而Kotlin协程能够采用同步的方式书写异步代码的原理正是由于编译器使用了CPS变换</strong>。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend</strong>函数发现，<strong>notSuspend()**函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，就是</strong>CPS变换**。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));<br>   Continuation continuation = (Continuation)var4;<br>   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;<br>   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;<br>   Companion var10 = Result.Companion;<br>   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;<br>   continuation.resumeWith(Result.constructor-impl(var8));<br>   Object var10000 = var4.getOrThrow();<br>   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>      DebugProbesKt.probeCoroutineSuspended($completion);<br>   &#125;<br>   <span class="hljs-keyword">return</span> var10000;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span><br>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;<br>        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;<br>        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span><br>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception<br>        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    <span class="hljs-keyword">val</span> deferred = async &#123;<br>        <span class="hljs-comment">// 发起了一个网络请求</span><br>        ......<br>    &#125;<br>    <span class="hljs-comment">// 做了一些操作</span><br>    ......<br>    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span><br>    <span class="hljs-comment">// 后续的一些操作</span><br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br></code></pre></div></td></tr></table></figure><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span><br>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span><br></code></pre></div></td></tr></table></figure><p>我们来看下协程上下文中的元素类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element<br></code></pre></div></td></tr></table></figure><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :<br>    AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)<br>coroutineContext += CoroutineExceptionHandler&#123;<br>    <span class="hljs-comment">//  ... ...</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        println(context[CoroutineName]?.name)<br>        result.onFailure &#123;<br>            context[CoroutineExceptionHandler]?.onError(it)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :<br>    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br></code></pre></div></td></tr></table></figure><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));<br></code></pre></div></td></tr></table></figure><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
