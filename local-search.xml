<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（六）——Kotlin协程框架初探（二）</title>
    <link href="/2021/02/21/dd192d66/"/>
    <url>/2021/02/21/dd192d66/</url>
    
    <content type="html"><![CDATA[<p>本篇继续探讨协程的取消、异常处理以及作用域问题。</p><h2 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h2><p>协程的取消本质是协作式的取消，这点跟线程的中断一致，除了自身状态置为取消外，也需要协程体的执行逻辑能够检查状态的变化来响应取消。</p><h3 id="完善协程的取消逻辑"><a href="#完善协程的取消逻辑" class="headerlink" title="完善协程的取消逻辑"></a>完善协程的取消逻辑</h3><p>我们的Job目前还有两个函数空着没有实现，分别是cancle和invokeOnCancel。后者的实现与doOnCompleted类似，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CancellationHandlerDisposable(<span class="hljs-keyword">this</span>, onCancel)<br><br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Cancelling)?.let &#123; onCancel() &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellationHandlerDisposable</span></span>(<span class="hljs-keyword">val</span> job: Job, <span class="hljs-keyword">val</span> onCancel: OnCancel) : Disposable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cancel函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> preState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Cancelling()<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preState <span class="hljs-keyword">is</span> CoroutineState.Incomplete) &#123;<br>        preState.notifyCancellation()<br>        preState.clear()<br>    &#125;<br>    parentCancelDisposable?.disposable()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意这里使用了getAndUpdate来流转状态，也就是说我们拿到的是旧状态，旧状态如果是Incomplete则一定发生了状态流转，调用notifyCancellation来通知取消事件。</p><h3 id="支持取消的挂起函数"><a href="#支持取消的挂起函数" class="headerlink" title="支持取消的挂起函数"></a>支持取消的挂起函数</h3><p>通常来讲，一个发生了事实上挂起的挂起函数如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nonCancellableFunction</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br><br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br><br>    completableFuture.thenApply &#123;<br>        continuation.resume(it)<br>    &#125;.exceptionally &#123;<br>        continuation.resumeWithException(it)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种情况下，及时所在的协程被取消，我们也无法取消内部的异步任务CompletableFuture。为了能够取消内部的异步任务，我们需要Continuation提供一个取消状态和回调，在协程取消，回调被通知时取消掉CompletableFuture，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancellableFunction</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> completableFuture = CompletableFuture.supplyAsync &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>)<br>        Random.nextInt()<br>    &#125;<br>    continuation.invokeOnCancellation &#123;<br>        completableFuture.cancel(<span class="hljs-literal">true</span>)<br>    &#125;<br>   ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这个<strong>suspendCancellableCoroutine</strong>要如何实现呢？我们可以参考官方框架中的<strong>suspendCoroutine</strong>实现来做一点修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-meta">@InlineOnly</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutine</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;<br>    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;<br>        <span class="hljs-keyword">val</span> safe = SafeContinuation(c.intercepted())<br>        block(safe)<br>        safe.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>suspendCoroutineUninterceptedOrReturn的参数是一个函数，这个函数有一个参数Continuation，实际上就是我们前面文章说的编译后生成的匿名内部类的实例。SafeContinuation的作用是确保传入的Continuation对象的恢复调用只被执行一次。如何确保的呢？当block(safe)执行过程中调用了Continuation的恢复调用时，safe.getOrThrow就会获取到结果，而不是<strong>COROUTINE_SUSPENDED</strong>，这样协程就不会真正挂起了。</p><p>那么我们要对 Continuation进行改造使其支持取消的话，就要替换到SafeContinuation了，即需要实现一下效果：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: T = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> cancellable = CancellableContinuation(continuation.intercepted())<br>    block(cancellable)<br>    cancellable.getResult()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关键就是CancellableContinuation的实现了。</p><h3 id="CancellableContinuation的实现"><a href="#CancellableContinuation的实现" class="headerlink" title="CancellableContinuation的实现"></a>CancellableContinuation的实现</h3><p>CancellableContinuation需要具备以下能力：</p><ul><li>支持通过invokeOnCancellation注册取消回调</li><li>支持监听对应协程的取消状态</li><li>具备SafeContinuation的功能</li></ul><p>这样的话，CancellableContinuation必然是有状态的，同样我们先给出状态的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelState</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> InComplete : CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelHandler</span></span>(<span class="hljs-keyword">val</span> onCancel: OnCancel): CancelState()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CancelState()<br>    <span class="hljs-keyword">object</span> Cancelled : CancelState()<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancelDecision</span> </span>&#123;<br>    UNDECIDED, SUSPENDED, RESUMED<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的状态定义跟协程的状态时一致的，这里不多说。CancelDecision枚举用于标记对应的挂起函数是否同步返回了。</p><p>CancellableContinuation需要包装一个Continuation，这里我们直接使用接口代理即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CancelState&gt;(CancelState.InComplete)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> decision = AtomicReference(CancelDecision.UNDECIDED)<br><br>    <span class="hljs-keyword">val</span> isCompleted: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            CancelState.InComplete,<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; <span class="hljs-literal">true</span><br>        &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先看invokeOnCancellation的实现，如果当前是Incomplete状态，那么就可以注册回调，如果是Cancelled状态就直接调用回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancellation</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            CancelState.InComplete -&gt; CancelState.CancelHandler(onCancel)<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;It&#x27;s prohibited to register multiple handlers.&quot;</span>)<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt;,<br>            CancelState.Cancelled -&gt; prev<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newState <span class="hljs-keyword">is</span> CancelState.Cancelled) &#123;<br>        onCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来尝试去监听对应协程的取消事件，可以通过协程上下文来获取对应协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">installCancelHandler</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">val</span> parent = continuation.context[Job] ?: <span class="hljs-keyword">return</span> <span class="hljs-comment">// 获取协程</span><br>    parent.invokeOnCancel &#123;<br>        doCancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>取消回调中通过doCancel方法来完成状态的流转。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> prevState = state.getAndUpdate &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>            CancelState.InComplete -&gt; &#123;<br>                CancelState.Cancelled<br>            &#125;<br>            CancelState.Cancelled,<br>            <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (prevState <span class="hljs-keyword">is</span> CancelState.CancelHandler) &#123;<br>        prevState.onCancel()<br>        resumeWithException(CancellationException(<span class="hljs-string">&quot;Cancelled.&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于两种未完成的状态，流转为Cancelled，如果刘赚钱有回调注册，就调用回调通知取消事件。</p><p>由于挂起点发生了真正的挂起后注册回调才有意义，因此无需急于注册取消回调，在getResult中注册即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    installCancelHandler()  <span class="hljs-comment">// 注册取消回调</span><br>    <span class="hljs-keyword">if</span>(decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.SUSPENDED))<br>        <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CancelState.CancelHandler,<br>        CancelState.InComplete -&gt; COROUTINE_SUSPENDED<br>        CancelState.Cancelled -&gt; <span class="hljs-keyword">throw</span> CancellationException(<span class="hljs-string">&quot;Continuation is cancelled.&quot;</span>)<br>        <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>            (currentState <span class="hljs-keyword">as</span> CancelState.Complete&lt;T&gt;).let &#123;<br>                it.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: it.value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先注册了协程的取消回调，接着通过CAS操作判断当前decision是否为<strong>UNDECIDED</strong>，如果是UNDECIDED则表示结果还未就绪，将其设置为<strong>SUSPENDED</strong>并返回挂起标志位<strong>COROUTINE_SUSPENDED</strong>。否则decision只可能为RESUMED，即挂起函数没有真正挂起并且结果已经可以获取，那么就会在Complete分支返回结果，如果未完成则会返回挂起标志COROUTINE_SUSPENDED。</p><p>接着是resumeWith的实现。该函数被调用表示挂起函数恢复执行，此时如果dicision为<strong>UNDECIDED</strong>，表示挂起函数同步返回了，后面通过getResult来获取结果，否则只能为dicision只能为<strong>SUSPENDED</strong>，即已挂起。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> &#123;<br>        decision.compareAndSet(CancelDecision.UNDECIDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是UNDECIDED，则不用考虑并发安全问题</span><br>            state.<span class="hljs-keyword">set</span>(CancelState.Complete(result.getOrNull(), result.exceptionOrNull()))<br>        &#125;<br>        decision.compareAndSet(CancelDecision.SUSPENDED, CancelDecision.RESUMED) -&gt; &#123; <span class="hljs-comment">// 如果是SUSPENDED，使用updateAndGet来更新状态并获取结果</span><br>            state.updateAndGet &#123; prev -&gt;<br>                <span class="hljs-keyword">when</span> (prev) &#123;<br>                    <span class="hljs-keyword">is</span> CancelState.Complete&lt;*&gt; -&gt; &#123;<br>                        <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed.&quot;</span>)<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        CancelState.Complete(result.getOrNull(), result.exceptionOrNull())<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复delegate</span><br>            continuation.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>CancellableContinuation的状态转移如下图。</p><p><img src="/img/cancellation_state_transfer.png" alt="CancellableContinuation的状态转移"></p><h3 id="改造挂起函数"><a href="#改造挂起函数" class="headerlink" title="改造挂起函数"></a>改造挂起函数</h3><p>我们之前定义的挂起函数都是使用suspendCoroutine函数来实现挂起，若要响应协程的取消，需要将其替换成上面实现好的suspendCancellableCoroutine。</p><p>以delay函数为例，改造后的delay函数如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(time: <span class="hljs-type">Long</span>, unit: <span class="hljs-type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br><br>    suspendCancellableCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> future = executor.schedule(&#123; continuation.resume(<span class="hljs-built_in">Unit</span>) &#125;, time, unit)<br>        continuation.invokeOnCancellation &#123; future.cancel(<span class="hljs-literal">true</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的异常处理"><a href="#协程的异常处理" class="headerlink" title="协程的异常处理"></a>协程的异常处理</h2><p>异常处理是异步程序需要解决的关键问题。</p><h3 id="处理协程的未捕获异常"><a href="#处理协程的未捕获异常" class="headerlink" title="处理协程的未捕获异常"></a>处理协程的未捕获异常</h3><p>先定义一个异常处理器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineExceptionHandler</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>要处理协程的未捕获异常，我们需要在AbstractCoroutine中定义一个子类可见的函数，提供给子类复写，返回值为true表示异常已处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>我们以AbstractCoroutine子类StandaloneCoroutine为例，StandaloneCoroutine由launch启动，协会本身没有返回结果。我们虚妄它能够在遇到未捕获异常时，调用自身的异常处理器进行处理，如果没有异常处理器就抛出给所在线程的uncaughtExceptionHandler来处理，代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">super</span>.handleJobException(e)<br>    context[CoroutineExceptionHandler]?.handleException(context, e) ?: Thread.currentThread()<br>        .let &#123; it.uncaughtExceptionHandler.uncaughtException(it, e) &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="取消异常的特别处理"><a href="#取消异常的特别处理" class="headerlink" title="取消异常的特别处理"></a>取消异常的特别处理</h3><p>协程的取消类似于线程的中断，取消时通过抛出取消异常来实现对取消状态的相应，因此上节的未捕获异常不应该包含取消异常。只需要定义一个函数来分发异常即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span>(e)&#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; handleJobException(e)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着在resumeWith中添加异常处理逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    ··· ···<br>    (newState <span class="hljs-keyword">as</span> CoroutineState.Complete&lt;T&gt;).exception?.let(<span class="hljs-keyword">this</span>::tryHandleException)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="协程的作用域"><a href="#协程的作用域" class="headerlink" title="协程的作用域"></a>协程的作用域</h2><p>协程作用域用来描述协程的作用范围，作用域既有约束作用又可以提供额外的能力。</p><h3 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h3><p>官方框架中作用域包括以下三种：</p><ol><li><strong>顶级作用域</strong>：没有父协程的协程所在的作用域。</li><li><strong>协同作用域</strong>：协程中启动新的协程，新协程未所在协程的子协程，这种情况下子协程所在的作用域默认为协同作用域。子协程抛出的未捕获异常都将传递给父协程处理，同时父协程也会被取消。</li><li><strong>主从作用域</strong>：与协程作用域在协程的父子关系一致，区别是子协程的未捕获异常将不会向上传递给父协程。</li></ol><p>父子协程之间还存在以下规则：</p><ul><li>父协程被取消，所有子协程都会被取消。</li><li>父协程需要等待子协程执行完毕才会最终进入完成状态。</li><li>子协程会继承父协程的协程上下文中的元素，如果自身有相同Key的成员，将会覆盖该Key。</li></ul><p>前面几篇文章我们已经熟悉了如何去创建一个作用域了，通常我们会将协程的启动函数定义在作用域中，同时让协程的描述类来实现作用域充当Receiver的角色，基于这两点来改造下launch函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义为CoroutineScope的扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion, completion) <span class="hljs-comment">// 带Receiver的方式启动协程</span><br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="建立父子关系"><a href="#建立父子关系" class="headerlink" title="建立父子关系"></a>建立父子关系</h3><p>前面说了，父协程取消之后，子协程也需要被取消，因此我们要对AbstractCoroutine稍加改造，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> parentJob = context[Job]<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> parentCancelDisposable : Disposable? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">init</span> &#123;<br>    ··· ···<br>    parentCancelDisposable = parentJob?.invokeOnCancel &#123; <br>        cancel()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过协程上下文来获取父协程，如果父协程存在，那么就需要注册一个取消回调，当父协程取消时取消掉当前协程。</p><h3 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h3><p>我们对launch函数进行改造之后，需要一个作用域来调用launch函数才能启动一个协程，但作用域又是在创建协程过程中产生的。针对这个问题，我们需要一个特殊的作用域，这个作用域不需要依赖父作用域来产生，这个作用域就叫做<strong>顶级作用域</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> scopeContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br>&#125;<br><br>GlobalScope.launch&#123;<br>  ··· ···<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于协程描述类AbstractCoroutine本身实现了CoroutineScope，因此由GlobalScope.launch启动的协程体内部我们可以直接创建新的子协程。</p><h3 id="实现异常传播"><a href="#实现异常传播" class="headerlink" title="实现异常传播"></a>实现异常传播</h3><p>接下来考虑一下子协程如何将异常向上传递。按照现有的实现，我们已经将该异常处理传递到tryHandleException中，对于非取消异常的情况都交给了handleJobException来处理。按照协同作用域的设计，协程遇到未捕获的异常时应当优先向上传播，如果没有父协程才自行处理。因此我们添加一个函数<strong>handleChildException</strong>用于接收子协程的异常，改造一下tryHandleException：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    cancel()  <span class="hljs-comment">// 取消父协程</span><br>    <span class="hljs-keyword">return</span> tryHandleException(e) <span class="hljs-comment">// 继续向上传递或者自己处理</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryHandleException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-keyword">when</span> (e) &#123;<br>    <span class="hljs-keyword">is</span> CancellationException -&gt; <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span> -&gt; (parentJob <span class="hljs-keyword">as</span>? AbstractCoroutine&lt;*&gt;)?.handleChildException(e) <span class="hljs-comment">// 交给父协程处理</span><br>        ?.takeIf &#123; it &#125;<br>        ?: handleJobException(e)  <span class="hljs-comment">// 没有父协程 自行处理</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注释已经很完善了，当出现未捕获异常时，先尝试调用父协程的handleChildException来处理，否则自行处理。父协程也优先调用父协程的父协程来处理。</p><h3 id="主从作用域"><a href="#主从作用域" class="headerlink" title="主从作用域"></a>主从作用域</h3><p>协同作用域的效果就是父子协程绑定，父取消则子取消，子异常则父连坐。而主从作用域则可以避免子协程出现异常而导致父协程取消的情况。</p><p>我们只需要将上面的<strong>handleChildException</strong>方法返回false即可避免子协程将异常传递给父协程，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(context: CoroutineContext, continuation: Continuation&lt;T&gt;) :<br>    ScopeCoroutine&lt;T&gt;(context, continuation) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleChildException</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>也很容易去创建这样一个作用域，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">supervisorScope</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">R</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: R = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> coroutine = SupervisorCoroutine(continuation.context, continuation)<br>    block.startCoroutine(coroutine, coroutine)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主从作用域的应用场景多见于子协程为独立对等的任务实体的情况，例如Android平台的Jetpack开发包中ViewModel内置的viewModelScope就是主从作用域实现。</p><h3 id="完整的异常处理流程"><a href="#完整的异常处理流程" class="headerlink" title="完整的异常处理流程"></a>完整的异常处理流程</h3><p>引入作用域后完整的异常处理流程如下如所示。</p><p><img src="/img/complete_exception_handle.png" alt="完整的异常处理流程"></p><h3 id="父协程等待子协程完成"><a href="#父协程等待子协程完成" class="headerlink" title="父协程等待子协程完成"></a>父协程等待子协程完成</h3><p>作用域要求父协程必须等待子协程执行完才可以进入完成状态，因此父协程的resumeWith执行完成后需要检查子协程是否完成，未完成则需要注册完成回调，等待所有子协程状态流转为完成状态父协程才能触发完成回调并且流转为完成态。我们只需要新增一个等待的状态即可，状态流转如下所示。</p><p><img src="/img/scope_state_transfer.png" alt="完整的异常处理流程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（五）——Kotlin协程框架初探（一）</title>
    <link href="/2021/02/16/b912c613/"/>
    <url>/2021/02/16/b912c613/</url>
    
    <content type="html"><![CDATA[<p>前面四篇文章我们了解了如何使用<strong>createCoroutine</strong>和<strong>startCoroutine</strong>这两个API来创建和启动简单协程，并且可以使用它们来构造复合协程。但客观的说，这两个API并不太适合直接在业务开发中使用，所以Kotlin协程为开发者提供了一些更贴近业务的复合协程API，即官方协程框架<a href="https://github.com/Kotlin/kotlinx.coroutines"><strong>kotlinx.coroutines</strong></a>。后面几篇文章我们就来尝试窥探一下这个庞大的框架的一角。</p><h2 id="协程的描述"><a href="#协程的描述" class="headerlink" title="协程的描述"></a>协程的描述</h2><p>对于协程的创建，官方框架中根据不同的目的提供了不同的构造器。</p><h3 id="协程的描述类"><a href="#协程的描述类" class="headerlink" title="协程的描述类"></a>协程的描述类</h3><p>Java中提供了线程的Java描述类Thread，通过调用<strong>Thread#start</strong>方法我们就可以通知系统启动一个线程，我们也知道<strong>Thread#run</strong>方法即为线程的执行代码，同时Thread也提供了类型join、interrupt、isAlive等方法来方便我们操作线程。类似的，我们也需要这样一个类来描述协程，按照官方框架的做法把它命名为Job，API设计如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;<br>        <span class="hljs-keyword">get</span>() = Job<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断协程是否扔在执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程取消回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCancel</span><span class="hljs-params">(onCancel: <span class="hljs-type">OnCancel</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 协程完成回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnCompelete</span>)</span></span>: Disposable<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取消协程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 与[Thread.join]类似，挂起外部协程直到当前协程完成</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>我们对协程的状态进行封装，让其状态管理更加简便。主要是<strong>未完成</strong>、<strong>已取消</strong>、<strong>已完成</strong>这三种状态。状态的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Incomplete</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cancelling</span> : <span class="hljs-type">CoroutineState</span></span>()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complete</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> value: T? = <span class="hljs-literal">null</span>, <span class="hljs-keyword">val</span> exception: Throwable? = <span class="hljs-literal">null</span>) : CoroutineState()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>进一步解释下这三种状态：</p><ul><li>Incomplete：协程启动后立即进入该状态，直到完成或者被取消。</li><li>Cancelling：协程执行中被取消后进入该状态。进入该状态后，要等待协程体内部的挂起函数调用相应取消，相应后协程成功被取消或者抛出CancellationException取消，最终会流转为Complete状态。</li><li>Complete：协程执行完成进入该状态。</li></ul><h3 id="支持回调的状态"><a href="#支持回调的状态" class="headerlink" title="支持回调的状态"></a>支持回调的状态</h3><p>注册回调时，需要根据当前状态的不同采取不同的处理方式，回调注册的操作也必须是原子操作，否则会有状态不一致问题。跟上篇文章相同，我们在状态流转时采用元子类来处理原子操作，比加锁性能会有较大提升。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-comment">// 返回新状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用updateAndGet，在Lambda表达式中返回新的状态，内部会采用CAS操作来更新新状态，如果更新不成功，Lambda表达式会重复调用。</p><p>用于存放回调的数据结构也必须支持并发安全。这里我们提供一个递归列表，它具有不变形，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposableList</span> </span>&#123;<br>    <span class="hljs-keyword">object</span> Nil : DisposableList()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span></span>(<br>        <span class="hljs-keyword">val</span> head: Disposable,<br>        <span class="hljs-keyword">val</span> tail: DisposableList<br>    ) : DisposableList()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过递归来实现对该列表的访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: DisposableList &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>        DisposableList.Nil -&gt; <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (head == disposable) tail<br>            <span class="hljs-keyword">else</span> DisposableList.Cons(head, tail.remove(disposable))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> DisposableList.<span class="hljs-title">forEach</span><span class="hljs-params">(action: (<span class="hljs-type">Disposable</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    DisposableList.Nil -&gt; <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">is</span> DisposableList.Cons -&gt; &#123;<br>        action(<span class="hljs-keyword">this</span>.head)<br>        <span class="hljs-keyword">this</span>.tail.forEach(action)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Disposable&gt;</span> DisposableList.<span class="hljs-title">loopOn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> =<br>    forEach &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> T -&gt; action(it)<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>我们把这个不变列表添加到状态中，在状态发生变化时，上一个状态的回调可以传递给新状态，确保已注册的回调不丢失。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineState</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> disposableList: DisposableList = DisposableList.Nil<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拿到上一个状态的所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">from</span><span class="hljs-params">(state: <span class="hljs-type">CoroutineState</span>)</span></span>: CoroutineState &#123;<br>        disposableList = state.disposableList<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">with</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = DisposableList.Cons(disposable, disposableList)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除一个回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">without</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span>: CoroutineState &#123;<br>        disposableList = <span class="hljs-keyword">this</span>.disposableList.remove(disposable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清除所有回调</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>        disposableList = DisposableList.Nil<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程的初步实现"><a href="#协程的初步实现" class="headerlink" title="协程的初步实现"></a>协程的初步实现</h3><p>定义好状态后，接下来要为状态机输入事件，定义一个Job的抽象子类如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> context: CoroutineContext) : Job, Continuation&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子状态机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> state = AtomicReference&lt;CoroutineState&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br><br>    <span class="hljs-keyword">val</span> isCompleted<br>        <span class="hljs-keyword">get</span>() = state.<span class="hljs-keyword">get</span>() <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt;,<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">true</span><br>        &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        state.<span class="hljs-keyword">set</span>(CoroutineState.Incomplete()) <span class="hljs-comment">// 初始化为Incomplete状态</span><br>        <span class="hljs-keyword">this</span>.context = context + <span class="hljs-keyword">this</span><br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AbstractCoroutine同时实现了<strong>Continuation</strong>接口，这个我们已经熟悉了，是为了能够传入作为completion在启动时传入协程，以监听协程的完成事件。</p><h2 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h2><p>我们在协程的描述中定义好了协程应该具备哪些能力，接下来要考虑如何封装协程的创建。</p><h3 id="无返回值的luanch"><a href="#无返回值的luanch" class="headerlink" title="无返回值的luanch"></a>无返回值的luanch</h3><p>如果协程的返回值是为Unit，那我们可以认为它<strong>无返回值</strong>，对于这种协程只需要启动它即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">1000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>launch的实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">launch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> completion = StandaloneCoroutine(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(context: CoroutineContext) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(context)<br></code></pre></div></td></tr></table></figure><h3 id="实现invokeOnCompletion"><a href="#实现invokeOnCompletion" class="headerlink" title="实现invokeOnCompletion"></a>实现invokeOnCompletion</h3><p>用launch创建的协程可以立即运行起来，如果我们知道它什么时候结束，可以通过注册OnComplete回调来做到这一点。我们需要做两件事：</p><ol><li>将回调注册到协程中。</li><li>在协程完成时通知回调。</li></ol><p>Job接口中定义的OnComplete实际只是一个函数，声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> OnComplete = () -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></div></td></tr></table></figure><p>这里并没有携带任何参数，因为协程执行完成的结果我们有更好的方式去获取，这里的OnComplete仅仅用于通知协程执行结束。但对于协程内部来说，我们需要获取结果来进行状态流转，所以这里定义一个doOnCompleted函数在注册获取结果的回调，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeOnCompletion</span><span class="hljs-params">(onComplete: <span class="hljs-type">OnComplete</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">return</span> doOnCompleted &#123; _ -&gt; onComplete() &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnCompleted</span><span class="hljs-params">(block: (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Disposable &#123;<br>    <span class="hljs-keyword">val</span> disposable = CompletionHandlerDisposable(<span class="hljs-keyword">this</span>, block)<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).with(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; prev<br>        &#125;<br>    &#125;<br>    (newState <span class="hljs-keyword">as</span>? CoroutineState.Complete&lt;T&gt;)?.let &#123;<br>        block(<br>            <span class="hljs-keyword">when</span> &#123;<br>                it.value != <span class="hljs-literal">null</span> -&gt; Result.success(it.value)<br>                it.exception != <span class="hljs-literal">null</span> -&gt; Result.failure(it.exception)<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Won&#x27;t happen.&quot;</span>)<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">return</span> disposable<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompletionHandlerDisposable</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> job: Job,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> OnComplete: (Result&lt;T&gt;) -&gt; <span class="hljs-built_in">Unit</span><br>) : Disposable &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span></span> &#123;<br>        job.remove(<span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，<strong>除了Complete状态时我们可以直接回调OnComplete，其它状态的流转我们都需要构造一个新的状态对象来确保并发安全</strong>。</p><p>注册回调的过程分为以下三步：</p><ol><li>构造一个CompletionHandlerDisposable对象。它有一个disposable函数，用于将对应的回调移除。</li><li>检查状态，并将回调添加到状态中。</li><li>在状态流转成功后，获得最终的状态，如果是Complete状态则立即回调OnComplete。</li></ol><p>Job的remove函数还未实现，来看看。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(disposable: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Incomplete().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; &#123;<br>                CoroutineState.Cancelling().from(prev).without(disposable)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>                prev<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现与doOnCompleted刚好相反。</p><p>接下来思考下如何通知回调。想一下如何知道协程执行完毕呢，没错就是当<strong>AbstractCoroutine#resumeWith</strong>函数调用时，协程执行完毕。因此我们只需要在AbstractCoroutine#resumeWith函数中将协程流转为完成状态，并且通知此前注册的完成回调即可。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> newState = state.updateAndGet &#123; prev -&gt;<br>        <span class="hljs-keyword">when</span> (prev) &#123;<br>            <span class="hljs-keyword">is</span> CoroutineState.Cancelling,<br>            <span class="hljs-keyword">is</span> CoroutineState.Incomplete -&gt; &#123;<br>                CoroutineState.Complete(result.getOrNull(), result.exceptionOrNull()).from(prev)<br>            &#125;<br>            <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already completed!&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知完成回调</span><br>    newState.notifyCompletion(result)<br>    newState.clear()<br>&#125;<br><br>[CoroutineState.kt]<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">notifyCompletion</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.disposableList.loopOn&lt;CompletionHandlerDisposable&lt;T&gt;&gt; &#123;<br>        it.onComplete(result)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里Cancelling会流转为Complete的关键是，协程被取消后并不会立即停止执行，而是要等待内部的挂起点相应，这个我们后面再详细讨论。</p><h3 id="实现join"><a href="#实现join" class="headerlink" title="实现join"></a>实现join</h3><p>join是一个挂起函数，它被调用时会有两种情况：</p><ul><li>被等待的协程已经完成，join不会挂起而是立即返回。</li><li>被等待的协程未完成，join立即挂起，直到协程完成。</li></ul><p>由于上面已经实现了完成回调，因此join只需要判断是否挂起，以及在挂起后被等待协程完成时回调中使用resume恢复挂起即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (state.<span class="hljs-keyword">get</span>()) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; <span class="hljs-keyword">return</span> joinSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt;<br>        continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="有返回值的async"><a href="#有返回值的async" class="headerlink" title="有返回值的async"></a>有返回值的async</h3><p>现在我们已经知道如何启动协程并等待协程执行完成，不过很多时候我们更想拿到协程的返回值，因此我们基于Job再定义一个接口Deferred如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deferred</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Job &#123;</span></span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里多了一个泛型参数T，T表示返回值类型，通过它的await函数也可以拿到这个返回值，await的作用主要是：</p><ol><li>在协程已经执行完成时，立即返回协程的结果，或者异常。</li><li>如果协程未完成，则挂起直到当前协程执行完成。</li></ol><p>该方法与join类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">val</span> currentState = state.<span class="hljs-keyword">get</span>()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (currentState) &#123;<br>        <span class="hljs-keyword">is</span> CoroutineState.Incomplete,<br>        <span class="hljs-keyword">is</span> CoroutineState.Cancelling -&gt; awaitSuspend()<br>        <span class="hljs-keyword">is</span> CoroutineState.Complete&lt;*&gt; -&gt; &#123;<br>            currentState.exception?.let &#123; <span class="hljs-keyword">throw</span> it &#125; ?: (currentState.value <span class="hljs-keyword">as</span> T)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>    doOnCompleted &#123; result -&gt; continuation.resumeWith(result) &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来可以写出有返回值的async函数的实现了，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: Deferred&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> completion = DeferredCoroutine&lt;T&gt;(context)<br>    block.startCoroutine(completion)<br>    <span class="hljs-keyword">return</span> completion<br>&#125;<br><br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">val</span> deferred = async &#123;<br>    getValue()<br>&#125;<br><span class="hljs-keyword">val</span> result = deferred.await()<br>println(result)<br></code></pre></div></td></tr></table></figure><p>这与我们前几篇实现的async/await仅有细节的差别。</p><h2 id="协程的调度"><a href="#协程的调度" class="headerlink" title="协程的调度"></a>协程的调度</h2><p>我们已经大致实现了一个比较完整的复合协程，不过还要一个问题，如何指定协程的运行线程，或者说如何对协程进行线程调度？</p><h3 id="协程的调度位置"><a href="#协程的调度位置" class="headerlink" title="协程的调度位置"></a>协程的调度位置</h3><p>协程在挂起点位置可能需要进行调度，为什么说可能，前几篇文章已经说过了，只有发生了事实上的异步行为时，才需要调度。我们再来回顾一下什么是事实上的异步：</p><ul><li>挂起点对应的挂起函数内部切换了线程，并在该线程内部调用Continuation#resume来恢复。</li><li>挂起函数内部通过事件循环机制将Continuation的恢复调用转移到了新的线程调用栈上，例如Android平台上的Handler#post。</li><li>挂起函数内部将Continuation实例白村，在后续某个时间再恢复调用。</li></ul><p>综上所述，只有恢复和挂起不在同一个函数调用栈执行的情况，我们才有机会实现调度，而实现调度需要使用协程的<strong>拦截器</strong>。</p><h3 id="协程的调度器设计"><a href="#协程的调度器设计" class="headerlink" title="协程的调度器设计"></a>协程的调度器设计</h3><p><strong>调度的本质是利用拦截器将协程的恢复调用转移到一个特定的线程上</strong>，由此可以写出下列代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContext</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatcherContinuation(continuation, dispatcher)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> delegate: Continuation&lt;T&gt;, <span class="hljs-keyword">val</span> dispatcher: Dispatcher) :<br>    Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = delegate.context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        dispatcher.dispatch &#123;<br>            delegate.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基于线程池的调度器"><a href="#基于线程池的调度器" class="headerlink" title="基于线程池的调度器"></a>基于线程池的调度器</h3><p>我们最常见的调度场景就是制定代码的执行线程，而在Java平台上使用线程池是比较好的做法，官方调度器也是如此。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DefaultDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadGroup = ThreadGroup(<span class="hljs-string">&quot;DefaultDispatcher&quot;</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> threadIndex = AtomicInteger(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executor =<br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>) &#123; runnable -&gt;<br>            Thread(<br>                threadGroup,<br>                runnable,<br>                <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;threadGroup.name&#125;</span>-worker-<span class="hljs-subst">$&#123;threadIndex.getAndDecrement()&#125;</span>&quot;</span><br>            ).apply &#123; isDaemon = <span class="hljs-literal">true</span> &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        executor.submit(block)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-keyword">val</span> Default <span class="hljs-keyword">by</span> lazy &#123;<br>        DispatcherContext(DefaultDispatcher)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里我们创建了一个CPU密集型线程池，并且线程全部设置为守护线程。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch(Dispatchers.Default) &#123;<br>    println(<span class="hljs-number">1</span>)<br>    delay(<span class="hljs-number">2000</span>)<br>    println(<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>println(1)和println(2)都将运行在Default调度器对应线程上。</p><h3 id="基于UI事件循环的调度器"><a href="#基于UI事件循环的调度器" class="headerlink" title="基于UI事件循环的调度器"></a>基于UI事件循环的调度器</h3><p>Android开发者比较关心如何将协程调度到主线程上。这个比较简单，直接使用Handler#post即可将协程体发送到主线程消息循环中。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidMainDispatcher : Dispatcher &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = Handler(Looper.getMainLooper())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（四）——Luna风格的协程API</title>
    <link href="/2021/02/08/ded91b47/"/>
    <url>/2021/02/08/ded91b47/</url>
    
    <content type="html"><![CDATA[<p>我们在使用Kotlin协程时，总是说创建了一个协程，不像创建线程会有一个对应的类或者对象。在之前的复合协程中，我们总是把协程的状态机封装在协程的完成回调Continuation实例competition中，由于这个实例提供了各种的协程能力，所以我们一般它当做复合协程本身。</p><p>使用Luna API创建协程与创建线程一样，只需提供一个函数，返回一个协程的控制类来控制协程的执行，我们可以基于Kotlin的简单协程来实现这样的一套API。</p><h2 id="非对称API实现"><a href="#非对称API实现" class="headerlink" title="非对称API实现"></a>非对称API实现</h2><p>非对称协程的主要特点就是在协程挂起时，协程控制权返回给了调用者，我们先看下实现效果，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer = Coroutine.create&lt;<span class="hljs-built_in">Unit</span>, <span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        println(<span class="hljs-string">&quot;send <span class="hljs-variable">$i</span>&quot;</span>)<br>        yield(i)<br>    &#125;<br>    <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = Coroutine.create&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Unit</span>&gt; &#123; parameter: <span class="hljs-built_in">Int</span> -&gt;<br>    println(<span class="hljs-string">&quot;start <span class="hljs-variable">$parameter</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">val</span> value = yield(<span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;receive <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive) &#123;<br>    <span class="hljs-keyword">val</span> result = producer.resume(<span class="hljs-built_in">Unit</span>)<br>    consumer.resume(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过Coroutine的伴生对象来创建协程，参数为协程体，协程体的参数类型和返回值类型由泛型参数指定。create的返回值用来控制协程的执行，结合前面几篇文章，我们知道这个返回值其实就是封装了协程状态机的实例，与SafeContinuation的作用十分类似，我们也习惯于将这个实例作为协程的完成回调，即competition。yield函数类似于序列生成器中的yield的作用，将当前协程挂起并将它的参数作为协程这一次resume调用的返回值。</p><p>状态机的状态设计是关键点，有如下几个状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Created</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yielded</span>&lt;<span class="hljs-type">P</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;P&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resumed</span>&lt;<span class="hljs-type">R</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;R&gt;) : Status()<br>    <span class="hljs-keyword">object</span> Dead : Status()<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>Created：</strong>协程处于刚刚被创建状态，需要等待resume函数的调用来启动协程。</li><li><strong>Yielded：</strong>协程内部调用yield函数后挂起，泛型参数P表示协程的参数类型。</li><li><strong>Resumed：</strong>协程外部调用resume函数之后协程恢复执行，泛型参数R表示协程的返回值类型。</li><li><strong>Dead：</strong>表示协程已经执行完毕。</li></ul><p>状态之间的转移如下所示。</p><p><img src="/img/state_transfer_02.png" alt="状态流转图"></p><p>创建一个CoroutineScope来约束yield的调用范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span>&lt;<span class="hljs-type">P, R</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">val</span> parameter: P?   <span class="hljs-comment">// 协程体启动时的参数</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于Coroutine的对象需要返回给调用者，所以我们这里不能让Coroutine来直接实现CoroutineScope，而是在内部创建了一个CoroutineScope的匿名内部类。协程描述类的部分代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coroutine</span>&lt;<span class="hljs-type">P, R</span>&gt; <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.(P) -&gt; R<br>) : Continuation&lt;R&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P, R&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>&lt;<span class="hljs-type">P</span>, R&gt;.(P)</span></span> -&gt; R<br>        ): Coroutine&lt;P, R&gt; &#123;<br>            <span class="hljs-keyword">return</span> Coroutine(context, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = <span class="hljs-keyword">object</span> : CoroutineScope&lt;P, R&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> parameter: P? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>          ... ...<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: AtomicReference&lt;Status&gt;<br>  <br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>      <span class="hljs-keyword">get</span>() = status.<span class="hljs-keyword">get</span>() != Status.Dead<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.() -&gt; R = &#123; block(parameter!!) &#125;<br>        <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(scope, <span class="hljs-keyword">this</span>)<br>        status = AtomicReference(Status.Created(start))<br>    &#125;<br>  ... ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码结构与之前的序列生成器的迭代器类似，不过有两点区别：</p><ol><li>提供了一个工厂方法create函数，用于手动创建Coroutine对象，同时返回该对象，使得外部可以控制Coroutine对象的恢复逻辑。</li><li>状态机status我们使用了AtomicReference<Status>，这是为了确保状态机的流转在多线程情况下仍然能够保证原子性。</li></ol><p>我们再来看下yield的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)  <span class="hljs-comment">// 恢复外部协程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数使用<strong>suspendCoroutine</strong>来挂起函数，这个我们已经很熟悉了。与序列生成器的yield实现不同的是，这里yield是有返回值的，为P类型也就是协程的入参类型，这使得yield同时也可以作为消费者来使用。</p><p>status.getAndUpdate接收一个参数为上一个状态，并要求返回新的状态，这个函数可能会被执行多次。当previousStatus确实是Resumed，就调用它的continuation.resume来<strong>恢复此前恢复执行当前协程的协程</strong>，这里有点绕，其实就是恢复外部协程的执行，外部协程指我们创建producer和consumer的协程。外部协程为什么会挂起跟我们的resume函数实现有关，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;  <span class="hljs-comment">// 挂起外部协程</span><br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; &#123;<br>                scope.parameter = value<br>                Status.Resumed(continuation)<br>            &#125;<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; Status.Resumed(continuation)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already resumed!&quot;</span>)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (previousStatus) &#123;  <span class="hljs-comment">// 恢复当前协程</span><br>        <span class="hljs-keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>        <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="hljs-keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当外部调用resume恢复该协程时，当前状态可能为：</p><ul><li>Created，协程只是创建，并未启动。</li><li>Yielded，协程已执行处于挂起状态。</li></ul><p>resume函数的作用是挂起外部协程，并且启动或恢复当前协程的执行。外部协程挂起后，我们将其continuation实例存入到状态机中，当当前协程yield函数被调用时，又会将外部协程恢复，使得外部协程可以继续执行后续工作，例如调用另一个协程的resume函数。文字说起来可能比较抽象，这里画了一个时序图，如下。</p><p><img src="/img/asymmetric_api.png" alt="非对称API时序图"></p><p>最后就是resumeWith的实现了，它的调用表示该协程已经执行完毕，需要将状态流转为State.Dead，同时不要忘记恢复外部协程执行，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Dead<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此，Lua风格的非对称协程API完成。</p><h2 id="对称API实现"><a href="#对称API实现" class="headerlink" title="对称API实现"></a>对称API实现</h2><p>对称协程意味着协会可以任意、平等地传递调度权。在传递过程过，调度权转出的协程需要提供目标协程的对象及参数，目标协程应处于挂起状态等待接收调度权，中间应当有一个控制中心来协助完成调度权的转移。控制中心需要具备以下能力：</p><ul><li>在当前协程挂起时接收调度权。</li><li>根据目标协程对象来完成调度权的最终转移。</li></ul><p>这个控制中心显然是一个可以恢复（当前协程挂起）和挂起（传递调度权给目标协程）的协程，实际上我们之前的非对称API中的外部协程已经具备了一些控制中心的能力，我们只需要对其进行改造即可。效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SymCoroutines &#123;<br>    <span class="hljs-keyword">val</span> coroutine0: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; params: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-0 <span class="hljs-variable">$params</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine2, <span class="hljs-number">0</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(SymCoroutine.main, <span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine1: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-1 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> result = transfer(coroutine0, <span class="hljs-number">1</span>)<br>        println(<span class="hljs-string">&quot;coroutine-1 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine2: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-2 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine1, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(coroutine0, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 2 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br>SymCoroutine.main &#123;<br>    println(<span class="hljs-string">&quot;main 0&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="hljs-number">3</span>)<br>    println(<span class="hljs-string">&quot;main end <span class="hljs-variable">$result</span>&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用<strong>SymCoroutine.create</strong>创建了多个协程，并且使用<strong>SymCoroutine.main</strong>创建了一个外部协程，这个外部协程就是控制中心，后文简称为 Main协程。Main协程通过<strong>transfer</strong>函数将调度权转移给coroutine2，从而开始了对称协程的调度权转移过程。</p><p><img src="/img/sym_coroutine_sequence_diagram.png" alt="调度权转移时序图"></p><p>与之前一样，我们定义一个作用域接口来提供transfer函数，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，泛型参数T为对称协程的参数类型，而transfer函数的泛型参数P表示目标协程的参数类型，对称协程自身的定义决定了它不存在返回值，这点与非对称协程不同。</p><p>接下来就是协程描述类SymCoroutine以及它的create和main函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> main: SymCoroutine&lt;Any?&gt;<br><br>        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">Any</span>?&gt;.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span> &#123;<br>            SymCoroutine&lt;Any?&gt; &#123;<br>                block()<br>            &#125;.also &#123;<br>                main = it<br>            &#125;.start(<span class="hljs-built_in">Unit</span>)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: SymCoroutine&lt;T&gt; = SymCoroutine(context, block)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        ... ...<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> isMain: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span> == main<br>    ... ... <br>&#125;<br></code></pre></div></td></tr></table></figure><p>main函数的作用是创建Main协程，同时会将其赋值给伴生对象属性main，方便其他协程将调度权归还给控制中心。</p><p>接下来我们思考下当前协程如何将调度权转出。<strong>由于当前协程本质上是由Main协程启动的协程，因此只要调用内部的非对称协程的yield函数将自身挂起，调度权自然就交回到了Main协程手中</strong>。Main协程只需要读取它自己的resume的返回值即可得到目标协程对象及参数。因此yield的参数类型定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameter</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="hljs-keyword">val</span> value: T)<br></code></pre></div></td></tr></table></figure><p>SymCoroutin内部的非对称协程的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    ... ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coroutine = Coroutine.create&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;<br>        Parameter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>, <span class="hljs-keyword">suspend</span> &#123;<br>            block(body, it)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) <span class="hljs-built_in">Unit</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>        &#125;() <span class="hljs-keyword">as</span> T)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        coroutine.resume(value)<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于内部的非对称协程而言，yield函数的参数类型**Parameter<T>**自然就是它的返回值类型，因此我们看到携程体内构造了一个Parameter的实例。不过我们在传入Parameter参数的时候，应传入目标协程和目标协程的参数，但这里我们传入了this，这是为什么呢？因为这是协程执行完后的最后一行代码，由于对称协程在执行完成之前必须交出调度权，所以这段代码只会被特权协程执行。第二个参数也是如此，创建了一个Lambda表达式并且理解调用了它，并在其中执行了block触发协程体的执行，普通的对称协程在block内部就会通过调用transfer交出调度权。</p><p>接下来是最关键的transfer函数的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">tailrec</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transferInner</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">            value: <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) &#123; <span class="hljs-comment">// Main协程在转移调度权</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (symCoroutine.isMain) &#123;<br>                    value <span class="hljs-keyword">as</span> T  <span class="hljs-comment">// ... ③</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="hljs-keyword">as</span> P)  <span class="hljs-comment">// ... ①</span><br>                    transferInner(parameter.coroutine, parameter.value)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 对称协程转移调度权到其他协程或者Main协程</span><br>                coroutine.run &#123;<br>                    <span class="hljs-keyword">return</span> yield(Parameter(symCoroutine, value <span class="hljs-keyword">as</span> P))  <span class="hljs-comment">// ... ②</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T &#123;<br>            <span class="hljs-keyword">return</span> transferInner(symCoroutine, value)<br>        &#125;<br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们按照之前代码的执行逻辑来分析一下transfer的调用逻辑。</p><ul><li>程序开始执行时，调度权最开始在特权协程手中，调用transfer将调度权转给coroutine2，transferInner入参symCoroutine为coroutine2，在①处调用coroutine2的resume挂起Main协程，coroutine2开始执行。</li><li>接下来coroutine2调用transfer函数转给coroutine1时，先将调度权交出，实际上就是在②处调用yield将自己挂起，此时接收调度权的Main协程在①处的resume函数返回，parameter中携带的其实就是coroutine1和它的参数。</li><li>此时Main协程中递归调用transferInner并再次进入①处挂起自己，由于coroutine1尚未启动，因此直接开始执行，直到调用transfer转给coroutine0。</li><li>最终，在coroutine()中将调度权归还给Main协程，transferInner落入③处分支直接返回。</li></ul><p>至此，基于非对称协程API实现的对称协程API原理分析完毕。</p><h2 id="复合协程的实现模式"><a href="#复合协程的实现模式" class="headerlink" title="复合协程的实现模式"></a>复合协程的实现模式</h2><p>结合本篇以及前面几篇文章几个案例的实现，我们可以把<strong>复合协程实现模式</strong>归纳如下。</p><ul><li><strong>协程的构造器</strong>。我们总是需要一套更好更简便的API来创建协程，例如async{ … }或者Coroutine.create{ … }。</li><li><strong>协程的返回值</strong>。协程可以有返回值，这一点主要是由协程完成时对completion的调用来保证的。</li><li><strong>协程的状态机</strong>。在Kotlin协程的基础设施中，协程本身已经存在创建、执行、挂起、完成等状态了，我们通常需要对这些状态进行管理以控制协程的执行逻辑。状态流转过程在并发环境下需要考虑并发安全问题，我们可以在状态流转时通过加锁来确保这一点，也可以采用更高效的CAS算法来确保状态流转的原子性。</li><li><strong>协程的作用域</strong>。作用域主要用作协程体的Receiver，从而令协程体能够方便地获得协程自身的信息或者调用协程体专属的函数（例如yield）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——复合协程</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将介绍两种序列生成器，序列生成器包含“序列”和“生成器”两部分，我们先来仿写一个Python的Generator。</p><h2 id="序列生成器"><a href="#序列生成器" class="headerlink" title="序列生成器"></a>序列生成器</h2><h3 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h3><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums: (<span class="hljs-built_in">Int</span>) -&gt; Generator&lt;<span class="hljs-built_in">Int</span>&gt; = generator &#123; start: <span class="hljs-built_in">Int</span> -&gt;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) &#123;<br>        yield(start + i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> gen: Generator&lt;<span class="hljs-built_in">Int</span>&gt; = nums(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> gen) &#123;<br>    println(j)<br>&#125;<br><br><span class="hljs-comment">// 运行结果 </span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt; = GeneratorIterator(block, parameter)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建一个序列生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReady</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : State()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ready</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, <span class="hljs-keyword">val</span> nextValue: T) : State()<br>    <span class="hljs-keyword">object</span> Done : State()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取下一个元素</span><br><span class="hljs-comment"> * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程</span><br><span class="hljs-comment"> * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; &#123;<br>            resume()<br>            <span class="hljs-keyword">return</span> next()<br>        &#125;<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;<br>            state = State.NotReady(currentState.continuation)<br>            (currentState <span class="hljs-keyword">as</span> State.Ready&lt;T&gt;).nextValue<br>        &#125;<br>        State.Done -&gt; &#123;<br>            <span class="hljs-keyword">throw</span>  IndexOutOfBoundsException(<span class="hljs-string">&quot;No value left.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用suspendCoroutine挂起当前协程</span><br><span class="hljs-comment"> * 并将当前状态流转为[State.Ready]状态，返回value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    state = <span class="hljs-keyword">when</span> (state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;cannot yield while ready.&quot;</span>)<br>        <span class="hljs-keyword">is</span> State.Done -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;cannot yield while done.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    resume()<br>    <span class="hljs-keyword">return</span> state != State.Done<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动或者恢复协程</span><br><span class="hljs-comment"> * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建协程的completion回调</span><br><span class="hljs-comment"> * 协程执行完成后回调</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    state = State.Done<br>    println(result.getOrThrow())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; block(parameter) &#125;<br>    <span class="hljs-comment">// 带Receiver的方式创建协程</span><br>    <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 初始化状态</span><br>    state = State.NotReady(start)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorIterator</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : GeneratorScope&lt;T&gt;, Iterator&lt;T&gt;, Continuation&lt;Any?&gt;<br></code></pre></div></td></tr></table></figure><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h3 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h3><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sequence = sequence &#123;<br>        yield(<span class="hljs-number">1</span>)<br>        yield(<span class="hljs-number">2</span>)<br>        yield(<span class="hljs-number">3</span>)<br>        yieldAll(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>&#125;<br><br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">in</span> sequence) &#123;<br>    println(num)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fibonacci = sequence &#123;<br>    yield(<span class="hljs-number">1L</span>)<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">var</span> next = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        yield(next)<br>        next += current<br>        current = next - current<br>    &#125;<br>&#125;<br><br>fibonacci.take(<span class="hljs-number">10</span>).forEach(::println) <span class="hljs-comment">// 使用take(10)获取前10个元素</span><br></code></pre></div></td></tr></table></figure><h2 id="Promise-模型"><a href="#Promise-模型" class="headerlink" title="Promise 模型"></a>Promise 模型</h2><p>Promise模型又叫async/await，是目前最常见也最容易理解和上手的协程实现。</p><p>async/await的设计可以在async函数内部对复合Promise协议的异步回调进行await，使得异步逻辑变成了同步代码。这是目前主流的协程实现，它的关键在于将函数分为两种：</p><ul><li>普通函数：只能够调用普通函数，不存在协程的挂起和恢复逻辑。</li><li>async函数：既可以调用普通函数，也可以调用async函数，且可以将回调通过await同步化。</li></ul><p>async和wait各司其职，分别实现协程的挂起和恢复的逻辑，上手几乎没有成本。</p><h3 id="仿JavaScript的async-await实现"><a href="#仿JavaScript的async-await实现" class="headerlink" title="仿JavaScript的async/await实现"></a>仿JavaScript的async/await实现</h3><p>利用kotlin协程实现一个async/await的复合协程，效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">async &#123;<br>    <span class="hljs-keyword">val</span> user = await &#123; gitHubApi.getUserCallback(<span class="hljs-string">&quot;sukaidev&quot;</span>) &#125;<br>    println(user)<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>User(userName=sukaidev, blog=https:<span class="hljs-comment">//www.sukaidev.top, location=GuangZhou,China, bio=Focus on Jetpack)</span><br></code></pre></div></td></tr></table></figure><p>先思考下async如何实现。async接收一个函数作为参数，这个函数即协程体，必然是个挂起函数。async创建成功后协程即启动，并且内部可以使用await方法来挂起协程。async函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">AsyncScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> completion = AsyncCoroutine(context)<br>    block.startCoroutine(completion, completion)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCoroutine</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext) :<br>    Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, AsyncScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        result.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于async启动的协程不需要返回值，所以作为completion存在的AsyncCoroutine没有泛型参数。</p><p>await函数定义在AsyncScope中，使得它可以在async构造的协程中调用，它主要的作用就是将网络请求的回调转为协程，使用suspendCoroutine实现即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncScope</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">await</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> call = block()<br>        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                    response.body()?.let(continuation::resume)<br>                        ?: continuation.resumeWithException(NullPointerException())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                continuation.resumeWithException(HttpException(response))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                continuation.resumeWithException(t)<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>async/await的状态比较简单，只有挂起以及被封装的回调完成状态，状态之间的流转由await单独来完成，因此不需要额外的状态机实现。当我们引入了协程的取消处理、异常处理等逻辑后，状态机的存在就至关重要了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——基本原理</title>
    <link href="/2021/02/03/2a3d271f/"/>
    <url>/2021/02/03/2a3d271f/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    continuation.resume(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即连续传递样式变换。CPS是一种编程风格，用来将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者，这就将它的程序流程显式的暴露给程序员。而CPS变换就是将原本不是CPS风格的代码转变为CPS风格，通常由编译器来对代码进行优化，<strong>而Kotlin协程能够采用同步的方式书写异步代码的原理正是由于编译器使用了CPS变换</strong>。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend</strong>函数发现，<strong>notSuspend</strong>函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，即是<strong>CPS变换</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));<br>   Continuation continuation = (Continuation)var4;<br>   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;<br>   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;<br>   Companion var10 = Result.Companion;<br>   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;<br>   continuation.resumeWith(Result.constructor-impl(var8));<br>   Object var10000 = var4.getOrThrow();<br>   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>      DebugProbesKt.probeCoroutineSuspended($completion);<br>   &#125;<br>   <span class="hljs-keyword">return</span> var10000;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span><br>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;<br>        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;<br>        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span><br>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception<br>        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    <span class="hljs-keyword">val</span> deferred = async &#123;<br>        <span class="hljs-comment">// 发起了一个网络请求</span><br>        ......<br>    &#125;<br>    <span class="hljs-comment">// 做了一些操作</span><br>    ......<br>    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span><br>    <span class="hljs-comment">// 后续的一些操作</span><br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br></code></pre></div></td></tr></table></figure><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span><br>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span><br></code></pre></div></td></tr></table></figure><p>我们来看下协程上下文中的元素类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element<br></code></pre></div></td></tr></table></figure><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :<br>    AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)<br>coroutineContext += CoroutineExceptionHandler&#123;<br>    <span class="hljs-comment">//  ... ...</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        println(context[CoroutineName]?.name)<br>        result.onFailure &#123;<br>            context[CoroutineExceptionHandler]?.onError(it)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :<br>    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br></code></pre></div></td></tr></table></figure><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));<br></code></pre></div></td></tr></table></figure><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p><strong>Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现</strong>。不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br> SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></div></td></tr></table></figure><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)<br>    <span class="hljs-string">&quot;return value.&quot;</span><br>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><br><br><span class="hljs-comment">// 控制台输出：</span><br>Coroutine Start.<br>Coroutine End : Success(<span class="hljs-keyword">return</span> value.)<br></code></pre></div></td></tr></table></figure><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br> createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，这里就不贴源码了毕竟这篇只是个初识（笑），这里要说的是SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)<br></code></pre></div></td></tr></table></figure><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br></code></pre></div></td></tr></table></figure><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(value.toString())<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)<br>        print(<span class="hljs-number">1000</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        hashCode(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们**main()**函数可以直接被声明为suspend：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.result = result<br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
