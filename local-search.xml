<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——基本原理</title>
    <link href="/2021/02/03/2a3d271f/"/>
    <url>/2021/02/03/2a3d271f/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;    <span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;    thread &#123;        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))    &#125;&#125;</code></pre></div><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;    continuation.resume(<span class="hljs-number">100</span>)&#125;</code></pre></div><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即Continuation传递变换，通过传递Continuation实例来控制异步调用流程。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend()**函数发现，</strong>notSuspend()<strong>函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，我们称为</strong>CPS变换**。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));   Continuation continuation = (Continuation)var4;   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;   Companion var10 = Result.Companion;   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;   continuation.resumeWith(Result.constructor-impl(var8));   Object var10000 = var4.getOrThrow();   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;      DebugProbesKt.probeCoroutineSuspended($completion);   &#125;   <span class="hljs-keyword">return</span> var10000;&#125;</code></pre></div><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span>    &#125;&#125;</code></pre></div><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;    <span class="hljs-keyword">val</span> deferred = async &#123;        <span class="hljs-comment">// 发起了一个网络请求</span>        ......    &#125;    <span class="hljs-comment">// 做了一些操作</span>    ......    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span>    <span class="hljs-comment">// 后续的一些操作</span>    ......&#125;</code></pre></div><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext</code></pre></div><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span></code></pre></div><p>我们来看下协程上下文中的元素类型：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * A key of this coroutine context element.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =        operation(initial, <span class="hljs-keyword">this</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>&#125;</code></pre></div><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element</code></pre></div><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :    AbstractCoroutineContextElement(Key) &#123;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;        error.printStackTrace()        onErrorAction(error)    &#125;&#125;</code></pre></div><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)coroutineContext += CoroutineExceptionHandler&#123;    <span class="hljs-comment">//  ... ...</span>&#125;<span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;        println(context[CoroutineName]?.name)        result.onFailure &#123;            context[CoroutineExceptionHandler]?.onError(it)        &#125;    &#125;&#125;)</code></pre></div><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =        LogContinuation(continuation)&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)        continuation.resumeWith(result)        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)    &#125;&#125;</code></pre></div><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)after resumeWith.before resumeWith : Success(<span class="hljs-number">5</span>)after resumeWith.before resumeWith : Success(<span class="hljs-number">5</span>)after resumeWith.</code></pre></div><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));</code></pre></div><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =        intercepted            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)                .also &#123; intercepted = it &#125;</code></pre></div><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><p>参考：</p><p>Kotlin标准库1.4.21</p><p><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念</title>
    <link href="/2021/02/03/595755ca/"/>
    <url>/2021/02/03/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p>**Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现。 **不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(    completion: Continuation&lt;T&gt;): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</code></pre></div><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)    <span class="hljs-string">&quot;return value.&quot;</span>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)    &#125;&#125;)</code></pre></div><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><span class="hljs-comment">// 控制台输出：</span>Coroutine Start.Coroutine End : Success(<span class="hljs-keyword">return</span> value.)</code></pre></div><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(    completion: Continuation&lt;T&gt;) &#123; createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)&#125;</code></pre></div><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，这里就不贴源码了毕竟这篇只是个初识（笑），这里要说的是SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)</code></pre></div><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(    receiver: R,    completion: Continuation&lt;T&gt;)<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(    receiver: R,    completion: Continuation&lt;T&gt;)</code></pre></div><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)        &#125;    &#125;)&#125;</code></pre></div><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;        println(value.toString())    &#125;    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)&#125; <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)        print(<span class="hljs-number">1000</span>)        delay(<span class="hljs-number">1000L</span>)        hashCode(<span class="hljs-number">1000</span>)    &#125;&#125;</code></pre></div><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们**main()**函数可以直接被声明为suspend：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ... ...&#125;</code></pre></div><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));&#125;</code></pre></div><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;    <span class="hljs-keyword">val</span> run = RunSuspend()    block.startCoroutine(run)    run.await()&#125;</code></pre></div><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;    <span class="hljs-keyword">this</span>.result = result    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()            <span class="hljs-keyword">else</span> -&gt; &#123;                result.getOrThrow() <span class="hljs-comment">// throw up failure</span>                <span class="hljs-keyword">return</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><p>参考：</p><p><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a></p><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
