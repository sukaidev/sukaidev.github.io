<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（四）——Luna风格的协程API</title>
    <link href="/2021/02/08/ded91b47/"/>
    <url>/2021/02/08/ded91b47/</url>
    
    <content type="html"><![CDATA[<p>我们在使用Kotlin协程时，总是说创建了一个协程，不像创建线程会有一个对应的类或者对象。在之前的复合协程中，我们总是把协程的状态机封装在协程的完成回调Continuation实例competition中，由于这个实例提供了各种的协程能力，所以我们一般它当做复合协程本身。</p><p>使用Luna API创建协程与创建线程一样，只需提供一个函数，返回一个协程的控制类来控制协程的执行，我们可以基于Kotlin的简单协程来实现这样的一套API。</p><h2 id="非对称API实现"><a href="#非对称API实现" class="headerlink" title="非对称API实现"></a>非对称API实现</h2><p>非对称协程的主要特点就是在协程挂起时，协程控制权返回给了调用者，我们先看下实现效果，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> producer = Coroutine.create&lt;<span class="hljs-built_in">Unit</span>, <span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        println(<span class="hljs-string">&quot;send <span class="hljs-variable">$i</span>&quot;</span>)<br>        yield(i)<br>    &#125;<br>    <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">val</span> consumer = Coroutine.create&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Unit</span>&gt; &#123; parameter: <span class="hljs-built_in">Int</span> -&gt;<br>    println(<span class="hljs-string">&quot;start <span class="hljs-variable">$parameter</span>&quot;</span>)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">val</span> value = yield(<span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;receive <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive) &#123;<br>    <span class="hljs-keyword">val</span> result = producer.resume(<span class="hljs-built_in">Unit</span>)<br>    consumer.resume(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过Coroutine的伴生对象来创建协程，参数为协程体，协程体的参数类型和返回值类型由泛型参数指定。create的返回值用来控制协程的执行，结合前面几篇文章，我们知道这个返回值其实就是封装了协程状态机的实例，与SafeContinuation的作用十分类似，我们也习惯于将这个实例作为协程的完成回调，即competition。yield函数类似于序列生成器中的yield的作用，将当前协程挂起并将它的参数作为协程这一次resume调用的返回值。</p><p>状态机的状态设计是关键点，有如下几个状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Created</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yielded</span>&lt;<span class="hljs-type">P</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;P&gt;) : Status()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resumed</span>&lt;<span class="hljs-type">R</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;R&gt;) : Status()<br>    <span class="hljs-keyword">object</span> Dead : Status()<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>Created：</strong>协程处于刚刚被创建状态，需要等待resume函数的调用来启动协程。</li><li><strong>Yielded：</strong>协程内部调用yield函数后挂起，泛型参数P表示协程的参数类型。</li><li><strong>Resumed：</strong>协程外部调用resume函数之后协程恢复执行，泛型参数R表示协程的返回值类型。</li><li><strong>Dead：</strong>表示协程已经执行完毕。</li></ul><p>状态之间的转移如下所示。</p><p><img src="/img/state_transfer_02.png" alt="状态流转图"></p><p>创建一个CoroutineScope来约束yield的调用范围：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span>&lt;<span class="hljs-type">P, R</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">val</span> parameter: P?   <span class="hljs-comment">// 协程体启动时的参数</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于Coroutine的对象需要返回给调用者，所以我们这里不能让Coroutine来直接实现CoroutineScope，而是在内部创建了一个CoroutineScope的匿名内部类。协程描述类的部分代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coroutine</span>&lt;<span class="hljs-type">P, R</span>&gt; <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.(P) -&gt; R<br>) : Continuation&lt;R&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P, R&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>&lt;<span class="hljs-type">P</span>, R&gt;.(P)</span></span> -&gt; R<br>        ): Coroutine&lt;P, R&gt; &#123;<br>            <span class="hljs-keyword">return</span> Coroutine(context, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = <span class="hljs-keyword">object</span> : CoroutineScope&lt;P, R&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> parameter: P? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>          ... ...<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: AtomicReference&lt;Status&gt;<br>  <br>    <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span><br>      <span class="hljs-keyword">get</span>() = status.<span class="hljs-keyword">get</span>() != Status.Dead<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> CoroutineScope&lt;P, R&gt;.() -&gt; R = &#123; block(parameter!!) &#125;<br>        <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(scope, <span class="hljs-keyword">this</span>)<br>        status = AtomicReference(Status.Created(start))<br>    &#125;<br>  ... ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码结构与之前的序列生成器的迭代器类似，不过有两点区别：</p><ol><li>提供了一个工厂方法create函数，用于手动创建Coroutine对象，同时返回该对象，使得外部可以控制Coroutine对象的恢复逻辑。</li><li>状态机status我们使用了AtomicReference<Status>，这是为了确保状态机的流转在多线程情况下仍然能够保证原子性。</li></ol><p>我们再来看下yield的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)  <span class="hljs-comment">// 恢复外部协程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数使用<strong>suspendCoroutine</strong>来挂起函数，这个我们已经很熟悉了。与序列生成器的yield实现不同的是，这里yield是有返回值的，为P类型也就是协程的入参类型，这使得yield同时也可以作为消费者来使用。</p><p>status.getAndUpdate接收一个参数为上一个状态，并要求返回新的状态，这个函数可能会被执行多次。当previousStatus确实是Resumed，就调用它的continuation.resume来<strong>恢复此前恢复执行当前协程的协程</strong>，这里有点绕，其实就是恢复外部协程的执行，外部协程指我们创建producer和consumer的协程。外部协程为什么会挂起跟我们的resume函数实现有关，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;  <span class="hljs-comment">// 挂起外部协程</span><br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; &#123;<br>                scope.parameter = value<br>                Status.Resumed(continuation)<br>            &#125;<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; Status.Resumed(continuation)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already resumed!&quot;</span>)<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (previousStatus) &#123;  <span class="hljs-comment">// 恢复当前协程</span><br>        <span class="hljs-keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>        <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="hljs-keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当外部调用resume恢复该协程时，当前状态可能为：</p><ul><li>Created，协程只是创建，并未启动。</li><li>Yielded，协程已执行处于挂起状态。</li></ul><p>resume函数的作用是挂起外部协程，并且启动或恢复当前协程的执行。外部协程挂起后，我们将其continuation实例存入到状态机中，当当前协程yield函数被调用时，又会将外部协程恢复，使得外部协程可以继续执行后续工作，例如调用另一个协程的resume函数。文字说起来可能比较抽象，这里画了一个时序图，如下。</p><p><img src="/img/asymmetric_api.png" alt="非对称API时序图"></p><p>最后就是resumeWith的实现了，它的调用表示该协程已经执行完毕，需要将状态流转为State.Dead，同时不要忘记恢复外部协程执行，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">R</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> previousStatus = status.getAndUpdate &#123;<br>        <span class="hljs-keyword">when</span> (it) &#123;<br>            <span class="hljs-keyword">is</span> Status.Created -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Never started!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;Already yielded!&quot;</span>)<br>            <span class="hljs-keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Dead<br>            Status.Dead -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Already dead!&quot;</span>)<br>        &#125;<br>    &#125;<br>    (previousStatus <span class="hljs-keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resumeWith(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此，Lua风格的非对称协程API完成。</p><h2 id="对称API实现"><a href="#对称API实现" class="headerlink" title="对称API实现"></a>对称API实现</h2><p>对称协程意味着协会可以任意、平等地传递调度权。在传递过程过，调度权转出的协程需要提供目标协程的对象及参数，目标协程应处于挂起状态等待接收调度权，中间应当有一个控制中心来协助完成调度权的转移。控制中心需要具备以下能力：</p><ul><li>在当前协程挂起时接收调度权。</li><li>根据目标协程对象来完成调度权的最终转移。</li></ul><p>这个控制中心显然是一个可以恢复（当前协程挂起）和挂起（传递调度权给目标协程）的协程，实际上我们之前的非对称API中的外部协程已经具备了一些控制中心的能力，我们只需要对其进行改造即可。效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SymCoroutines &#123;<br>    <span class="hljs-keyword">val</span> coroutine0: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; params: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-0 <span class="hljs-variable">$params</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine2, <span class="hljs-number">0</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(SymCoroutine.main, <span class="hljs-built_in">Unit</span>)<br>        println(<span class="hljs-string">&quot;coroutine-0 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine1: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-1 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">val</span> result = transfer(coroutine0, <span class="hljs-number">1</span>)<br>        println(<span class="hljs-string">&quot;coroutine-1 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine2: SymCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; = SymCoroutine.create &#123; param: <span class="hljs-built_in">Int</span> -&gt;<br>        println(<span class="hljs-string">&quot;coroutine-2 <span class="hljs-variable">$param</span>&quot;</span>)<br>        <span class="hljs-keyword">var</span> result = transfer(coroutine1, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 1 <span class="hljs-variable">$result</span>&quot;</span>)<br>        result = transfer(coroutine0, <span class="hljs-number">2</span>)<br>        println(<span class="hljs-string">&quot;coroutine-2 2 <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br>SymCoroutine.main &#123;<br>    println(<span class="hljs-string">&quot;main 0&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = transfer(SymCoroutines.coroutine2, <span class="hljs-number">3</span>)<br>    println(<span class="hljs-string">&quot;main end <span class="hljs-variable">$result</span>&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们使用<strong>SymCoroutine.create</strong>创建了多个协程，并且使用<strong>SymCoroutine.main</strong>创建了一个外部协程，这个外部协程就是控制中心，后文简称为 Main协程。Main协程通过<strong>transfer</strong>函数将调度权转移给coroutine2，从而开始了对称协程的调度权转移过程。</p><p><img src="/img/sym_coroutine_sequence_diagram.png" alt="调度权转移时序图"></p><p>与之前一样，我们定义一个作用域接口来提供transfer函数，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要注意的是，泛型参数T为对称协程的参数类型，而transfer函数的泛型参数P表示目标协程的参数类型，对称协程自身的定义决定了它不存在返回值，这点与非对称协程不同。</p><p>接下来就是协程描述类SymCoroutine以及它的create和main函数的定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> main: SymCoroutine&lt;Any?&gt;<br><br>        <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">Any</span>?&gt;.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span> &#123;<br>            SymCoroutine&lt;Any?&gt; &#123;<br>                block()<br>            &#125;.also &#123;<br>                main = it<br>            &#125;.start(<span class="hljs-built_in">Unit</span>)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">            block: <span class="hljs-type">suspend</span> <span class="hljs-type">SymCoroutineScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: SymCoroutine&lt;T&gt; = SymCoroutine(context, block)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        ... ...<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> isMain: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span> == main<br>    ... ... <br>&#125;<br></code></pre></div></td></tr></table></figure><p>main函数的作用是创建Main协程，同时会将其赋值给伴生对象属性main，方便其他协程将调度权归还给控制中心。</p><p>接下来我们思考下当前协程如何将调度权转出。<strong>由于当前协程本质上是由Main协程启动的协程，因此只要调用内部的非对称协程的yield函数将自身挂起，调度权自然就交回到了Main协程手中</strong>。Main协程只需要读取它自己的resume的返回值即可得到目标协程对象及参数。因此yield的参数类型定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parameter</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> coroutine: SymCoroutine&lt;T&gt;, <span class="hljs-keyword">val</span> value: T)<br></code></pre></div></td></tr></table></figure><p>SymCoroutin内部的非对称协程的定义如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    ... ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> coroutine = Coroutine.create&lt;T, Parameter&lt;*&gt;&gt;(context) &#123;<br>        Parameter(<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>, <span class="hljs-keyword">suspend</span> &#123;<br>            block(body, it)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) <span class="hljs-built_in">Unit</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>        &#125;() <span class="hljs-keyword">as</span> T)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;SymCoroutine cannot be dead.&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        coroutine.resume(value)<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于内部的非对称协程而言，yield函数的参数类型**Parameter<T>**自然就是它的返回值类型，因此我们看到携程体内构造了一个Parameter的实例。不过我们在传入Parameter参数的时候，应传入目标协程和目标协程的参数，但这里我们传入了this，这是为什么呢？因为这是协程执行完后的最后一行代码，由于对称协程在执行完成之前必须交出调度权，所以这段代码只会被特权协程执行。第二个参数也是如此，创建了一个Lambda表达式并且理解调用了它，并在其中执行了block触发协程体的执行，普通的对称协程在block内部就会通过调用transfer交出调度权。</p><p>接下来是最关键的transfer函数的实现，如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> SymCoroutineScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span><br>) : Continuation&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> body: SymCoroutineScope&lt;T&gt; = <span class="hljs-keyword">object</span> : SymCoroutineScope&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">tailrec</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transferInner</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">            value: <span class="hljs-type">Any</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span><span class="hljs-symbol">@SymCoroutine</span>.isMain) &#123; <span class="hljs-comment">// Main协程在转移调度权</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (symCoroutine.isMain) &#123;<br>                    value <span class="hljs-keyword">as</span> T  <span class="hljs-comment">// ... ③</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> parameter = symCoroutine.coroutine.resume(value <span class="hljs-keyword">as</span> P)  <span class="hljs-comment">// ... ①</span><br>                    transferInner(parameter.coroutine, parameter.value)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 对称协程转移调度权到其他协程或者Main协程</span><br>                coroutine.run &#123;<br>                    <span class="hljs-keyword">return</span> yield(Parameter(symCoroutine, value <span class="hljs-keyword">as</span> P))  <span class="hljs-comment">// ... ②</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;P&gt;</span> <span class="hljs-title">transfer</span><span class="hljs-params">(symCoroutine: <span class="hljs-type">SymCoroutine</span>&lt;<span class="hljs-type">P</span>&gt;, value: <span class="hljs-type">P</span>)</span></span>: T &#123;<br>            <span class="hljs-keyword">return</span> transferInner(symCoroutine, value)<br>        &#125;<br>    &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们按照之前代码的执行逻辑来分析一下transfer的调用逻辑。</p><ul><li>程序开始执行时，调度权最开始在特权协程手中，调用transfer将调度权转给coroutine2，transferInner入参symCoroutine为coroutine2，在①处调用coroutine2的resume挂起Main协程，coroutine2开始执行。</li><li>接下来coroutine2调用transfer函数转给coroutine1时，先将调度权交出，实际上就是在②处调用yield将自己挂起，此时接收调度权的Main协程在①处的resume函数返回，parameter中携带的其实就是coroutine1和它的参数。</li><li>此时Main协程中递归调用transferInner并再次进入①处挂起自己，由于coroutine1尚未启动，因此直接开始执行，直到调用transfer转给coroutine0。</li><li>最终，在coroutine()中将调度权归还给Main协程，transferInner落入③处分支直接返回。</li></ul><p>至此，基于非对称协程API实现的对称协程API原理分析完毕。</p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（三）——复合协程</title>
    <link href="/2021/02/05/7963e723/"/>
    <url>/2021/02/05/7963e723/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们将介绍两种序列生成器，序列生成器包含“序列”和“生成器”两部分，我们先来仿写一个Python的Generator。</p><h2 id="序列生成器"><a href="#序列生成器" class="headerlink" title="序列生成器"></a>序列生成器</h2><h3 id="仿Python的Generator实现"><a href="#仿Python的Generator实现" class="headerlink" title="仿Python的Generator实现"></a>仿Python的Generator实现</h3><p>Python中的Generator可以在函数中调用yield将当前函数挂起并返回yield的参数，效果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nums: (<span class="hljs-built_in">Int</span>) -&gt; Generator&lt;<span class="hljs-built_in">Int</span>&gt; = generator &#123; start: <span class="hljs-built_in">Int</span> -&gt;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) &#123;<br>        yield(start + i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> gen: Generator&lt;<span class="hljs-built_in">Int</span>&gt; = nums(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> gen) &#123;<br>    println(j)<br>&#125;<br><br><span class="hljs-comment">// 运行结果 </span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>我们通过generator函数来得到一个新的函数nums，通过调用这个函数我们可以得到一个序列生成器Generator，Generator需要重载iterator操作符并且返回一个迭代器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt; = GeneratorIterator(block, parameter)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建一个序列生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来思考一下这个<strong>GeneratorIterator</strong>迭代器要怎么写。当<strong>GeneratorIterator#next</strong>被调用时，我们需要获取到<strong>yield</strong>函数返回的数据，同时yield函数将会挂起协程，当我们下一次获取数据时恢复协程执行，获取到下一个数据后再挂起。也就是说<strong>next</strong>函数除了获取下一个数据之外，还要配合yield函数恢复协程的执行，我们根据当前迭代器的状态总结出下面几种情况：</p><ul><li><strong>下个数据未准备完成</strong>。此状态表示协程尚未启动或者协程挂起后尚未恢复，此时调用next我们需要恢复协程的执行</li><li><strong>下个数据准备完成</strong>。恢复执行后，yield函数被调用，此时我们拿到了下一个数据，协程需要被挂起等待恢复执行。</li><li>生成器执行完毕。无更多数据产生。</li></ul><p>根据上面的分析我们定义出几种状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotReady</span></span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;) : State()<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ready</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> continuation: Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, <span class="hljs-keyword">val</span> nextValue: T) : State()<br>    <span class="hljs-keyword">object</span> Done : State()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>序列生成时，<strong>next</strong>函数和<strong>yield</strong>相互配合实现状态的流转，next函数需要恢复协程的执行，yield函数需要挂起协程同时将产生的数据传递给next函数返回，因此这里我们将等待恢复的continuation实例和返回的数据作为入参添加到状态中方便两个函数获取。</p><p>这几种状态的状态流转关系图如下：</p><p><img src="/img/state_transfer.png" alt="状态流转图"></p><p>根据状态流转图编写GeneratorIterator的部分代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取下一个元素</span><br><span class="hljs-comment"> * 当状态为[State.NotReady]时，表示协程未启动或已经挂起，调用[resume]函数启动或者恢复协程</span><br><span class="hljs-comment"> * 当状态为[State.Ready]时，返回yield携带过来的value，并且将当前状态流转为[State.NotReady]状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; &#123;<br>            resume()<br>            <span class="hljs-keyword">return</span> next()<br>        &#125;<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;<br>            state = State.NotReady(currentState.continuation)<br>            (currentState <span class="hljs-keyword">as</span> State.Ready&lt;T&gt;).nextValue<br>        &#125;<br>        State.Done -&gt; &#123;<br>            <span class="hljs-keyword">throw</span>  IndexOutOfBoundsException(<span class="hljs-string">&quot;No value left.&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用suspendCoroutine挂起当前协程</span><br><span class="hljs-comment"> * 并将当前状态流转为[State.Ready]状态，返回value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; &#123; continuation -&gt;<br>    state = <span class="hljs-keyword">when</span> (state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; State.Ready(continuation, value)<br>        <span class="hljs-keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;cannot yield while ready.&quot;</span>)<br>        <span class="hljs-keyword">is</span> State.Done -&gt; <span class="hljs-keyword">throw</span>  IllegalStateException(<span class="hljs-string">&quot;cannot yield while done.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在yield函数的实现中，我们对当前的状态进行了判断，这是复合协程的一个核心逻辑：<strong>状态机</strong>。无论是何种场景下的协程，都会有挂起、恢复、结束等相应的状态需要维护，同时在有对应的事件到达时也需要完成状态的转移。状态转移务必考虑原子性，kotlin核心库中的状态转移都通过CAS操作来更新，由于本例仅限于单线程中使用，所以这里没有考虑线程安全问题。yield函数定义在协程作用域中：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>yield函数处理了挂起事件，对应的我们也需要合适时候处理协程的恢复、完成等事件，下面函数都完成了部分时间的状态转移：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    resume()<br>    <span class="hljs-keyword">return</span> state != State.Done<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动或者恢复协程</span><br><span class="hljs-comment"> * 假设事实上的挂起发生了n次，那么[resume]将被调用n+1次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) &#123;<br>        <span class="hljs-keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建协程的completion回调</span><br><span class="hljs-comment"> * 协程执行完成后回调</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>    state = State.Done<br>    println(result.getOrThrow())<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们已经完成比较关键的状态流转代码，但我们还没有创建协程，我们在<strong>GeneratorIterator</strong>构造函数中创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> coroutineBlock: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; block(parameter) &#125;<br>    <span class="hljs-comment">// 带Receiver的方式创建协程</span><br>    <span class="hljs-keyword">val</span> start = coroutineBlock.createCoroutine(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 初始化状态</span><br>    state = State.NotReady(start)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用带Receiver的方式创建协程的好处是我们可以使用作用域中的方法，也就是<strong>yield</strong>函数。这里createCoroutine的两个个参数我们都传入了this，即<strong>GeneratorIterator</strong>同时实现了GeneratorScope接口和Continuation接口，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorIterator</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: <span class="hljs-keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="hljs-built_in">Unit</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parameter: T<br>) : GeneratorScope&lt;T&gt;, Iterator&lt;T&gt;, Continuation&lt;Any?&gt;<br></code></pre></div></td></tr></table></figure><p>实现GeneratorScope接口我们可以复写或者实现yield函数，而实现Continuation的好处是<strong>GeneratorIterator</strong>自身可以监听到协程的执行结束，例如上面resumeWith函数使得我们可以在执行结束后将状态置为<strong>State.Done</strong>结束迭代。</p><p>接下来就是<strong>generator</strong>函数了，它接收一个参数即协程体，返回一个函数用来创建迭代器/序列生成器，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">generator</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">GeneratorScope</span>&lt;<span class="hljs-type">T</span>&gt;.(<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123; parameter: T -&gt;<br>        GeneratorImpl(block, parameter)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在我们完成了一个序列生成器，该序列生成器比较具备代表性，具有以下代表结构：</p><ul><li><strong>返回值：</strong>GeneratorIterator的泛型参数T即为元素类型。对于存在结果的协程，一定存在相应的泛型参数生命。</li><li><strong>状态机：</strong>GeneratorIterator实现Continuation接口之后，自身即可作为协程执行完成后的回调completion参数传入，进而监听协程的完成情况。</li><li><strong>作用域：</strong>GeneratorIterator实现GeneratorScope接口之后，可以作为协程体的Receiver，这样即可令协程体获得相应的扩展函数，如本例中的yield函数。</li></ul><h3 id="kotlin标准库中的序列生成器"><a href="#kotlin标准库中的序列生成器" class="headerlink" title="kotlin标准库中的序列生成器"></a>kotlin标准库中的序列生成器</h3><p>Kotlin标准库中提供了类似的生成器实现，通常我们称它为“懒序列生成器”。序列使用方法如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sequence = sequence &#123;<br>        yield(<span class="hljs-number">1</span>)<br>        yield(<span class="hljs-number">2</span>)<br>        yield(<span class="hljs-number">3</span>)<br>        yieldAll(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>&#125;<br><br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">in</span> sequence) &#123;<br>    println(num)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sequence函数接收一个函数作为参数，结合我们自己实现的generator，这个函数实际上就是协程体。除了提供yield函数外，sequence还支持批量生产元素yieldAll。与generator不同的是，这里sequence {}的返回值直接就是迭代器。</p><p>我们可以通过sequence来获取一个斐波那契数列，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fibonacci = sequence &#123;<br>    yield(<span class="hljs-number">1L</span>)<br>    <span class="hljs-keyword">var</span> current = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">var</span> next = <span class="hljs-number">1L</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        yield(next)<br>        next += current<br>        current = next - current<br>    &#125;<br>&#125;<br><br>fibonacci.take(<span class="hljs-number">10</span>).forEach(::println) <span class="hljs-comment">// 使用take(10)获取前10个元素</span><br></code></pre></div></td></tr></table></figure><h2 id="Promise-模型"><a href="#Promise-模型" class="headerlink" title="Promise 模型"></a>Promise 模型</h2><p>Promise模型又叫async/await，是目前最常见也最容易理解和上手的协程实现。</p><p>async/await的设计可以在async函数内部对复合Promise协议的异步回调进行await，使得异步逻辑变成了同步代码。这是目前主流的协程实现，它的关键在于将函数分为两种：</p><ul><li>普通函数：只能够调用普通函数，不存在协程的挂起和恢复逻辑。</li><li>async函数：既可以调用普通函数，也可以调用async函数，且可以将回调通过await同步化。</li></ul><p>async和wait各司其职，分别实现协程的挂起和恢复的逻辑，上手几乎没有成本。</p><h3 id="仿JavaScript的async-await实现"><a href="#仿JavaScript的async-await实现" class="headerlink" title="仿JavaScript的async/await实现"></a>仿JavaScript的async/await实现</h3><p>利用kotlin协程实现一个async/await的复合协程，效果如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">async &#123;<br>    <span class="hljs-keyword">val</span> user = await &#123; gitHubApi.getUserCallback(<span class="hljs-string">&quot;sukaidev&quot;</span>) &#125;<br>    println(user)<br>&#125;<br><br><span class="hljs-comment">// 控制台输出</span><br>User(userName=sukaidev, blog=https:<span class="hljs-comment">//www.sukaidev.top, location=GuangZhou,China, bio=Focus on Jetpack)</span><br></code></pre></div></td></tr></table></figure><p>先思考下async如何实现。async接收一个函数作为参数，这个函数即协程体，必然是个挂起函数。async创建成功后协程即启动，并且内部可以使用await方法来挂起协程。async函数实现如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">async</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-function"><span class="hljs-params">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">AsyncScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> completion = AsyncCoroutine(context)<br>    block.startCoroutine(completion, completion)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCoroutine</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = EmptyCoroutineContext) :<br>    Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;, AsyncScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        result.getOrThrow()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于async启动的协程不需要返回值，所以作为completion存在的AsyncCoroutine没有泛型参数。</p><p>await函数定义在AsyncScope中，使得它可以在async构造的协程中调用，它主要的作用就是将网络请求的回调转为协程，使用suspendCoroutine实现即可，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncScope</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">await</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> = suspendCoroutine&lt;T&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">val</span> call = block()<br>        call.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                    response.body()?.let(continuation::resume)<br>                        ?: continuation.resumeWithException(NullPointerException())<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                continuation.resumeWithException(HttpException(response))<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                continuation.resumeWithException(t)<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>async/await的状态比较简单，只有挂起以及被封装的回调完成状态，状态之间的流转由await单独来完成，因此不需要额外的状态机实现。当我们引入了协程的取消处理、异常处理等逻辑后，状态机的存在就至关重要了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（二）——基本原理</title>
    <link href="/2021/02/03/2a3d271f/"/>
    <url>/2021/02/03/2a3d271f/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>用suspend修饰的函数称为挂起函数。挂起函数只能在协程体内或者另一个挂起函数内部调用，这样kotlin的函数就分为了两种：<strong>普通函数</strong>和<strong>挂起函数</strong>。其中挂起函数可以调用任何函数，而普通函数只能调用普通函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，挂起函数既可以像普通函数一样同步返回，也可以处理异常逻辑。suspendFunc02中使用<strong>suspendCoroutine</strong>来获取当前所在协程体的<strong>Continuation</strong>的实例作为参数将挂起函数当成异步函数里来处理，内部新建一个线程来执行<strong>Continuation.resultWith</strong>操作，因此协程调用suspendFunc02后会进入挂起状态，直到结果返回。<strong>所谓挂起其实就是指当前的程序执行流程发生了异步调用，执行流程进入等待状态。</strong></p><h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>在前面的suspendFunc02中我们发现，一个挂起函数想要挂起，所需要的无非是一个Continuation实例，我们可以通过<strong>suspendCoroutine</strong>函数来获取到它。而协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就会被真正挂起，直到对应的<strong>Continuation#resume</strong>函数被调用才会恢复执行。</p><p>我们已经知道<strong>suspendCoroutine</strong>函数可以获得当前协程的Continuation实例，结合我们通过suspend{}创建的协程体，不难得出这个Continuation实例其实是一个<strong>SafeContinuation</strong>的实例。<strong>SafeContinuation</strong>的作用是确保协程只有在发生异步调用时才会挂起，例如下方代码虽然也有发生resume函数的调用，但协程并不会真正挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notSuspend</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>    continuation.resume(<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而异步调用是否发生，取决于resume函数与其对应的挂起函数调用是否在相同的调用栈上。这里列举两个函数调用栈发生了<strong>切换</strong>的场景：</p><ol><li>发生了线程切换</li><li>操作被post到了事件循环队列中等待执行</li></ol><h3 id="CPS变换"><a href="#CPS变换" class="headerlink" title="CPS变换"></a>CPS变换</h3><p><strong>CPS变换</strong>全名叫<strong>Continuation-Passing-Style Transformation</strong>，即连续传递样式变换。CPS是一种编程风格，用来将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者，这就将它的程序流程显式的暴露给程序员。而CPS变换就是将原本不是CPS风格的代码转变为CPS风格，通常由编译器来对代码进行优化，<strong>而Kotlin协程能够采用同步的方式书写异步代码的原理正是由于编译器使用了CPS变换</strong>。</p><p>Kotlin协程在挂起时，最关键的是要保存挂起点。挂起点的信息被保存在Continuation对象中，Continuation携带了协程继续执行所需要的上下文，恢复执行的时候只需要执行它的恢复调用并且把需要的参数或者异常传入即可。</p><p>我们前面讲到，挂起函数如果需要挂起，则需通过<strong>suspendCoroutine</strong>来获取Continuation，问题是这个Continuation是怎么传入suspendCoroutine里来的呢？</p><p>我们通过反编译上一节的<strong>notSuspend()**函数发现，</strong>notSuspend<strong>函数实际上有一个入参为Continuation<T>实例，结合挂起函数必须在协程体中执行这个特点，不难得出这个实例由外部协程传入。而编译器将我们的挂起函数编译成需要一个Continuation实例入参的这种行为，即是</strong>CPS变换**。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">notSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>   <span class="hljs-keyword">boolean</span> var1 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;<br>   <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>   SafeContinuation var4 = <span class="hljs-keyword">new</span> SafeContinuation(IntrinsicsKt.intercepted($completion));<br>   Continuation continuation = (Continuation)var4;<br>   <span class="hljs-keyword">int</span> var6 = <span class="hljs-keyword">false</span>;<br>   Integer var8 = Boxing.boxInt(<span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">boolean</span> var9 = <span class="hljs-keyword">false</span>;<br>   Companion var10 = Result.Companion;<br>   <span class="hljs-keyword">boolean</span> var11 = <span class="hljs-keyword">false</span>;<br>   continuation.resumeWith(Result.constructor-impl(var8));<br>   Object var10000 = var4.getOrThrow();<br>   <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>      DebugProbesKt.probeCoroutineSuspended($completion);<br>   &#125;<br>   <span class="hljs-keyword">return</span> var10000;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们仔细观察这段代码，发现由外部传入的$completion的resume方法实际上并没有得到调用，而是使用其创建了一个SafeContinuation对象，并最终调用了<strong>SafeContinuation#resumeWith</strong>。关于SafeContinuation我们上文说过，用来保证结果的正常返回。</p><p>上述反编译代码还有一个特别的地方在于，我们写的<strong>notSuspend</strong>函数本来是没有返回值的，但编译后返回了<strong>Object</strong>。而这个Object对象是通过<strong>SafeContinuation#getOrThrow</strong>函数来获得，我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@PublishedApi</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getOrThrow</span><span class="hljs-params">()</span></span>: Any? &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// atomic read</span><br>    <span class="hljs-keyword">if</span> (result === UNDECIDED) &#123;<br>        <span class="hljs-keyword">if</span> (RESULT.compareAndSet(<span class="hljs-keyword">this</span>, UNDECIDED, COROUTINE_SUSPENDED)) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        result = <span class="hljs-keyword">this</span>.result <span class="hljs-comment">// reread volatile var</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> &#123;<br>        result === RESUMED -&gt; COROUTINE_SUSPENDED <span class="hljs-comment">// already called continuation, indicate COROUTINE_SUSPENDED upstream</span><br>        result <span class="hljs-keyword">is</span> Result.Failure -&gt; <span class="hljs-keyword">throw</span> result.exception<br>        <span class="hljs-keyword">else</span> -&gt; result <span class="hljs-comment">// either COROUTINE_SUSPENDED or data</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>SafeContinuation#getOrThrow</strong>方法会根据resumeWith被调用后的结果来返回，除了返回结果外，它还要可能会返回<strong>COROUTINE_SUSPENDED</strong>标志位或者一个Exception。</p><p><strong>COROUTINE_SUSPENDED</strong>标志位用来表示返回这个标志的挂起函数已经发生了事实上的挂起。什么叫事实上的挂起呢？上文我们已经说到了主要resume函数与其对应挂起函数不在同一个函数调用栈，那么就说明它发生了事实上的挂起。这里要说明的一点是，如果在调用挂起函数时，协程虽然有异步调用但实际上已经得到结果，那么这里就没有发生事实上的挂起，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">launch &#123;<br>    <span class="hljs-keyword">val</span> deferred = async &#123;<br>        <span class="hljs-comment">// 发起了一个网络请求</span><br>        ......<br>    &#125;<br>    <span class="hljs-comment">// 做了一些操作</span><br>    ......<br>    deferred.await()  <span class="hljs-comment">// 假设在这里deferred已经执行完毕</span><br>    <span class="hljs-comment">// 后续的一些操作</span><br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设我们在调用deferred.await()时，deferred对应协程已经执行完毕，那么这里就没有发生事实上的挂起。</p><p>我们来总结一下挂起函数的返回情况：</p><ul><li>同步返回。作为参数的Continuation的resumeWith不会被调用，函数的返回值就是它作为挂起函数的返回值。</li><li>返回挂起标志。当挂起函数发生了事实上的挂起时，返回挂起标志表示挂起点进入挂起状态，等待异步调用结束时调用<strong>resumeWith</strong>再执行恢复操作。</li><li>返回Exception。当函数执行报错，返回Exception。</li></ul><h2 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h2><p>上下文的概念很容易理解，如Android中的Context、Spring中的ApplicationContext，它们在各自的场景下主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。</p><p>前面说到，Continuation除了可以通过恢复调用来控制执行流程的异步返回外，还有一个重要的属性就是<strong>协程上下文</strong>。</p><h3 id="协程上下文的集合特征"><a href="#协程上下文的集合特征" class="headerlink" title="协程上下文的集合特征"></a>协程上下文的集合特征</h3><p>协程上下文的数据结构特征特别明显，类似一个集合。跟创建集合一样，我们也可以创建一个空的协程上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br></code></pre></div></td></tr></table></figure><p><strong>EmptyCoroutineContext</strong>是标准库自带的object，里面没有数据。</p><p>类似的，我们可以往协程上下文中添加数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">list += <span class="hljs-number">0</span><br>coroutineContext += Dispatchers.IO  <span class="hljs-comment">// Dispatchers.IO实现了Element接口</span><br></code></pre></div></td></tr></table></figure><p>我们来看下协程上下文中的元素类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> : <span class="hljs-type">CoroutineContext &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Element定义在CoroutineContext内部，重点有两个：</p><ol><li>Element本身也实现了CoroutineContext。</li><li>Element接口中有一个属性key，表示元素在上下文中的索引。</li></ol><h3 id="协程上下文元素的实现"><a href="#协程上下文元素的实现" class="headerlink" title="协程上下文元素的实现"></a>协程上下文元素的实现</h3><p>Element有一个子接口<strong>AbstractCoroutineContextElement</strong>，能让我们在实现协程上下文的元素时更加方便：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCoroutineContextElement</span></span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;) : Element<br></code></pre></div></td></tr></table></figure><p>这样我们只需要提供一个Key就可以创建自己的Element了，例如下面CoroutineName可以为协程绑定一个名字，CoroutineExceptionHandler可以为协程绑定一个全局错误处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(<span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineExceptionHandler</span></span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>) :<br>    AbstractCoroutineContextElement(Key) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="协程上下文的使用"><a href="#协程上下文的使用" class="headerlink" title="协程上下文的使用"></a>协程上下文的使用</h3><p>把上面定义好的元素添加到协程上下文中，并将其绑定到协程上：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">coroutineContext += CoroutineName(<span class="hljs-string">&quot;Download Coroutine&quot;</span>)<br>coroutineContext += CoroutineExceptionHandler&#123;<br>    <span class="hljs-comment">//  ... ...</span><br>&#125;<br><br><span class="hljs-keyword">suspend</span> &#123; ... &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = coroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        println(context[CoroutineName]?.name)<br>        result.onFailure &#123;<br>            context[CoroutineExceptionHandler]?.onError(it)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>可以看到我们使用对应的Key就能获取到Element，从而使用其属性/方法。</p><h2 id="协程的拦截器"><a href="#协程的拦截器" class="headerlink" title="协程的拦截器"></a>协程的拦截器</h2><p>协程标准库中提供了一个叫作拦截器的组件，它允许我们拦截协程异步回调时的恢复调用。</p><h3 id="拦截的位置"><a href="#拦截的位置" class="headerlink" title="拦截的位置"></a>拦截的位置</h3><p>我们来看下方代码，这个过程发生了几次恢复调用呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> &#123;<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>    suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt;) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在启动协程时，通过恢复调用来执行协程，这是一次，而这里<strong>suspendFunc02</strong>发生了事实上的挂起，那么这里就发生了两次恢复调用。也就是说，如果协程体内发生了n次事实上的挂起操作，那么恢复调用总共会执行n+1次。这n+1次恢复执行的位置都可以通过添加拦截器来实现一些AOP操作。</p><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>我们可以通过实现<strong>ContinuationInterceptor</strong>接口来快速实现一个协程拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor &#123;</span></span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) :<br>    Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith : <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拦截的关键函数是<strong>interceptContinuation</strong>，根据需要返回一个新的Continuation实例来实现拦截。拦截器本身也是一个协程上下文的元素类型，因此可以直接添加到协程上下文中。拦截后的协程执行情况如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">before resumeWith : Success(kotlin.<span class="hljs-built_in">Unit</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br>before resumeWith : Success(<span class="hljs-number">5</span>)<br>after resumeWith.<br></code></pre></div></td></tr></table></figure><p>可以看到两次挂起函数的恢复调用处都执行了一次拦截。</p><h3 id="拦截器的执行细节"><a href="#拦截器的执行细节" class="headerlink" title="拦截器的执行细节"></a>拦截器的执行细节</h3><p>在上一篇文章我们提到，SafeContinuation其内部有个<strong>delegate</strong>，我们称其为协程体。实际上这是在没有拦截器进行拦截的情况下，当添加了拦截器后，delegate就是拦截器拦截后返回的Continuation实例了，例如我们上面例子中的LogContinuation。</p><p>我们在上面分析<strong>suspendFunc02</strong>的字节码反编译代码时，提到协程体传入挂起函数的Continuation实例$completion实际上会包装成SafeContinuation，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">SafeContinuation(IntrinsicsKt.intercepted($completion));<br></code></pre></div></td></tr></table></figure><p>$completion并没有简单的传入SafeContinuation的构造方法中，而是使用了IntrinsicsKt.intercepted($completion)的返回值，来看看调用链：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到IntrinsicsKt.intercepted($completion)的返回值其实就是调用拦截器的<strong>interceptContinuation</strong>函数的返回，协程体在挂起点处先被拦截器拦截，再被SafeContinuation保护了起来。</p><p>除了打印日志外，拦截器最常见的作用就是线程调度，这个我们在后续文章中讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Kotlin标准库1.4.21<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Kotlin协程（一）——基本概念</title>
    <link href="/2021/02/01/595755ca/"/>
    <url>/2021/02/01/595755ca/</url>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>在当前主流的计算机操作系统中，进程和线程是我们比较熟悉的东西。在早期的计算机系统中，并没有线程的概念，而进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。</p><p>线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。</p><p>协程是很早就存在的概念，但近几年被广泛的使用。协程出现最初是为了实现与线程的“抢占式调度”不同的“协同式调度”多任务并发程序。与线程的抢占式调度不同，协同式调度讲究的是任务完成后主动通知cpu任务已经执行完成并交回cpu使用权，但随着主流操作系统都采用抢占式调度后，协程也被人们遗忘。</p><p>随着对程序性能的追求，减少线程上下文切换，不少语言都实现了自己的协程，例如Golang、Python、C++、Lua、Kotlin等。Kotlin的协程由语言层面提供，不少人对它的解释是“线程框架”，实际上它的功能就是在当前以抢占式线程的多任务并发机制为主的操作系统，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。</p><p>说了那么多，那么到底什么是协程？</p><ol><li>挂起和恢复</li><li>程序自行处理挂起恢复</li><li>程序自行处理挂起恢复来实现程序执行流程的协作调度</li></ol><h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按调用栈分类"><a href="#按调用栈分类" class="headerlink" title="按调用栈分类"></a>按调用栈分类</h3><p>我们知道，java程序之所以能实现方法内部调用方法的功能，是因为Jvm中维护了一个栈，当方法被调用时，其相关的数据与属性都会被栈中，也就是我们常说的JVM中的Java栈。这个栈就是函数调用栈，是用来保存函数调用时的状态信息的数据结构。</p><p>由于协程需要挂起和恢复，因此对于挂起点的状态保存就显得很重要。按照是否开辟了函数调用栈我们可以对协程进行分类。</p><ul><li><strong>有栈协程（Stackful Coroutine）</strong>：每一个协程都有自己的调用栈，类似于线程的调用栈</li><li><strong>无栈协程（Stackless Coroutine）</strong>：协程没有自己的调用栈，挂起点的状态由状态机或者闭包等语法来实现</li></ul><p>有栈协程的优点是可以在任意函数调用层级的任意位置挂起，并转移调度权。无栈协程的有点是不需要开辟栈空间，因此在内存紧张的程序上有优势。</p><p><strong>Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现</strong>。不过，kotlin协程可以在挂起函数范围内的任意调用层次挂起，这也是有栈协程的一个重要特性之一。</p><h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>调度过程中，根据协程调度权的转移目标的不同又可将协程分为<strong>对称协程</strong>和<strong>非对称协程</strong>。</p><ul><li><strong>对称协程（Symmetric Coroutine）</strong>：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</li><li><strong>非对称协程（Asymmetric Coroutine）</strong>：协程出让调度权的目标只能是它的的调用者，即协程之间存在调用和被调用关系</li></ul><p>对称协程的概念跟线程十分类似，例如go routine可以通过读写不同的channel来实现控制权的自由转移。常见语言的协程大多是非对称实现。实际上在非对称的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，所有协程在挂起时都将调度权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，即可实现对称协程。</p><h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h3><p>我们可以通过<strong>createCoroutine</strong>方法快速创建一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br> SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></div></td></tr></table></figure><p>可以看到该方法是个扩展方法，Receiver类型为<strong>suspend ()-&gt;T</strong>，是一个挂起函数。<strong>completion</strong>是协程完成后的回调，有点类似于我们常写的Callback。方法返回一个Continuation对象， 拿到了这个对象后我们就可以随时的启动协程了。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;Coroutine Start.&quot;</span>)<br>    <span class="hljs-string">&quot;return value.&quot;</span><br>&#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>上面代码中我们顺利创建一个协程，那么如何启动这个协程呢？Continuation中并没有类型startXXX()的方法，而是调用<strong>Continuation#resume</strong>来启动一个协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)   <span class="hljs-comment">// 启动协程</span><br><br><span class="hljs-comment">// 控制台输出：</span><br>Coroutine Start.<br>Coroutine End : Success(<span class="hljs-keyword">return</span> value.)<br></code></pre></div></td></tr></table></figure><p>当然我们也可通过<strong>startCoroutine</strong>来直接创建和启动一个协程：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br> createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面有个非常令人疑惑的点是，为什么调用返回的Continuation对象就可以启动协程呢？按照我们上面的写的，continuation的resumeWith方法应该作为回调成功的方法才对。</p><p>通过上面<strong>createCoroutine</strong>方法源码我们得知返回给我们的是一个<strong>SafeContinuation</strong>对象，这里就不贴源码了毕竟这篇只是个初识（笑），这里要说的是SafeContinuation其实只是个”马甲“，它的所有操作均交由其私有属性delegate来执行，当然delegate也是一个Continuation对象。当我们执行了</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">continuation.resume(<span class="hljs-built_in">Unit</span>)<br></code></pre></div></td></tr></table></figure><p>这行代码时，实际上是执行了<strong>delegate.resumeWith</strong>方法。那么新问题来了，delegate对象又是哪来的呢？通过查阅字节码和反编译文件我们发现，我们写的协程体也就是suspend修饰的这个lambda编译后实际上变成了一个匿名内部类，而我们的协程体中的代码实际被包装在了其<strong>invokeSuspend</strong>方法中。而当我们调用Suspend Lambda的扩展方法<strong>createCoroutine</strong>创建一个协程时，我们的Suspend Lambda也就是协程体实际被传入<strong>SafeContinuation</strong>的构造方法中，也就是说SafeContinuation的delegate属性其实就是我们的协程体。</p><p>这样看来就比较清晰了，创建协程返回的Continuation实例其实就是套了几层马甲的协程体，协程体先被编译器封装到一个匿名内部类内部的<strong>invokeSuspend</strong>方法中，再传入SafeContinuation充当其代理，当我们调用<strong>SafeContinuation#resume</strong>的时候，我们的协程体自然就得到了执行。</p><h3 id="协程体的Receiver"><a href="#协程体的Receiver" class="headerlink" title="协程体的Receiver"></a>协程体的Receiver</h3><p>与协程创建和启动相关的API有两组，现在看下第二组：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>)<br></code></pre></div></td></tr></table></figure><p>两组区别仅仅在于这一组协程体多了一个Receiver类型R。协程体的Receiver可以为协程提供一个作用域，使得我们可以在协程体内使用作用域提供的函数或者状态等。</p><p>由于Kotlin本身没有提供带有Receiver的Lambda表达式的语法，这里我们自己实现一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End : <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用时首先需要一个作用域，这里我们来手动模拟一个协程作用域：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScope</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(value.toString())<br>    &#125;<br><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = value.hashCode() xor (value.hashCode() ushr <span class="hljs-number">16</span>)<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span> &#123;<br>    launchCoroutine(MainScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;Start Coroutine.&quot;</span>)<br>        print(<span class="hljs-number">1000</span>)<br>        delay(<span class="hljs-number">1000L</span>)<br>        hashCode(<span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到我们可以直接使用作用域提供的函数，也可以调用作用域外部定义的挂起函数。</p><p>除了可以提供函数支持外，作用域也可以用来增加限制，例如<strong>RestrictsSuspension</strong>注解，为作用域添加这个注解后，使用作用域构造的协程体将无法调用外部的挂起函数，例如上面代码中的<strong>delay</strong>将会报红。</p><h3 id="可挂起的main函数"><a href="#可挂起的main函数" class="headerlink" title="可挂起的main函数"></a>可挂起的main函数</h3><p>从Kotlin Version 1.3开始，我们**main()**函数可以直接被声明为suspend：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这意味着我们可以在JVM启动的时候直接获得一个协程。首先可以确定的是这个可挂起的<strong>main</strong>函数肯定不会是真正的程序入口，因为JVM根本不会知道什么是协程，实际上我们反编译字节码后发现main方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>   RunSuspendKt.runSuspend(<span class="hljs-keyword">new</span> CoroutineKt$$$main(var0));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们在suspend main()中写的可挂起的代码实际上由<strong>RunSuspendKt#runSuspend</strong>来执行，来看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSuspend</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> run = RunSuspend()<br>    block.startCoroutine(run)<br>    run.await()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到这里用我们的suspend main()来启动一个协程。</p><p>这里还有一个RunSuspend类，它也是一个Continuation，作为我们整个程序运行完成的回调，这里我们可以关注下<strong>await</strong>函数的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.result = result<br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).notifyAll()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> = synchronized(<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = <span class="hljs-keyword">this</span>.result) &#123;<br>            <span class="hljs-literal">null</span> -&gt; <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;</span>)</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Object).wait()<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                result.getOrThrow() <span class="hljs-comment">// throw up failure</span><br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到当我们调用了block.startCoroutine(run)启动了协程之后，main()方法所在线程实际会进入阻塞状态，当协程执行完毕，run的<strong>resumeWith</strong>方法会被调用，main()方法所在线程从而被唤醒，使得JVM可以正常退出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/35094136/">《深入理解Kotlin协程》</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutines</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
