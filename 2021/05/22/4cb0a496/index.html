

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Android Developer">
  <meta name="author" content="sukaidev">
  <meta name="keywords" content="Android sukaidev 苏海鸿">
  <title>Android Framework（二）——Activity启动流程 - Sukai&#39;s Blog - Android Developer</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"sukaidev.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sukai's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android Framework（二）——Activity启动流程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-22 20:20" pubdate>
        2021年5月22日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android Framework（二）——Activity启动流程</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>注意（WARNING）：本文含有大量AOSP源码，阅读过程中如出现头晕、目眩、恶心、犯困等症状属正常情况，作者本人亦无法避免症状产生，故不承担任何法律责任。</p>
<p>本文所贴源码全部来自 Android API 29 Platform，即 Android 10.0。</p>
</blockquote>
<p>Android 中待启动的 Activity 分为两类，一种是 App 的Root Activity，也就是根Activity，另一种是普通的 Activity。</p>
<p>两类 Activity 的启动过程有不少重叠的部分，根 Activity 特殊的点在于，启动它时涉及到整个应用进程的启动，因此更具有指导意义。</p>
<p>本文将通过分析根Activity的启动过程来理解Android 10中Activity的启动流程。根 Activity 的启动过程分为三个部分，分别是：</p>
<ul>
<li><strong>Launcher 请求 ATMS 过程</strong></li>
<li><strong>ATMS 调用 ApplicationThread 过程</strong></li>
<li><strong>ActivityThread启动Activity过程</strong></li>
</ul>
<p>另外还涉及到目标App进程的启动过程，不过本文主要讨论Activity的启动流程，App进程的启动将会在下篇文章讲解。</p>
<p>下面就以这三个部分为基础来分析根 Activity 的启动过程。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>为了避免阅读源码过程中出现不适，这里先简单介绍一些后面会出现的相关类。</p>
<h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><ul>
<li><strong>ActivityThread</strong>：整个 App main 方法所在的类，所谓主线程就是指它所执行的线程，所以通常会称其为主线程。它负责管理应用程序进程的主线程的执行，处理 ATMS 的调度和执行Activity，Broadcast及相关操作。</li>
<li><strong>ApplicationThread</strong>：它是 ActivityThread 的一个内部类，继承自 IApplicationThread.Stub，是一个 IBinder。ActivityThread 通过它来进行 IPC 调用，与 SystemServer 通信。</li>
<li><strong>Intrumentation</strong>：用于监控应用程序与系统交互，启动 Activity 或者调用 Activity、Application 的生命周期都需要经过它的处理。</li>
<li><strong>ActivityTaskManager</strong>：Activity，Service 等与 ATMS 跨进程交互的接口，ATMS的辅助类。后文简称为 ATM。</li>
<li><strong>ActivityTaskManagerService</strong>：管理 Activity 和它的回退栈、任务栈的系统服务，Android 10以前是 AMS 的工作，Android 10中将部分工作从 AMS 抽离为 ATMS。后文将简称为 ATMS。</li>
<li><strong>ActivityRecord</strong>：system_server进程中用来描述Activity的数据类型。ActivityRecord中存储了Activity的信息，如所在的进程名称，应用的包名，所在的任务栈的taskAffinity等，与ActivityClientRecord、Activity的是一一对应关系。</li>
<li><strong>ActivityClientRecord</strong>：App进程中用来描述Activity的数据类型。</li>
<li><strong>TaskRecord</strong>：表示一个任务栈，记录了Activity启动的先后顺序，栈中严格按照先进后出的特性维护一系列ActivityRecord。</li>
<li><strong>ActivityStack</strong>：负责维护TaskRecord，内部保存了当前Stack中所有的Task列表。</li>
<li><strong>ActivityDisplay</strong>：管理所有ActivityStack，表示当前屏幕的抽象，内部维护了mHomeStack、mStacks、mPreferredToFocusableStack和mLastFocusedStack等ActivityStack。</li>
<li><strong>RootActivityContainer</strong>：Android10中新增的类，由ActivityStackSupervisor中抽离而来，其作为Activity容器的根节点，负责管理所有的ActivityDisplay。</li>
<li><strong>ActivityStackSupervisor</strong>：Android系统中Activity的最大管家，通过持有RootActivityContainer来间接管理所有的Activity。</li>
<li><strong>ClientLifecycleManager</strong>：组合多个客户端生命周期转换和请求，作为单个事务来执行。</li>
</ul>
<h3 id="Activity栈管理机制"><a href="#Activity栈管理机制" class="headerlink" title="Activity栈管理机制"></a>Activity栈管理机制</h3><p>Activity栈结构如下图所示。</p>
<p><img src="/img/activity_stack_model.jpg" srcset="/img/loading.gif" alt="Activity栈管理模型"></p>
<p>用关系链表来表示它们的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityStackSupervisor.mRootActivityContainer<br>-&gt; RootActivityContainer.mActivityDisplays<br>-&gt; ActivityDisplay.mStacks<br>-&gt; ActivityStack.mTaskHistory<br>-&gt; TaskRecord.mActivities<br>-&gt; ActivityRecord<br></code></pre></td></tr></table></figure>
<h2 id="Launcher-请求-AMS-过程"><a href="#Launcher-请求-AMS-过程" class="headerlink" title="Launcher 请求 AMS 过程"></a>Launcher 请求 AMS 过程</h2><p>当我们启动系统时首先启动的App就是 Launcher，通过 Launcher 我们可以点击图标启动任何一个App，继而启动它的 Main Activity。整个过程发生在Launcher#startActivitySafely方法中。</p>
<h3 id="Launcher-startActivitySafely"><a href="#Launcher-startActivitySafely" class="headerlink" title="Launcher#startActivitySafely"></a>Launcher#startActivitySafely</h3><blockquote>
<p>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v, Intent intent, ItemInfo item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> String sourceContainer)</span> </span>&#123;<br>    ··· <br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">super</span>.startActivitySafely(v, intent, item, sourceContainer);<br>    ···<br>    <span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>startActivitySafely 方法继承自 BaseDraggingActivity：</p>
<blockquote>
<p>packages/apps/Launcher3/src/com/android/launcher3/BaseDraggingActivity.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v, Intent intent, <span class="hljs-meta">@Nullable</span> ItemInfo item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> String sourceContainer)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 1</span><br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>        intent.setSourceBounds(getViewBounds(v));<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> isShortcut = (item <span class="hljs-keyword">instanceof</span> WorkspaceItemInfo)<br>                &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT<br>                || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)<br>                &amp;&amp; !((WorkspaceItemInfo) item).isPromise();<br>        <span class="hljs-keyword">if</span> (isShortcut) &#123;<br>            <span class="hljs-comment">// Shortcuts need some special checks due to legacy reasons.</span><br>            startShortcutIntentSafely(intent, optsBundle, item, sourceContainer);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || user.equals(Process.myUserHandle())) &#123;<br>            <span class="hljs-comment">// Could be launching some bookkeeping activity</span><br>            <span class="hljs-comment">// 2</span><br>            startActivity(intent, optsBundle);<br>            AppLaunchTracker.INSTANCE.get(<span class="hljs-keyword">this</span>).onStartApp(intent.getComponent(),<br>                    Process.myUserHandle(), sourceContainer);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            getSystemService(LauncherApps.class).startMainActivity(<br>                    intent.getComponent(), user, intent.getSourceBounds(), optsBundle);<br>            AppLaunchTracker.INSTANCE.get(<span class="hljs-keyword">this</span>).onStartApp(intent.getComponent(), user,<br>                    sourceContainer);<br>        &#125;<br>        getUserEventDispatcher().logAppLaunch(v, intent, user);<br>        <span class="hljs-keyword">if</span> (item != <span class="hljs-keyword">null</span>) &#123;<br>            InstanceId instanceId = <span class="hljs-keyword">new</span> InstanceIdSequence().newInstanceId();<br>            logAppLaunch(item, instanceId);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException|ActivityNotFoundException|SecurityException e) &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>        Log.e(TAG, <span class="hljs-string">&quot;Unable to launch. tag=&quot;</span> + item + <span class="hljs-string">&quot; intent=&quot;</span> + intent, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码注释1处是我们比较熟悉的了，通过设置 FLAG_ACTIVITY_NEW_TASK flag让 Activity 在新的任务栈中启动。在注释 2 处会调用 startActivity 方法，这个 startActivity 方法在 Activity 中实现。</p>
<h3 id="Activity-startActivity"><a href="#Activity-startActivity" class="headerlink" title="Activity#startActivity"></a>Activity#startActivity</h3><blockquote>
<p>frameworks/base/core/java/android/app/Activity.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.startActivity(intent, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, <span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>        startActivityForResult(intent, -<span class="hljs-number">1</span>, options);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note we want to go through this call for compatibility with</span><br>        <span class="hljs-comment">// applications that may have overridden the method.</span><br>        startActivityForResult(intent, -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>startActivity 方法最终会调用到 startActivityForResult 方法并传入-1表示不需要返回。</p>
<h3 id="Activity-startActivityForResult"><a href="#Activity-startActivityForResult" class="headerlink" title="Activity#startActivityForResult"></a>Activity#startActivityForResult</h3><p>继续来看startActivityForResult：</p>
<blockquote>
<p>frameworks/base/core/java/android/app/Activity.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(<span class="hljs-meta">@RequiresPermission</span> Intent intent, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>    <span class="hljs-comment">// Activity mParent</span><br>    <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>        options = transferSpringboardActivityOptions(options);<br>        Instrumentation.ActivityResult ar =<br>            mInstrumentation.execStartActivity(<br>                <span class="hljs-keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-keyword">this</span>,<br>                intent, requestCode, options);<br>        <span class="hljs-keyword">if</span> (ar != <span class="hljs-keyword">null</span>) &#123;<br>            mMainThread.sendActivityResult(<br>                mToken, mEmbeddedID, requestCode, ar.getResultCode(),<br>                ar.getResultData());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (requestCode &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// If this start is requesting a result, we can avoid making</span><br>            <span class="hljs-comment">// the activity visible until the result is received.  Setting</span><br>            <span class="hljs-comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br>            <span class="hljs-comment">// activity hidden during this time, to avoid flickering.</span><br>            <span class="hljs-comment">// This can only be done when a result is requested because</span><br>            <span class="hljs-comment">// that guarantees we will get information back when the</span><br>            <span class="hljs-comment">// activity is finished, no matter what happens to it.</span><br>            mStartedActivity = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        cancelInputsAndStartExitTransition(options);<br>        <span class="hljs-comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>            mParent.startActivityFromChild(<span class="hljs-keyword">this</span>, intent, requestCode, options);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Note we want to go through this method for compatibility with</span><br>            <span class="hljs-comment">// existing applications that may have overridden it.</span><br>            mParent.startActivityFromChild(<span class="hljs-keyword">this</span>, intent, requestCode);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>mParent 属性会在 Activity attach 时设置，表示 Activity 启动时的父 Activity，但 Main Activity 的 mParent 是为 null 的，因此会进入 if 判断中。if 代码块中调用到了 Instrumentation#execStartActivity，剩下都交给 Instrumentation 来处理。</p>
<h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation#execStartActivity"></a>Instrumentation#execStartActivity</h3><p>Instrumentation 类主要用来监控应用程序与系统交互，mMainThread 对象是 ActivityThread，通过 getApplicationThread 方法获取 ApplicationThread 对象。ApplicationThread 继承自 Stub，也就是 Binder，这为我们后面与 AMS 通信提供了基础。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IApplicationThread</span>.<span class="hljs-title">Stub</span></span><br></code></pre></td></tr></table></figure>
<p>继续跟踪源码，来到 Instrumentation#execStartActivity 方法中：</p>
<blockquote>
<p>frameworks/base/core/java/android/app/Instrumentation.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;<br>    IApplicationThread whoThread = (IApplicationThread) contextThread;<br>    ···<br>    <span class="hljs-keyword">try</span> &#123;<br>        intent.migrateExtraStreamToClipData();<br>        intent.prepareToLeaveProcess(who);<br>        <span class="hljs-keyword">int</span> result = ActivityTaskManager.getService()<br>            .startActivity(whoThread, who.getBasePackageName(), intent,<br>                    intent.resolveTypeIfNeeded(who.getContentResolver()),<br>                    token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,<br>                    requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);<br>        checkStartActivityResult(result, intent);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里使用 binder IPC 调用到了 <strong>ActivityTaskManagerService（ATMS）</strong>中。</p>
<p>ATMS 是个远程服务，需要通过 ServiceManager 来获取，ServiceManager 底层最终调用的还是 Native 层的 ServiceManager，它是 Binder 的守护服务，通过它能够获取在 Android 系统启动时注册的系统服务，这其中就包含这里提到的 ATMS。获取服务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityTaskManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> IActivityTaskManagerSingleton.get();<br>   &#125;<br><br>   <span class="hljs-meta">@UnsupportedAppUsage(trackingBug = 129726065)</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =<br>           <span class="hljs-keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityTaskManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>                   <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);<span class="hljs-comment">// 1</span><br>                   <span class="hljs-keyword">return</span> IActivityTaskManager.Stub.asInterface(b); <span class="hljs-comment">// 2</span><br>               &#125;<br>           &#125;;<br></code></pre></td></tr></table></figure>
<p>注释 1 处通过 ServiceManager 获取对应的系统服务，也就是 IBinder 类型的 ATMS 引用。注释 2 处将它转换成 ActivityTaskManager 类型的对象，这段代码采用的是 AIDL，IActivityTaskManager.java 类是由 AIDL 工具在编译时自动生成的，IActivityTaskManager.aidl 的文件路径为 frameworks/base/core/java/android/app/IActivityTaskManager.aidl。 要实现进程间通信，服务端也就是 ATMS 只需要继承 IActivityTaskManager.Stub 类并实现相应的方法也就可以了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们回顾一下 Launcher 所做工作，startActivity 最终都会调用到 startActivityForResult，而启动一个 Activity 必须通过系统服务来执行，因此会使用 Launcher 的 ApplicationThread 来发起一次 IPC 调用，最终在 Instrumentation#execStartActivitiesAsUser 中请求 ATMS 来启动 Activity。</p>
<p>这个过程的时序图如下所示。</p>
<p><img src="/img/framework_launcher_start_activity.jpg" srcset="/img/loading.gif" alt="Launcher请求ATMS过程时序图"></p>
<h2 id="ATMS-到-ApplicationThread-的调用过程"><a href="#ATMS-到-ApplicationThread-的调用过程" class="headerlink" title="ATMS 到 ApplicationThread 的调用过程"></a>ATMS 到 ApplicationThread 的调用过程</h2><p>Launcher 请求 AMS 后 ，代码逻辑已经进入 ATMS 中，接着是 ATMS 到 ApplicationThread 的调用流程。</p>
<h3 id="ActivityTaskManagerService-startActivity"><a href="#ActivityTaskManagerService-startActivity" class="headerlink" title="ActivityTaskManagerService#startActivity"></a>ActivityTaskManagerService#startActivity</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">    Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>            resultWho, requestCode, startFlags, profilerInfo, bOptions,<br>            UserHandle.getCallingUserId());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ATMS中会调用startActivityAsUser方法，这里需要注意一点就是startActivityAsUser方法比startActivity多了一个参数，为UserHandle.getCallingUserId()，ATMS根据这个参数来判断调用者的权限。</p>
<h3 id="ActivityTaskManagerService-startActivityAsUser"><a href="#ActivityTaskManagerService-startActivityAsUser" class="headerlink" title="ActivityTaskManagerService#startActivityAsUser"></a>ActivityTaskManagerService#startActivityAsUser</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> validateIncomingUser)</span> </span>&#123;<br>    <span class="hljs-comment">// 1</span><br>    enforceNotIsolatedCaller(<span class="hljs-string">&quot;startActivityAsUser&quot;</span>);<br><br>    <span class="hljs-comment">// 2</span><br>    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,<br>            Binder.getCallingPid(), Binder.getCallingUid(), <span class="hljs-string">&quot;startActivityAsUser&quot;</span>);<br><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="hljs-string">&quot;startActivityAsUser&quot;</span>)<br>            .setCaller(caller)<br>            .setCallingPackage(callingPackage)<br>            .setResolvedType(resolvedType)<br>            .setResultTo(resultTo)<br>            .setResultWho(resultWho)<br>            .setRequestCode(requestCode)<br>            .setStartFlags(startFlags)<br>            .setProfilerInfo(profilerInfo)<br>            .setActivityOptions(bOptions)<br>            .setMayWait(userId)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注释1处判断调用者进程是否被隔离，如果被隔离则抛出SecurityException异常。</p>
<p>注释2处检查调用者是否有权限，如果没有权限也会抛出SecurityException异常。</p>
<p>注释3出通过ActivityStartController来获取一个ActivityStarter，并且配置了一些参数，这里要注意setMayWait方法传入了userId，会将ActivityStarter的mayWait属性置为true，后面会用到。</p>
<p>ActivityStarter是Android 7.0中新加入的类，它是加载Activity的控制类，会收集所有的逻辑来决定如何将 Intent和Flags转换为Activity，并将 Activity和Task以及Stack相关联。 </p>
<h3 id="ActivityStarter-execute"><a href="#ActivityStarter-execute" class="headerlink" title="ActivityStarter#execute"></a>ActivityStarter#execute</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (mRequest.mayWait) &#123;<br>            <span class="hljs-keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,<br>                    mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,<br>                    mRequest.intent, mRequest.resolvedType,<br>                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,<br>                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,<br>                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,<br>                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,<br>                    mRequest.inTask, mRequest.reason,<br>                    mRequest.allowPendingRemoteAnimationRegistryLookup,<br>                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ···<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        onExecutionComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于mRequest.mayWait被置为true，因此会调用startActivityMayWait方法。startActivityMayWait多了几个参数，需要注意的是TaskRecord代表启动Activity所在的栈。</p>
<h3 id="ActivityStarter-startActivityMayWait"><a href="#ActivityStarter-startActivityMayWait" class="headerlink" title="ActivityStarter#startActivityMayWait"></a>ActivityStarter#startActivityMayWait</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityMayWait</span><span class="hljs-params">(IApplicationThread caller, <span class="hljs-keyword">int</span> callingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">        String callingPackage, <span class="hljs-keyword">int</span> requestRealCallingPid, <span class="hljs-keyword">int</span> requestRealCallingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, String resolvedType, IVoiceInteractionSession voiceSession,</span></span><br><span class="hljs-function"><span class="hljs-params">        IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, WaitResult outResult,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration globalConfig, SafeActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> userId, TaskRecord inTask, String reason,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingIntentRecord originatingPendingIntent, <span class="hljs-keyword">boolean</span> allowBackgroundActivityStart)</span> </span>&#123;<br>    <span class="hljs-comment">// intent中不允许携带文件描述符</span><br>    <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.hasFileDescriptors()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;File descriptors passed in Intent&quot;</span>);<br>    &#125;<br>    ··· <br>    <span class="hljs-comment">// 解析Intent</span><br>    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,<br>            <span class="hljs-number">0</span> <span class="hljs-comment">/* matchFlags */</span>,<br>                    computeResolveFilterUid(<br>                            callingUid, realCallingUid, mRequest.filterCallingUid));<br>    ···<br>    <span class="hljs-comment">// 解析Activity信息，当有多个可供选择时在这里弹出选择框</span><br>    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);<br><br>    <span class="hljs-keyword">synchronized</span> (mService.mGlobalLock) &#123;<br>        ··· <br>        <span class="hljs-comment">// 启动Activity</span><br>        <span class="hljs-keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,<br>                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,<br>                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,<br>                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,<br>                allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,<br>                allowBackgroundActivityStart);<br>        ···<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>startActivityMayWait较为复杂，其中关键的几点都已经用注释标注，主要是通过解析Intent来获取将要启动的Activity信息。</p>
<h3 id="ActivityStarter-startActivity"><a href="#ActivityStarter-startActivity" class="headerlink" title="ActivityStarter#startActivity"></a>ActivityStarter#startActivity</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="hljs-function"><span class="hljs-params">         String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">         IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">         IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,</span></span><br><span class="hljs-function"><span class="hljs-params">         String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">         SafeActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span></span><br><span class="hljs-function"><span class="hljs-params">         TaskRecord inTask, <span class="hljs-keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="hljs-function"><span class="hljs-params">         PendingIntentRecord originatingPendingIntent, <span class="hljs-keyword">boolean</span> allowBackgroundActivityStart)</span> </span>&#123;<br>     ···<br>     <span class="hljs-comment">// 此处创建了一个ActivityRecord对象</span><br>     <span class="hljs-comment">// 同时会通过ActivityRecord和intent构建appToken</span><br>     ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,<br>             callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),<br>             resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,<br>             mSupervisor, checkedOptions, sourceRecord);<br>     <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;<br>         outActivity[<span class="hljs-number">0</span>] = r;<br>     &#125;<br><br>    ......<br><br>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> res = startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,<br>             <span class="hljs-keyword">true</span> <span class="hljs-comment">/* doResume */</span>, checkedOptions, inTask, outActivity, restrictedBgActivity);<span class="hljs-comment">//4</span><br>     .....<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>startActivity中有个关键点就是，将要启动的Activity的<strong>ActivityRecord</strong>对象在这里被创建。ActivityRecord构建的同时会根据ActivityRecord和intent创建一个<strong>appToken</strong>。appToken是一个IBinder对象，用于提供给WMS关联Window和Activity，后面文章会详细分析。startActivity调用了另一个startActivity的重载，继而调用到了startActivityUnchecked方法。</p>
<h3 id="ActivityStarter-startActivityUnchecked"><a href="#ActivityStarter-startActivityUnchecked" class="headerlink" title="ActivityStarter#startActivityUnchecked"></a>ActivityStarter#startActivityUnchecked</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置初始状态值，这里的r赋值给mStartActivity</span><br>        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,<br>                voiceInteractor);<br>        <span class="hljs-comment">// 计算启动task的标志位Flag</span><br>        <span class="hljs-comment">// 主要处理一些Intent Flag冲突、复用问题</span><br>        <span class="hljs-comment">// 以及SingleInstance和SingleTask的处理</span><br>        computeLaunchingTaskFlags();<br>  <br>        <span class="hljs-comment">// 通过sourceActivity计算sourceTask</span><br>        <span class="hljs-comment">// 主要处理 FLAG_ACTIVITY_NEW_TASK 问题</span><br>        computeSourceStack();<br>  <br>        mIntent.setFlags(mLaunchFlags);<br><br>        <span class="hljs-comment">// 寻找是否有可以复用的ActivityRecord</span><br>        ActivityRecord reusedActivity = getReusableIntentActivity();<br>        ···<br>        <span class="hljs-keyword">if</span> (mReusedActivity != <span class="hljs-keyword">null</span>) &#123;<br>            ···<br>            <span class="hljs-comment">// 将当前栈移至前台</span><br>            mReusedActivity = setTargetStackAndMoveToFrontIfNeeded(mReusedActivity);<br>　　　　　    ···<br>            setTaskFromIntentActivity(mReusedActivity);<br><br>            <span class="hljs-keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="hljs-keyword">null</span>) &#123;<br>                resumeTargetStackIfNeeded();<br>                <span class="hljs-keyword">return</span> START_TASK_TO_FRONT;<br>            &#125;<br>        &#125;<br>　　　　 ···<br>     　　<span class="hljs-comment">//singleTop 或者singleInstance的处理</span><br>        <span class="hljs-keyword">if</span> (dontStart) &#123;<br>            <span class="hljs-comment">// For paranoia, make sure we have correctly resumed the top activity.</span><br>            topStack.mLastPausedActivity = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>                mRootActivityContainer.resumeFocusedStacksTopActivities();<br>            &#125;<br>            ActivityOptions.abort(mOptions);<br>            <span class="hljs-keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// We don&#x27;t need to start a new activity, and the client said not to do</span><br>                <span class="hljs-comment">// anything if that is the case, so this is it!</span><br>                <span class="hljs-keyword">return</span> START_RETURN_INTENT_TO_CALLER;<br>            &#125;<br>            ···<br>            <span class="hljs-comment">// 向已存在的Activity分发新的Intent</span><br>            <span class="hljs-comment">// 会回调其onNewIntent()方法</span><br>            deliverNewIntent(top);<br>　　    　   ···<br>            <span class="hljs-keyword">return</span> START_DELIVERED_TO_TOP;<br>        &#125;<br>  <br>        <span class="hljs-keyword">boolean</span> newTask = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">final</span> TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="hljs-keyword">null</span>)<br>                ? mSourceRecord.getTaskRecord() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 设置对应的task</span><br>        <span class="hljs-keyword">int</span> result = START_SUCCESS;<br>        <span class="hljs-keyword">if</span> (mStartActivity.resultTo == <span class="hljs-keyword">null</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span> &amp;&amp; !mAddingToTask<br>                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="hljs-number">0</span>) &#123;<br>            newTask = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// intent设置了FLAG_ACTIVITY_NEW_TASK，新建task</span><br>            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 设置sourceRecord所在栈，即standard启动模式</span><br>            result = setTaskFromSourceRecord();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mInTask != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 指定了启动的taskAffinity，设置到对应的task中</span><br>            result = setTaskFromInTask();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在当前焦点的task中启动，这种情况不会发生</span><br>            result = setTaskToCurrentTopOrCreateNewTask();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result != START_SUCCESS) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        ··· <br>        <span class="hljs-comment">// mDoResume由外部传入，本次流程中为true</span><br>        <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>            <span class="hljs-comment">// 使用ActivityStaskSupervisor去显示该Activity</span><br>            <span class="hljs-keyword">final</span> ActivityRecord topTaskActivity =<br>                    mStartActivity.getTaskRecord().topRunningActivityLocked();<br>            <span class="hljs-keyword">if</span> (!mTargetStack.isFocusable()<br>                    || (topTaskActivity != <span class="hljs-keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay<br>                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;<br>                <span class="hljs-comment">// If the activity is not focusable, we can&#x27;t resume it, but still would like to</span><br>                <span class="hljs-comment">// make sure it becomes visible as it starts (this will also trigger entry</span><br>                <span class="hljs-comment">// animation). An example of this are PIP activities.</span><br>                <span class="hljs-comment">// Also, we don&#x27;t want to resume activities in a task that currently has an overlay</span><br>                <span class="hljs-comment">// as the starting activity just needs to be in the visible paused state until the</span><br>                <span class="hljs-comment">// over is removed.</span><br>                mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);<br>                <span class="hljs-comment">// Go ahead and tell window manager to execute app transition for this activity</span><br>                <span class="hljs-comment">// since the app transition will not be triggered through the resume channel.</span><br>                mTargetStack.getDisplay().mDisplayContent.executeAppTransition();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前activity是可以获取焦点的但当前Stack没有获取焦点</span><br>                <span class="hljs-keyword">if</span> (mTargetStack.isFocusable()<br>                        &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;<br>                    <span class="hljs-comment">// 将对应Task移至前台</span><br>                    mTargetStack.moveToFront(<span class="hljs-string">&quot;startActivityUnchecked&quot;</span>);<br>                &#125;<br>                 <span class="hljs-comment">// 使栈顶activity可见，即resume状态</span><br>                 mRootActivityContainer.resumeFocusedStacksTopActivities(<br>                        mTargetStack, mStartActivity, mOptions);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mStartActivity != <span class="hljs-keyword">null</span>) &#123;<br>            mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());<br>        &#125;<br>        mRootActivityContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);<br><br>        mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTaskRecord(),<br>                preferredWindowingMode, mPreferredDisplayId, mTargetStack);<br><br>        <span class="hljs-keyword">return</span> START_SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>startActivityUnchecked主要处理任务栈相关，处理singleTop、singleInstance问题，计算Intent Flag，以及栈顶复用问题。接着调用了调用了RootActivityContainer的resumeFocusedStacksTopActivities方法。</p>
<h3 id="RootActivityContainer-resumeFocusedStacksTopActivities"><a href="#RootActivityContainer-resumeFocusedStacksTopActivities" class="headerlink" title="RootActivityContainer#resumeFocusedStacksTopActivities"></a>RootActivityContainer#resumeFocusedStacksTopActivities</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeFocusedStacksTopActivities</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;<br><br>        ......<br><br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (targetStack != <span class="hljs-keyword">null</span> &amp;&amp; (targetStack.isTopStackOnDisplay()<br>                || getTopDisplayFocusedStack() == targetStack)) &#123; <br>            <span class="hljs-comment">// 使栈顶Activity可见（resume）</span><br>            result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);<br>        &#125;<br><br>        .......<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>resumeFocusedStacksTopActivities方法中调用ActivityStack#resumeTopActivityUncheckedLocked启动栈顶的Activity。</p>
<h3 id="ActivityStack-resumeTopActivityUncheckedLocked"><a href="#ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="ActivityStack#resumeTopActivityUncheckedLocked"></a>ActivityStack#resumeTopActivityUncheckedLocked</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mInResumeTopActivity) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 防止递归调用，确保只有一个Activity执行该方法</span><br>        mInResumeTopActivity = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// resume栈顶Activity</span><br>        result = resumeTopActivityInnerLocked(prev, options);<br><br>        <span class="hljs-keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span> || !next.canTurnScreenOn()) &#123;<br>            checkReadyForSleep();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mInResumeTopActivity = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>inResumeTopActivity用于保证每次只有一个Activity执行resumeTopActivityUncheckedLocked()操作。</p>
<h3 id="ActivityStack-resumeTopActivityInnerLocked"><a href="#ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="ActivityStack#resumeTopActivityInnerLocked"></a>ActivityStack#resumeTopActivityInnerLocked</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 获取栈顶未finish的activity</span><br>    ActivityRecord next = topRunningActivityLocked(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>    ···<br>    <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;<br>        ···<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ···<br>        mStackSupervisor.startSpecificActivityLocked(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>resumeTopActivityInnerLocked方法的逻辑非常复杂，主要是判断当前是否真的需要resume栈顶Activity。这里精简了一下，当我们的栈顶activity没有绑定到任何Application的时候，就会调用ActivityStackSupervisor#startSpecificActivityLocked，我们此时恰好就是这种情况。</p>
<h3 id="ActivityStackSupervisor-startSpecificActivityLocked"><a href="#ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="ActivityStackSupervisor#startSpecificActivityLocked"></a>ActivityStackSupervisor#startSpecificActivityLocked</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过ATMS获取目标进程的WindowProcessController对象</span><br>    <span class="hljs-comment">// WindowProcessController用于ActivityManager与WindowManager同步进程状态</span><br>    <span class="hljs-comment">// 如果wpc为空，则表示对应进程不存在或者未启动</span><br>    <span class="hljs-keyword">final</span> WindowProcessController wpc =<br>            mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br><br>    <span class="hljs-keyword">boolean</span> knownToBeDead = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 这里的hasThread表示的是IApplicationThread</span><br>    <span class="hljs-keyword">if</span> (wpc != <span class="hljs-keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 启动activity</span><br>            realStartActivityLocked(r, wpc, andResume, checkConfig);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Exception when starting activity &quot;</span><br>                    + r.intent.getComponent().flattenToShortString(), e);<br>        &#125;<br><br>        <span class="hljs-comment">// If a dead object exception was thrown -- fall through to</span><br>        <span class="hljs-comment">// restart the application.</span><br>        knownToBeDead = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里主要处理键盘锁问题</span><br>    <span class="hljs-keyword">if</span> (getKeyguardController().isKeyguardLocked()) &#123;<br>        r.notifyUnknownVisibilityLaunched();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ···<br>        <span class="hljs-comment">// 如果对应App进程还未启动</span><br>        <span class="hljs-comment">// 通过handler发送消息启动进程</span><br>        <span class="hljs-comment">// 这部分将在下文讨论</span><br>        <span class="hljs-keyword">final</span> Message msg = PooledLambda.obtainMessage(<br>                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,<br>                r.info.applicationInfo, knownToBeDead, <span class="hljs-string">&quot;activity&quot;</span>, r.intent.getComponent());<br>        mService.mH.sendMessage(msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>realStartActivityLocked中将会真正启动一个Activity。</p>
<h3 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor#realStartActivityLocked"></a>ActivityStackSupervisor#realStartActivityLocked</h3><blockquote>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</p>
</blockquote>
<p>realStartActivityLocked方法中创建了一个启动Activity事务，并利用IApplicationThread发送到目标App中，精简后的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            ···<br>            <span class="hljs-comment">// 创建一个启动Activity事务.</span><br>            <span class="hljs-keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(<br>                    proc.getThread(), r.appToken);<br><br>            <span class="hljs-keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;<br>            <span class="hljs-comment">// 添加Callback，注意这里创建的是LaunchActivityItem</span><br>            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="hljs-keyword">new</span> Intent(r.intent),<br>                    System.identityHashCode(r), r.info,<br>                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global</span><br>                    <span class="hljs-comment">// and override configs.</span><br>                    mergedConfiguration.getGlobalConfiguration(),<br>                    mergedConfiguration.getOverrideConfiguration(), r.compat,<br>                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),<br>                    r.icicle, r.persistentState, results, newIntents,<br>                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),<br>                            r.assistToken));<br><br>            <span class="hljs-comment">// 设置此次事务应该执行的最终状态</span><br>            <span class="hljs-comment">// 此次流程将会设置为resume，表示activity应该执行到onResume状态</span><br>            <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem;<br>            <span class="hljs-keyword">if</span> (andResume) &#123;<br>                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lifecycleItem = PauseActivityItem.obtain();<br>            &#125;<br>            clientTransaction.setLifecycleStateRequest(lifecycleItem);<br><br>            <span class="hljs-comment">// 执行事务</span><br>            mService.getLifecycleManager().scheduleTransaction(clientTransaction);<br>    ···<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从Android 8.0开始Activity的启动将会通过事务来完成，事务将会通过目标App的IApplicationThread远程发送到目标App中，然后通过ClientLifecycleManager 来执行。至此ATMS中执行的逻辑就结束了，剩下的就是目标App的ApplicationThread来执行目标Activity的各个生命周期方法了。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>同样的来回顾一下ATMS所做的工作。</p>
<ul>
<li>首先ATMS会判断权限信息，只有具有权限的调用进程才可以启动Activity。</li>
<li>接着ActivityStarter解析Intent的内容，创建对应的ActivityRecord对象，根据是否需要新建Task来新建或者选择对应的TaskRecord添加Activity，并处理Task相关状态信息，例如前后台的转移。</li>
<li>然后就会使前台Task的栈顶Activity可见，这个过程就会启动对应的Activity，必要情况会启动对应的进程。</li>
<li>最后通过IPC调用将启动Activity的事务发送到对应进程中，交由对应App来处理。</li>
</ul>
<p>这部分的时序图如下所示。</p>
<p><img src="/img/framework_atms_start_activity.jpg" srcset="/img/loading.gif" alt="ATMS执行时序图"></p>
<h2 id="ActivityThread启动Activity过程"><a href="#ActivityThread启动Activity过程" class="headerlink" title="ActivityThread启动Activity过程"></a>ActivityThread启动Activity过程</h2><p>经过ATMS的一系列调用后，Activity启动工作终于来到了目标App进程中。</p>
<p>所谓的目标进程，是指目标Activity所在的进程。它与原Activity属于同一进程，也就是App内的Activity启动；也有可能属于另外一个App，这种情况属于跨App启动Activity。</p>
<p>不管是在App内启动还是跨App启动，其流程是一致的，都是由ApplicationThread接收到Binder通信传递过来的事务开始执行。</p>
<h3 id="ApplicationThread-scheduleTransaction"><a href="#ApplicationThread-scheduleTransaction" class="headerlink" title="ApplicationThread#scheduleTransaction"></a>ApplicationThread#scheduleTransaction</h3><blockquote>
<p>frameworks/base/core/java/android/app/ActivityThread.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>    ActivityThread.<span class="hljs-keyword">this</span>.scheduleTransaction(transaction);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ApplicationThread#scheduleTransaction调用了ActivityThread#scheduleTransaction将事务交给主线程处理，ActivityThread#scheduleTransaction方法定义在其父类<strong>ClientTransactionHandler</strong>中。</p>
<h3 id="ClientTransactionHandler-scheduleTransaction"><a href="#ClientTransactionHandler-scheduleTransaction" class="headerlink" title="ClientTransactionHandler#scheduleTransaction"></a>ClientTransactionHandler#scheduleTransaction</h3><blockquote>
<p>frameworks/base/core/java/android/app/ClientTransactionHandler.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    transaction.preExecute(<span class="hljs-keyword">this</span>);<br>    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里调用sendMessage方法往主线程发送了一条what为<strong>ActivityThread.H.EXECUTE_TRANSACTION</strong>的消息，并将事务传递。</p>
<h3 id="ActivityThread-sendMessage"><a href="#ActivityThread-sendMessage" class="headerlink" title="ActivityThread#sendMessage"></a>ActivityThread#sendMessage</h3><p>ApplicationThread运行在Binder线程，与ActivityThread通信需经过Handler，而H是ActivityThread中的一个内部类，它继承自Handler，当ActivityThread调用sendMessage方法时其实就是在调用H#sendMessage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) &#123;<br>        Slog.v(TAG,<br>                <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what) + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>    &#125;<br>    Message msg = Message.obtain();<br>    msg.what = what;<br>    msg.obj = obj;<br>    msg.arg1 = arg1;<br>    msg.arg2 = arg2;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    mH.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="H-handleMessage"><a href="#H-handleMessage" class="headerlink" title="H#handleMessage"></a>H#handleMessage</h3><p>现在我们知道H是Handler的话，就知道消息一定在其handlerMessage方法中进行处理，来看看对应的消息是如何处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>    <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>        <span class="hljs-comment">// 省略一些case</span><br>        ···<br>        <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>            <span class="hljs-keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;<br>            mTransactionExecutor.execute(transaction);<br>            <span class="hljs-keyword">if</span> (isSystem()) &#123;<br>                <span class="hljs-comment">// Client transactions inside system process are recycled on the client side</span><br>                <span class="hljs-comment">// instead of ClientLifecycleManager to avoid being cleared before this</span><br>                <span class="hljs-comment">// message is handled.</span><br>                transaction.recycle();<br>            &#125;<br>            <span class="hljs-comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 省略一些case</span><br>        ···<br>    &#125;<br>    Object obj = msg.obj;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> SomeArgs) &#123;<br>        ((SomeArgs) obj).recycle();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中使用TransactionExecutor#execute来执行事务。</p>
<h3 id="TransactionExecutor-execute"><a href="#TransactionExecutor-execute" class="headerlink" title="TransactionExecutor#execute"></a>TransactionExecutor#execute</h3><p>TransactionExecutor是专门用于处理事务的类，用于保证事务以正确的顺序执行。</p>
<blockquote>
<p>frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Start resolving transaction&quot;</span>);<br>    <span class="hljs-comment">// ActivityRecord中的appToken</span><br>    <span class="hljs-keyword">final</span> IBinder token = transaction.getActivityToken();<br>    ···<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler));<br>    <span class="hljs-comment">// 执行所有Callback</span><br>    executeCallbacks(transaction);<br>    <span class="hljs-comment">// 执行到对应生命周期</span><br>    executeLifecycleState(transaction);<br>    mPendingActions.clear();<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;End resolving transaction&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之前我们在<strong>ActivityStackSupervisor</strong>中创建事务并且通过<strong>addCallback</strong>的的方式将其添加到ClientTransaction中，现在调用executeCallbacks来执行每个Callback。</p>
<h3 id="TransactionExecutor-executeCallbacks"><a href="#TransactionExecutor-executeCallbacks" class="headerlink" title="TransactionExecutor#executeCallbacks"></a>TransactionExecutor#executeCallbacks</h3><blockquote>
<p>frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeCallbacks</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();<br>    <span class="hljs-keyword">if</span> (callbacks == <span class="hljs-keyword">null</span> || callbacks.isEmpty()) &#123;<br>        <span class="hljs-comment">// 快速返回路径</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Resolving callbacks in transaction&quot;</span>);<br><br>    <span class="hljs-keyword">final</span> IBinder token = transaction.getActivityToken();<br>    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);<br><br>    <span class="hljs-keyword">final</span> ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> finalState = finalStateRequest != <span class="hljs-keyword">null</span> ? finalStateRequest.getTargetState()<br>            : UNDEFINED;<br>    <span class="hljs-comment">// Index of the last callback that requests some post-execution state.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> lastCallbackRequestingState = lastCallbackRequestingState(transaction);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = callbacks.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> ClientTransactionItem item = callbacks.get(i);<br>        <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Resolving callback: &quot;</span> + item);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> postExecutionState = item.getPostExecutionState();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> closestPreExecutionState = mHelper.getClosestPreExecutionState(r,<br>                item.getPostExecutionState());<br>        <span class="hljs-keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;<br>            <span class="hljs-comment">// 这个方法可以平滑的执行生命周期</span><br>            cycleToPath(r, closestPreExecutionState, transaction);<br>        &#125;<br>        <span class="hljs-comment">// 执行item的execute方法</span><br>        item.execute(mTransactionHandler, token, mPendingActions);<br>        item.postExecute(mTransactionHandler, token, mPendingActions);<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Launch activity request will create an activity record.</span><br>            r = mTransactionHandler.getActivityClient(token);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Skip the very last transition and perform it by explicit state request instead.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldExcludeLastTransition =<br>                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;<br>            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上节代码我们知道启动Activity时创建的ClientTransactionItem为<strong>LaunchActivityItem</strong>，后面将执行它的execute方法。</p>
<h3 id="LaunchActivityItem-execute"><a href="#LaunchActivityItem-execute" class="headerlink" title="LaunchActivityItem#execute"></a>LaunchActivityItem#execute</h3><blockquote>
<p>frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;activityStart&quot;</span>);<br>    ActivityClientRecord r = <span class="hljs-keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,<br>            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,<br>            mPendingResults, mPendingNewIntents, mIsForward,<br>            mProfilerInfo, client, mAssistToken);<br>    <span class="hljs-comment">// 处理启动Activity前的事项</span><br>    client.handleLaunchActivity(r, pendingActions, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>client是ActivityThread，方法中调用ActivityThread#handleLaunchActivity来启动Activity。</p>
<h3 id="ActivityThread-handleLaunchActivity"><a href="#ActivityThread-handleLaunchActivity" class="headerlink" title="ActivityThread#handleLaunchActivity"></a>ActivityThread#handleLaunchActivity</h3><blockquote>
<p>frameworks/base/core/java/android/app/ActivityThread.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 初始化WindowManager</span><br>    WindowManagerGlobal.initialize();<br>    ···<br>    <span class="hljs-comment">// 启动Activity</span><br>    <span class="hljs-keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<br>    ···<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Activity启动的核心代码都在performLaunchActivity方法里。</p>
<h3 id="ActivityThread-performLaunchActivity"><a href="#ActivityThread-performLaunchActivity" class="headerlink" title="ActivityThread#performLaunchActivity"></a>ActivityThread#performLaunchActivity</h3><blockquote>
<p>frameworks/base/core/java/android/app/ActivityThread.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    ···<br>    <span class="hljs-comment">// 为Activity创建Context</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    Activity activity = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 反射创建Activity对象</span><br>        java.lang.ClassLoader cl = appContext.getClassLoader();<br>        activity = mInstrumentation.newActivity(<br>                cl, component.getClassName(), r.intent);<br>        StrictMode.incrementExpectedActivityCount(activity.getClass());<br>        r.intent.setExtrasClassLoader(cl);<br>        r.intent.prepareToEnterProcess();<br>        <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>            r.state.setClassLoader(cl);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Unable to instantiate activity &quot;</span> + component<br>                + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取Application实例</span><br>        Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);<br>        ···<br>        <span class="hljs-keyword">if</span> (activity != <span class="hljs-keyword">null</span>) &#123;<br>            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());<br>            Configuration config = <span class="hljs-keyword">new</span> Configuration(mCompatConfiguration);<br>            <span class="hljs-keyword">if</span> (r.overrideConfig != <span class="hljs-keyword">null</span>) &#123;<br>                config.updateFrom(r.overrideConfig);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="hljs-string">&quot;Launching activity &quot;</span><br>                    + r.activityInfo.name + <span class="hljs-string">&quot; with config &quot;</span> + config);<br>            Window window = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (r.mPendingRemoveWindow != <span class="hljs-keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;<br>                window = r.mPendingRemoveWindow;<br>                r.mPendingRemoveWindow = <span class="hljs-keyword">null</span>;<br>                r.mPendingRemoveWindowManager = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            appContext.setOuterContext(activity);<br>            <span class="hljs-comment">// 调用activity.attach进行初始化</span><br>            <span class="hljs-comment">// 建立Context与Activity的联系，Window将会在这里创建</span><br>            <span class="hljs-comment">// 后面会出文章详解</span><br>            activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>                    r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                    r.embeddedID, r.lastNonConfigurationInstances, config,<br>                    r.referrer, r.voiceInteractor, window, r.configCallback,<br>                    r.assistToken);<br><br>            ···<br>            <span class="hljs-comment">// 回调onCreate</span><br>            <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mInstrumentation.callActivityOnCreate(activity, r.state);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!activity.mCalled) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>                    <span class="hljs-string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +<br>                    <span class="hljs-string">&quot; did not call through to super.onCreate()&quot;</span>);<br>            &#125;<br>            r.activity = activity;<br>        &#125;<br>        <span class="hljs-comment">// 更新LifeCycle状态</span><br>        r.setState(ON_CREATE);<br>        ···<br>    <span class="hljs-keyword">return</span> activity;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此Activity就已经被成功创建，并执行了其生命周期相关方法。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Activity真正的启动工作在其对应的App中进行，主要有几个步骤：</p>
<ul>
<li>ApplicationThread接收到ATMS发送过来的事务，通过Handler发送到主线程处理。</li>
<li>ActivityThread内部Handler（H）处理消息，并将事务交给TransactionExecutor处理。</li>
<li>TransactionExecutor执行事务的所有Callback，继而执行ActivityThread#handleLaunchActivity。</li>
<li>ActivityThread#handleLaunchActivity调用performLaunchActivity方法来执行核心逻辑。</li>
<li>ActivityThread#performLaunchActivity中反射创建的Activity实例，并且调用了attach方法绑定一些信息，然后调用callActivityOnCreate执行Activity生命周期。</li>
</ul>
<p>这部分的时序图如下所示。</p>
<p><img src="/img/framwork_target_app_start_activity.jpg" srcset="/img/loading.gif" alt="目标进程启动Activity过程时序图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于Android API 29源码分析了Activity的启动流程。整个过程涉及了四个进程和两次IPC调用，这四个进程分别是<strong>Launcher进程</strong>、<strong>SystemServer进程</strong>、<strong>应用程序进程</strong>、以及可能参与的<strong>Zygote进程</strong>。</p>
<p>我们来总结一下这几个过程的工作：</p>
<ol>
<li>Launcher进程：通过点击图标生成Intent，通知ATMS启动对应Activity。</li>
<li>SystemServer进程：<ul>
<li>检查调用（Launcher）进程是否被隔离、是否有权限启动Activity，然后生成ActivityStarter来处理Activity启动事宜。</li>
<li>解析Intent中的信息，通过这些信息解析出包含Activity信息的ActivityInfo对象。判断Activity是否有在清单文件中注册、是否有权限等。</li>
<li>计算Intent的Flags，处理LaunchMode问题，判断Activity的目标任务栈，将Activity添加到任务栈中。</li>
<li>将任务栈移至前台，使栈顶的Activity可见，会创建一个事务并通过IPC发送到目标App进程。</li>
<li>如果App进程不存在，启动App进程。</li>
</ul>
</li>
<li>应用程序进程：<ul>
<li>接收SystemServer传递的事务并且执行事务。</li>
<li>反射创建Activity对象，为Activity创建Context、Window等。</li>
<li>回调其onCreate、onStart、onResume生命周期。</li>
</ul>
</li>
</ol>
<p>Launcher进程负责通知ATMS发起Activity启动；SystemServer进程中参与的主要是ATMS服务，它负责计算构造目标的Intent、处理TaskRecord和ActivityRecord信息、以及ActivityStack的处理，最后将启动消息发送到对应应用程序进程；应用程序进程负责接收ATMS发送过来的事务并处理，Activity的创建以及生命周期的回调都在这里处理。</p>
<p>若应用程序进程还未启动，Zygote进程还需要参与进来创建对应进程。</p>
<p>下篇文章将会继续分析Zygote进程创建目标App进程的过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:">Android API 29 Platform</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30358046/">《Android进阶解密》</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener" href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9c12cd6a35e0">Android Fk: Activty管理之token总结</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android-Framework/">Android Framework</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/AOSP/">AOSP</a>
                    
                      <a class="hover-with-bg" href="/tags/Activity/">Activity</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/06/03/31b8eb1c/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android Framework（三）——应用程序进程启动流程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/14/7ca6484e/">
                        <span class="hidden-mobile">Android Framework（一）——关键系统进程启动过程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'sukaidev/sukaidev.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Powered by  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> , Theme  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>





  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
