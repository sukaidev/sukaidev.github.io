

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Android Developer">
  <meta name="author" content="sukaidev">
  <meta name="keywords" content="Android sukaidev 苏海鸿">
  <title>Android Framework（五）——Activity生命周期分析 - Sukai&#39;s Blog - Android Developer</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.sukaidev.top","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sukai's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android Framework（五）——Activity生命周期分析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-15 21:22" pubdate>
        2021年7月15日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      107
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android Framework（五）——Activity生命周期分析</h1>
            
            <div class="markdown-body">
              <p>在系列<a href="/2021/05/22/4cb0a496/#ActivityThread-performLaunchActivity">第二篇文章</a>中我们知道了Activity的整个启动流程，知道Activity是在App接收到启动Activity请求时通过反射的方式创建，在创建之后紧接着就会回调其生命周期。</p>
<p>本篇文章将会从Activity#attach开始，分析Activity在各个生命周期阶段的主要工作。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>通过<a href="/2021/05/22/4cb0a496/#ActivityThread-performLaunchActivity">之前的文章</a>，Activity的创建由ActivityThread的performLaunchActivity来完成，在创建完成后首先会调用其attach方法将一些数据与Activity进行绑定，来看看attach方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,</span></span><br><span class="hljs-function"><span class="hljs-params">        Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,</span></span><br><span class="hljs-function"><span class="hljs-params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="hljs-function"><span class="hljs-params">        CharSequence title, Activity parent, String id,</span></span><br><span class="hljs-function"><span class="hljs-params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;<br>    attachBaseContext(context);<br><br>    <span class="hljs-comment">// 为FragmentManager绑定Controller</span><br>    mFragments.attachHost(<span class="hljs-keyword">null</span> <span class="hljs-comment">/*parent*/</span>);<br><br>    <span class="hljs-comment">// 创建Window，并初始化</span><br>    mWindow = <span class="hljs-keyword">new</span> PhoneWindow(<span class="hljs-keyword">this</span>, window, activityConfigCallback);<br>    mWindow.setWindowControllerCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.setCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.setOnWindowDismissedCallback(<span class="hljs-keyword">this</span>);<br>    mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;<br>        mWindow.setSoftInputMode(info.softInputMode);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (info.uiOptions != <span class="hljs-number">0</span>) &#123;<br>        mWindow.setUiOptions(info.uiOptions);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 初始化一些变量</span><br>    mUiThread = Thread.currentThread();<br>    mMainThread = aThread;<br>    mInstrumentation = instr;<br>    mToken = token;<br>    mAssistToken = assistToken;<br>    mIdent = ident;<br>    mApplication = application;<br>    mIntent = intent;<br>    mReferrer = referrer;<br>    mComponent = intent.getComponent();<br>    mActivityInfo = info;<br>    mTitle = title;<br>    mParent = parent;<br>    mEmbeddedID = id;<br>    mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 为Window绑定WindowManager</span><br>    mWindow.setWindowManager(<br>            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),<br>            mToken, mComponent.flattenToString(),<br>            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>);<br>  <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure>
<p>attach方法为Activity注入外部环境的一些对象，其中为Activity创建了Window。</p>
<h2 id="Create阶段"><a href="#Create阶段" class="headerlink" title="Create阶段"></a>Create阶段</h2><p>执行完attach方法后，ActivityThread将会调用Instrumentation中的callActivityOnCreate方法来开启Activity的Create阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mInstrumentation.callActivityOnCreate(activity, r.state);<br></code></pre></td></tr></table></figure>
<p>这里会分为三个步骤：</p>
<ul>
<li>prePerformCreate：执行在Activity#onCreate之前，完成一些预处理</li>
<li>performCreate：回调Activity#onCreate方法</li>
<li>postPerformCreate：执行在Activity#onCreate之后，完成一些收尾工作</li>
</ul>
<h3 id="Instrumentation-prePerformCreate"><a href="#Instrumentation-prePerformCreate" class="headerlink" title="Instrumentation#prePerformCreate"></a>Instrumentation#prePerformCreate</h3><p>此方法用于将同步启动的Activity从列表mWaitingActivities中移除。</p>
<p>同步启动是指使用<code>Instrumentation#startActivitySync</code>方法启动的Activity，使用此方法启动Activity会同步执行到Activity成功运行才会返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prePerformCreate</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mWaitingActivities != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mWaitingActivities.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                <span class="hljs-keyword">final</span> ActivityWaiter aw = mWaitingActivities.get(i);<br>                <span class="hljs-keyword">final</span> Intent intent = aw.intent;<br>                <span class="hljs-keyword">if</span> (intent.filterEquals(activity.getIntent())) &#123;<br>                    aw.activity = activity;<br>                    mMessageQueue.addIdleHandler(<span class="hljs-keyword">new</span> ActivityGoing(aw));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，所谓的“Activity成功运行”其实就是在create阶段中，不过这里并不会确保在prePerformCreate执行后就立即解除阻塞状态，因为这里用的是IdleHandler。</p>
<h3 id="Activity-performCreate"><a href="#Activity-performCreate" class="headerlink" title="Activity#performCreate"></a>Activity#performCreate</h3><p>此部分将会真正回调Activity的onCreate方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle)</span> </span>&#123;<br>    performCreate(icicle, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;<br>    <span class="hljs-comment">// 分发preCreated事件</span><br>    dispatchActivityPreCreated(icicle);<br>    mCanEnterPictureInPicture = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 恢复权限相关标志变量</span><br>    restoreHasCurrentPermissionRequest(icicle);<br>    <span class="hljs-comment">// 回调onCreate</span><br>    <span class="hljs-keyword">if</span> (persistentState != <span class="hljs-keyword">null</span>) &#123;<br>        onCreate(icicle, persistentState);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        onCreate(icicle);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 恢复转场动画相关</span><br>    mActivityTransitionState.readState(icicle);<br><br>    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(<br>            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="hljs-keyword">false</span>);<br>  <br>    <span class="hljs-comment">// 通知fragment分发create事件</span><br>    mFragments.dispatchActivityCreated();<br>    mActivityTransitionState.setEnterActivityOptions(<span class="hljs-keyword">this</span>, getActivityOptions());<br>    <span class="hljs-comment">// 分发postCreated事件</span><br>    dispatchActivityPostCreated(icicle);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到这里除了回调Activity的onCreate生命周期回调外，还会通知FragmentManager分发onActivityCreated事件，以及调用ActivityLifecycleCallback中的切面方法。</p>
<h4 id="Activity-onCreate"><a href="#Activity-onCreate" class="headerlink" title="Activity#onCreate"></a>Activity#onCreate</h4><p>onCreate方法中主要是对于异常重启的Activity恢复一些数据，然后调用dispatchActivityCreated来回调所有ActivityLifecycleCallback。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mLastNonConfigurationInstances != <span class="hljs-keyword">null</span>) &#123;<br>        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActivityInfo.parentActivityName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mActionBar == <span class="hljs-keyword">null</span>) &#123;<br>            mEnableDefaultActionBarUp = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mActionBar.setDefaultDisplayHomeAsUpEnabled(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, <span class="hljs-keyword">false</span>);<br>        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,<br>                View.LAST_APP_AUTOFILL_ID);<br><br>        <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>            getAutofillManager().onCreate(savedInstanceState);<br>        &#125;<br><br>        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<br>        mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="hljs-keyword">null</span><br>                ? mLastNonConfigurationInstances.fragments : <span class="hljs-keyword">null</span>);<br>    &#125;<br>    mFragments.dispatchCreate();<br>    dispatchActivityCreated(savedInstanceState);<br>    <span class="hljs-keyword">if</span> (mVoiceInteractor != <span class="hljs-keyword">null</span>) &#123;<br>        mVoiceInteractor.attachActivity(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    mRestoredFromBundle = savedInstanceState != <span class="hljs-keyword">null</span>;<br>    mCalled = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Instrumentation-postPerformCreate"><a href="#Instrumentation-postPerformCreate" class="headerlink" title="Instrumentation#postPerformCreate"></a>Instrumentation#postPerformCreate</h3><p>此方法是<code>Instrumentation.postPerformCreate</code>所做工作是一致的，主要是保证Activity从列表mWaitingActivities中移除。</p>
<h2 id="Start阶段"><a href="#Start阶段" class="headerlink" title="Start阶段"></a>Start阶段</h2><p>执行完ActivityThread中的performLaunchActivity方法之后，Activity就已经被成功启动，不过此时Activity还处于<code>ON_CREATE</code>状态，而我们是希望此Activity的目标状态（Target State）是<code>ON_RESUME</code>，那么我们还需要顺序的执行Activity的生命周期回调onStart和onResume。</p>
<p>执行完LaunchActivity这个事务后，TransactionExecutor会帮我们平滑的将Activity的生命周期执行到Target State。主要是在cycleToPath方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleToPath</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">boolean</span> excludeLastState,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前生命周期，ON_CREATE</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = r.getLifecycleState();<br>    <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) &#123;<br>        Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Cycle activity: &quot;</span><br>                + getShortActivityName(r.token, mTransactionHandler)<br>                + <span class="hljs-string">&quot; from: &quot;</span> + getStateName(start) + <span class="hljs-string">&quot; to: &quot;</span> + getStateName(finish)<br>                + <span class="hljs-string">&quot; excludeLastState: &quot;</span> + excludeLastState);<br>    &#125;<br>  <br>    <span class="hljs-comment">// finish表示Target State，本次流程为ON_RESUME</span><br>    <span class="hljs-keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);<br>    performLifecycleSequence(r, path, transaction);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>cycleToPath计算了我们的起始阶段和终止阶段，并且调用了TransactionExecutorHelper中的getLifecyclePath得到了一个IntArray path，并将path传递给了performLifecycleSequence方法，此IntArray中存储了需要顺序执行的生命周期。</p>
<p>performLifecycleSequence方法负责根据path来调用ClientTransactionHandler中的具体方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLifecycleSequence</span><span class="hljs-params">(ActivityClientRecord r, IntArray path,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = path.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, state; i &lt; size; i++) &#123;<br>        state = path.get(i);<br>        <span class="hljs-keyword">if</span> (DEBUG_RESOLVER) &#123;<br>            Slog.d(TAG, tId(transaction) + <span class="hljs-string">&quot;Transitioning activity: &quot;</span><br>                    + getShortActivityName(r.token, mTransactionHandler)<br>                    + <span class="hljs-string">&quot; to state: &quot;</span> + getStateName(state));<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>            <span class="hljs-keyword">case</span> ON_CREATE:<br>                mTransactionHandler.handleLaunchActivity(r, mPendingActions,<br>                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_START:<br>                mTransactionHandler.handleStartActivity(r, mPendingActions);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESUME:<br>                mTransactionHandler.handleResumeActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        r.isForward, <span class="hljs-string">&quot;LIFECYCLER_RESUME_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_PAUSE:<br>                mTransactionHandler.handlePauseActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finished */</span>,<br>                        <span class="hljs-keyword">false</span> <span class="hljs-comment">/* userLeaving */</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, mPendingActions,<br>                        <span class="hljs-string">&quot;LIFECYCLER_PAUSE_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_STOP:<br>                mTransactionHandler.handleStopActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* show */</span>,<br>                        <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, mPendingActions, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        <span class="hljs-string">&quot;LIFECYCLER_STOP_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_DESTROY:<br>                mTransactionHandler.handleDestroyActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finishing */</span>,<br>                        <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* getNonConfigInstance */</span>,<br>                        <span class="hljs-string">&quot;performLifecycleSequence. cycling to:&quot;</span> + path.get(size - <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESTART:<br>                mTransactionHandler.performRestartActivity(r.token, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* start */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unexpected lifecycle state: &quot;</span> + state);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码很简单，就是根据path中的值来调用ClientTransactionHandler中的对应方法。</p>
<p>本次流程中，目前Activity的状态是<code>ON_START</code>，那么将会调用ClientTransactionHandler中的handleStartActivity方法。</p>
<p>前面文章已经说过，ClientTransactionHandler的实现类就是ActivityThread，我们来看方法的源码。</p>
<h3 id="ActivityThread-handleStartActivity"><a href="#ActivityThread-handleStartActivity" class="headerlink" title="ActivityThread#handleStartActivity"></a>ActivityThread#handleStartActivity</h3><p>与handleLaunchActivity方法类似，handleStartActivity用于处理Activity的<code>ON_START</code>生命周期，其中就会回调Activity的onStart方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStartActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Activity activity = r.activity;<br>    <span class="hljs-keyword">if</span> (r.activity == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Can&#x27;t start activity that is not stopped.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r.activity.mFinished) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// activity的start生命周期工作</span><br>    activity.performStart(<span class="hljs-string">&quot;handleStartActivity&quot;</span>);<br>    r.setState(ON_START);<br><br>    <span class="hljs-keyword">if</span> (pendingActions == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理Activity的重启恢复数据</span><br>    <span class="hljs-comment">// 调用onRestoreInstanceState恢复数据</span><br>    <span class="hljs-keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;<br>        <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>            <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span> || r.persistentState != <span class="hljs-keyword">null</span>) &#123;<br>                <br>                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,<br>                        r.persistentState);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用Activity.onPostCreate()方法</span><br>    <span class="hljs-keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;<br>        activity.mCalled = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>            mInstrumentation.callActivityOnPostCreate(activity, r.state,<br>                    r.persistentState);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mInstrumentation.callActivityOnPostCreate(activity, r.state);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!activity.mCalled) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>                    <span class="hljs-string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot; did not call through to super.onPostCreate()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到此阶段除了要执行Activity的performStart方法处理<code>ON_START</code>状态之外，还会考虑是否要调用onRestoreInstanceState来恢复数据，之后会调用Activity的onPostCreate方法，此方法我们通常不会去重写它，主要是通知系统相关类来完成初始化。</p>
<h3 id="Activity-performStart"><a href="#Activity-performStart" class="headerlink" title="Activity#performStart"></a>Activity#performStart</h3><p>performStart方法与performCreate方法类似，主要是分发preStart事件、调用onStart、分发postStart事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStart</span><span class="hljs-params">(String reason)</span> </span>&#123;<br>    dispatchActivityPreStarted();<br>    mActivityTransitionState.setEnterActivityOptions(<span class="hljs-keyword">this</span>, getActivityOptions());<br>    mFragments.noteStateNotSaved();<br>    mCalled = <span class="hljs-keyword">false</span>;<br>    mFragments.execPendingActions();<br>    <span class="hljs-comment">// 调用onStart回调</span><br>    mInstrumentation.callActivityOnStart(<span class="hljs-keyword">this</span>);<br>    writeEventLog(LOG_AM_ON_START_CALLED, reason);<br><br>    <span class="hljs-keyword">if</span> (!mCalled) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SuperNotCalledException(<br>            <span class="hljs-string">&quot;Activity &quot;</span> + mComponent.toShortString() +<br>            <span class="hljs-string">&quot; did not call through to super.onStart()&quot;</span>);<br>    &#125;<br>    mFragments.dispatchStart();<br>    mFragments.reportLoaderStart();<br><br>    <span class="hljs-keyword">boolean</span> isAppDebuggable =<br>            (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// This property is set for all non-user builds except final release</span><br>    <span class="hljs-keyword">boolean</span> isDlwarningEnabled = SystemProperties.getInt(<span class="hljs-string">&quot;ro.bionic.ld.warning&quot;</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-comment">// 对于Debug包会弹出一个Debuggable的提示</span><br>    <span class="hljs-keyword">if</span> (isAppDebuggable || isDlwarningEnabled) &#123;<br>        String dlwarning = getDlWarning();<br>        <span class="hljs-keyword">if</span> (dlwarning != <span class="hljs-keyword">null</span>) &#123;<br>            String appName = getApplicationInfo().loadLabel(getPackageManager())<br>                    .toString();<br>            String warning = <span class="hljs-string">&quot;Detected problems with app native libraries\n&quot;</span> +<br>                             <span class="hljs-string">&quot;(please consult log for detail):\n&quot;</span> + dlwarning;<br>            <span class="hljs-keyword">if</span> (isAppDebuggable) &#123;<br>                  <span class="hljs-keyword">new</span> AlertDialog.Builder(<span class="hljs-keyword">this</span>).<br>                      setTitle(appName).<br>                      setMessage(warning).<br>                      setPositiveButton(android.R.string.ok, <span class="hljs-keyword">null</span>).<br>                      setCancelable(<span class="hljs-keyword">false</span>).<br>                      show();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Toast.makeText(<span class="hljs-keyword">this</span>, appName + <span class="hljs-string">&quot;\n&quot;</span> + warning, Toast.LENGTH_LONG).show();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(<span class="hljs-keyword">this</span>);<br><br>    mActivityTransitionState.enterReady(<span class="hljs-keyword">this</span>);<br>    dispatchActivityPostStarted();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Activity的onStart回调通过Instrumentation来执行，来看看onStart源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;onStart &quot;</span> + <span class="hljs-keyword">this</span>);<br>    mCalled = <span class="hljs-keyword">true</span>;<br>  <br>    <span class="hljs-comment">// 执行Loader的start方法</span><br>    mFragments.doLoaderStart();<br><br>    <span class="hljs-comment">// 分发start事件</span><br>    dispatchActivityStarted();<br><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        getAutofillManager().onVisibleForAutofill();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Resume阶段"><a href="#Resume阶段" class="headerlink" title="Resume阶段"></a>Resume阶段</h2><p>由于我们的Activity目标状态为<code>ON_RESUME</code>，因此执行完handleStartActivity方法后，将会继续执行handleResumeActivity方法。</p>
<h3 id="ActivityThread-handleResumeActivity"><a href="#ActivityThread-handleResumeActivity" class="headerlink" title="ActivityThread#handleResumeActivity"></a>ActivityThread#handleResumeActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,</span></span><br><span class="hljs-function"><span class="hljs-params">        String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// 在后台时可能发送了gcIdler，这里取消掉</span><br>    unscheduleGcIdler();<br>  <br>    <span class="hljs-comment">// 这个值在之前gcWatch里面有用到，为true时会才会考虑回收Activity</span><br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 处理生命周期到onResume</span><br>    <span class="hljs-keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActivitiesToBeDestroyed.containsKey(token)) &#123;<br>        <span class="hljs-comment">// 对于马上要destroy的Activity，后续操作已经无意义</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Activity a = r.activity;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> forwardBit = isForward<br>            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 在调用startActivity后mStartedActivity会置为true</span><br>    <span class="hljs-comment">// 当我们在resume之前调用了startActivity，那么此Activity不应该显示</span><br>    <span class="hljs-comment">// 而是应该显示最新启动的Activity</span><br>    <span class="hljs-keyword">boolean</span> willBeVisible = !a.mStartedActivity;<br>    <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 跟ATMS再确认一次</span><br>            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(<br>                    a.getActivityToken());<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// window还未被添加到WindowManager同时Activity是需要显示的</span><br>    <span class="hljs-keyword">if</span> (r.window == <span class="hljs-keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;<br>        r.window = r.activity.getWindow();<br>        View decor = r.window.getDecorView();<br>        decor.setVisibility(View.INVISIBLE);<br>        ViewManager wm = a.getWindowManager();<br>        WindowManager.LayoutParams l = r.window.getAttributes();<br>        a.mDecor = decor;<br>        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;<br>        l.softInputMode |= forwardBit;<br>        <span class="hljs-keyword">if</span> (r.mPreserveWindow) &#123;<br>            a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>            r.mPreserveWindow = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 对于复用decorView，通知ViewRoot</span><br>            ViewRootImpl impl = decor.getViewRootImpl();<br>            <span class="hljs-keyword">if</span> (impl != <span class="hljs-keyword">null</span>) &#123;<br>                impl.notifyChildRebuilt();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;<br>            <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<br>                a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 将decorView添加到WindowManager</span><br>                wm.addView(decor, l);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a.onWindowAttributesChanged(l);<br>            &#125;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Launch &quot;</span> + r + <span class="hljs-string">&quot; mStartedActivity set&quot;</span>);<br>        r.hideForNow = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Get rid of anything left hanging around.</span><br>    cleanUpPendingRemoveWindows(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* force */</span>);<br><br>    <span class="hljs-comment">// 当前window确定是要显示的</span><br>    <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="hljs-keyword">null</span> &amp;&amp; !r.hideForNow) &#123;<br>        <span class="hljs-keyword">if</span> (r.newConfig != <span class="hljs-keyword">null</span>) &#123;<br>          <br>            <span class="hljs-comment">// onConfigurationChanged方法在此处被调用</span><br>            performConfigurationChangedForActivity(r, r.newConfig);<br>            r.newConfig = <span class="hljs-keyword">null</span>;<br>        &#125;<br>   <br>        WindowManager.LayoutParams l = r.window.getAttributes();<br>        <span class="hljs-keyword">if</span> ((l.softInputMode<br>                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)<br>                != forwardBit) &#123;<br>            l.softInputMode = (l.softInputMode<br>                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))<br>                    | forwardBit;<br>            <span class="hljs-keyword">if</span> (r.activity.mVisibleFromClient) &#123;<br>                ViewManager wm = a.getWindowManager();<br>                View decor = r.window.getDecorView();<br>                <br>                <span class="hljs-comment">// 更新DecorView的LayoutParams</span><br>                wm.updateViewLayout(decor, l);<br>            &#125;<br>        &#125;<br>      <br>      ···<br>&#125;<br></code></pre></td></tr></table></figure>
<p>handleResumeActivity方法会判断此Activity的Window是否已经添加到WindowManager中，以及是否是真正需要显示的。如果是要显示的并且还未添加，那么将会调用WindowManager的addView方法来讲将decor添加到WindowManager中，这是Resume阶段的关键方法，来看一下。</p>
<h3 id="WindowManagerImpl-addView"><a href="#WindowManagerImpl-addView" class="headerlink" title="WindowManagerImpl#addView"></a>WindowManagerImpl#addView</h3><p>WindowManager是一个接口，其实现类为WindowManagerImpl，来看看addView方法源码。</p>
<blockquote>
<p>frameworks/base/core/java/android/view/WindowManagerImpl.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;<br>    applyDefaultToken(params);<br>    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处调用了两个方法，applyDefaultToken方法中会检测传入的LayoutParams必须为WindowManager.LayoutParams，否则会直接抛异常。另外如果当前Window没有父Window，这意味这它的token有可能为null，此时会将其赋值为默认的token。</p>
<p>接下来调用了WindowManagerGlobal中的addView方法。</p>
<h3 id="WindowManagerGlobal-addView"><a href="#WindowManagerGlobal-addView" class="headerlink" title="WindowManagerGlobal#addView"></a>WindowManagerGlobal#addView</h3><p>WindowManagerGlobal是一个全局的单例对象，其代理了WindowManagerImpl中的一些与上下文Context无关的方法，负责具体的WindowManager操作。</p>
<p>WindowManagerGlobal内部维护了此WindowManager管理的所有View、ViewRoot和它们的LayoutParams，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="hljs-keyword">new</span> ArrayList&lt;View&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="hljs-keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =<br>        <span class="hljs-keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();<br></code></pre></td></tr></table></figure>
<p>简单的介绍了WindowManagerGlobal之后，继续来看addView的源码：</p>
<blockquote>
<p>frameworks/base/core/java/android/view/WindowManagerGlobal.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="hljs-function"><span class="hljs-params">        Display display, Window parentWindow)</span> </span>&#123;<br>  <br>    ···<br><br>    ViewRootImpl root;<br>    View panelParentView = <span class="hljs-keyword">null</span>;<br>  <br>    ···<br><br>        <span class="hljs-comment">// 对于一个PanelWindow，需要找到它的父Window对应的View</span><br>        <span class="hljs-keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;<br>                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mViews.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                <span class="hljs-keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;<br>                    panelParentView = mViews.get(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>  <br>        <span class="hljs-comment">// 对于每一个Window 都有一个ViewRoomtImpl与之对应</span><br>        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);<br><br>        view.setLayoutParams(wparams);<br><br>        mViews.add(view);<br>        mRoots.add(root);<br>        mParams.add(wparams);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            root.setView(view, wparams, panelParentView);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            <span class="hljs-comment">// 有可能会抛出熟知的BadTokenException异常</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                removeViewLocked(index, <span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此方法中创建了一个ViewRoomImpl，并且调用了ViewRoomImpl中的setView方法将当前view设置进去。</p>
<h3 id="ViewRootImpl-setView"><a href="#ViewRootImpl-setView" class="headerlink" title="ViewRootImpl#setView"></a>ViewRootImpl#setView</h3><p>ViewRootImpl的setView方法代码比较多，我们只需要关注关键信息即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mView == <span class="hljs-keyword">null</span>) &#123;<br>            mView = view;<br>            <br>            ···<br>              <br>            <span class="hljs-keyword">int</span> res; <span class="hljs-comment">/* = WindowManagerImpl.ADD_OKAY; */</span><br><br>            requestLayout();<br>          <br>            mForceDecorViewVisibility = (mWindowAttributes.privateFlags<br>                    &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mOrigWindowType = mWindowAttributes.type;<br>                mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;<br>                collectViewAttributes();<br>              <br>                <span class="hljs-comment">// 将Window与WindowManagerService绑定</span><br>                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                        getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,<br>                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,<br>                        mTempInsets);<br>                setFrame(mTmpFrame);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                mAdded = <span class="hljs-keyword">false</span>;<br>                mView = <span class="hljs-keyword">null</span>;<br>                mAttachInfo.mRootView = <span class="hljs-keyword">null</span>;<br>                mInputChannel = <span class="hljs-keyword">null</span>;<br>                mFallbackEventHandler.setView(<span class="hljs-keyword">null</span>);<br>                unscheduleTraversals();<br>                setAccessibilityFocus(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Adding window failed&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (restore) &#123;<br>                    attrs.restore();<br>                &#125;<br>            &#125;<br>          <br>            ···<br>              <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>可以看到方法中调用了requestLayout方法，而我们知道requestLayout方法最终会调用scheduleTraversals方法来发起整个View树的测量、布局与绘制工作。</p>
<p>View的绘制流程不是本文的重点，但这里我们获得了一个关键信息，就是Activity的Window显示过程，包括View树的绘制过程都是在Activity的<code>ON_RESUME</code>阶段来完成。</p>
<p>另外，调用了WindowSession中的addToDisplay方法，将Window与<strong>WindowManagerService</strong>绑定。</p>
<p>这就是为什么我们在onCreate、onStart和onResume中都无法同步到获取View的宽高。</p>
<h2 id="Pause阶段"><a href="#Pause阶段" class="headerlink" title="Pause阶段"></a>Pause阶段</h2><p>继续来看Pause阶段，根据经验我们直接来到ActivityThread中的handlePauseActivity方法。</p>
<h3 id="ActivityThread-handlePauseActivity"><a href="#ActivityThread-handlePauseActivity" class="headerlink" title="ActivityThread#handlePauseActivity"></a>ActivityThread#handlePauseActivity</h3><p>handlePauseActivity方法表示自此Pause事件是由于用户导致，例如按下back键、home键、点击跳转Activity等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlePauseActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finished, <span class="hljs-keyword">boolean</span> userLeaving,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (userLeaving) &#123;<br>            performUserLeavingActivity(r);<br>        &#125;<br><br>        r.activity.mConfigChangeFlags |= configChanges;<br>        performPauseActivity(r, finished, reason, pendingActions);<br><br>        <span class="hljs-comment">// Make sure any pending writes are now committed.</span><br>        <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;<br>            QueuedWork.waitToFinish();<br>        &#125;<br>        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>performUserLeavingActivity中将会调用Activity中的<strong>onUserInteraction</strong>和<strong>onUserLeaveHint</strong>方法。</p>
<h3 id="ActivityThread-performPauseActivity"><a href="#ActivityThread-performPauseActivity" class="headerlink" title="ActivityThread#performPauseActivity"></a>ActivityThread#performPauseActivity</h3><p>performPauseActivity方法中是会调用Activity的生命周期回调onPause方法，除了onPause方法，还有一些关键的方法也会在这里调用，例如onSaveInstanceState方法，来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Bundle <span class="hljs-title">performPauseActivity</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> finished, String reason,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions)</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// targetSDK &lt; 11的App在pause前就会调用onSaveInstanceState</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();<br>    <span class="hljs-keyword">if</span> (shouldSaveState) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br><br>  	<span class="hljs-comment">// 回调生命周期方法 onPause</span><br>    performPauseActivityIfNeeded(r, reason);<br><br>    ···<br>      <br>    <span class="hljs-keyword">return</span> shouldSaveState ? r.state : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="ActivityThread-performPauseActivityIfNeeded"><a href="#ActivityThread-performPauseActivityIfNeeded" class="headerlink" title="ActivityThread#performPauseActivityIfNeeded"></a>ActivityThread#performPauseActivityIfNeeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performPauseActivityIfNeeded</span><span class="hljs-params">(ActivityClientRecord r, String reason)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">try</span> &#123;<br>        r.activity.mCalled = <span class="hljs-keyword">false</span>;<br>      <br>      	<span class="hljs-comment">// 回调onPause</span><br>        mInstrumentation.callActivityOnPause(r.activity);<br>        <br>        ···<br>    &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to pause activity &quot;</span><br>                    + safeToComponentShortString(r.intent) + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置Lifecycle</span><br>    r.setState(ON_PAUSE);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Activity-performPause"><a href="#Activity-performPause" class="headerlink" title="Activity#performPause"></a>Activity#performPause</h3><p>此方法与之前生命周期的工作类似，主要就是分发prePause、onPause和postPause事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分发prePause</span><br>    dispatchActivityPrePaused();<br>    mDoReportFullyDrawn = <span class="hljs-keyword">false</span>;<br>    mFragments.dispatchPause();<br>    mCalled = <span class="hljs-keyword">false</span>;<br>  <br>    <span class="hljs-comment">// 回调生命周期方法</span><br>    onPause();<br>  <br>    mResumed = <span class="hljs-keyword">false</span>;<br><br>  	···<br>     <br>    <span class="hljs-comment">// 分发postPause</span><br>    dispatchActivityPostPaused();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Activity-onPause"><a href="#Activity-onPause" class="headerlink" title="Activity#onPause"></a>Activity#onPause</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分发pause</span><br>    dispatchActivityPaused();<br>  <br>    <span class="hljs-comment">// 是否需要自动填充</span><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        <span class="hljs-keyword">if</span> (!mAutoFillIgnoreFirstResumePause) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;autofill notifyViewExited &quot;</span> + <span class="hljs-keyword">this</span>);<br>            View focus = getCurrentFocus();<br>            <span class="hljs-keyword">if</span> (focus != <span class="hljs-keyword">null</span> &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;<br>                getAutofillManager().notifyViewExited(focus);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// reset after first pause()</span><br>            <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;autofill got first pause &quot;</span> + <span class="hljs-keyword">this</span>);<br>            mAutoFillIgnoreFirstResumePause = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE);<br>    mCalled = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Stop阶段"><a href="#Stop阶段" class="headerlink" title="Stop阶段"></a>Stop阶段</h2><p>同样的，Stop阶段与前面的生命周期方法调用链是类似的。</p>
<h3 id="ActivityThread-handleStopActivity"><a href="#ActivityThread-handleStopActivity" class="headerlink" title="ActivityThread#handleStopActivity"></a>ActivityThread#handleStopActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStopActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ActivityClientRecord r = mActivities.get(token);<br>    r.activity.mConfigChangeFlags |= configChanges;<br><br>    <span class="hljs-keyword">final</span> StopInfo stopInfo = <span class="hljs-keyword">new</span> StopInfo();<br>    performStopActivityInner(r, stopInfo, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, finalStateRequest,<br>            reason);<br><br>    <span class="hljs-comment">// 更新Activity的显隐状态</span><br>    updateVisibility(r, <span class="hljs-keyword">false</span>);<br><br>    ···<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>handleStopActivity</code>方法调用了<code>performStopActivityInner</code>来处理Activity的Stop状态，并且在Stop之后隐藏了Activity的DecorView的显示。</p>
<h3 id="ActivityThread-performStopActivityInner"><a href="#ActivityThread-performStopActivityInner" class="headerlink" title="ActivityThread#performStopActivityInner"></a>ActivityThread#performStopActivityInner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStopActivityInner</span><span class="hljs-params">(ActivityClientRecord r, StopInfo info, <span class="hljs-keyword">boolean</span> keepShown,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> saveState, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>  <br>    ···<br><br>        <span class="hljs-comment">// 保证Activity是处于Pause状态</span><br>        performPauseActivityIfNeeded(r, reason);<br><br>        ···<br><br>        <span class="hljs-keyword">if</span> (!keepShown) &#123;<br>            <span class="hljs-comment">// 回调Activiy的onStop方法</span><br>            callActivityOnStop(r, saveState, reason);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>performPauseActivityIfNeeded</code>中上一节已经有调用过，是为了确保Activity调用了onPause，如果已经处于pause状态将会直接返回。</p>
<p>来看一下<code>callActivityOnStop</code>方法。</p>
<h3 id="ActivityThread-callActivityOnStop"><a href="#ActivityThread-callActivityOnStop" class="headerlink" title="ActivityThread#callActivityOnStop"></a>ActivityThread#callActivityOnStop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnStop</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> saveState, String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// 在Android Honeycomb（11）之前，onSaveInstanceState都是在onPause之前执行</span><br>    <span class="hljs-comment">// 在Android P（28）之前，onSaveInstanceState在onStop方法执行之前执行</span><br>    <span class="hljs-comment">// 在Android P之后（包含），onSaveInstanceState在onStop方法执行之后执行 </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="hljs-keyword">null</span><br>            &amp;&amp; !r.isPreHoneycomb();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPreP = r.isPreP();<br>    <span class="hljs-keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用onStop</span><br>        r.activity.performStop(r.mPreserveWindow, reason);<br>    &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">&quot;Unable to stop activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    r.setState(ON_STOP);<br><br>    <span class="hljs-keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;<br>        <span class="hljs-comment">// 调用onSaveInstanceState</span><br>        callActivityOnSaveInstanceState(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里有个关键信息，就是<code>onSaveInstanceState</code>方法的调用时机。</p>
<p>之前在分析Pause阶段时，我们知道在<strong>Android</strong> <strong>Honeycomb</strong>以前<code>onSaveInstanceState</code>会在onPause方法调用之前回调，而在<code>callActivityOnStop</code>中进一步对<code>onSaveInstanceState</code>的调用时机做出了解释，总结如下：</p>
<ol>
<li>在Android Honeycomb之前，onSaveInstanceState在onPause调用之前被调用</li>
<li>在Android Honeycomb之后，Android P之前，onSaveInstanceState在onStop调用之前被调用</li>
<li>在Android P之后，onSaveInstanceState在onStop调用之后被调用</li>
</ol>
<p>performStop方法中会回调生命周期onStop方法，来看看。</p>
<h3 id="Activity-performStop"><a href="#Activity-performStop" class="headerlink" title="Activity#performStop"></a>Activity#performStop</h3><p>此方法中同样会进行preStop、stop和postStop的事件分发，并且使用Instrumentation来回调onStop方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performStop</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> preserveWindow, String reason)</span> </span>&#123;<br>    <br>  	···<br>  <br>    <span class="hljs-keyword">if</span> (!mStopped) &#123;<br>        <br>        ···<br>          <br>        dispatchActivityPreStopped();<br>        <span class="hljs-keyword">if</span> (mWindow != <span class="hljs-keyword">null</span>) &#123;<br>            mWindow.closeAllPanels();<br>        &#125;<br>      <br>        ···<br>          <br>        mFragments.dispatchStop();<br><br>        mCalled = <span class="hljs-keyword">false</span>;<br>        mInstrumentation.callActivityOnStop(<span class="hljs-keyword">this</span>);<br><br>        ···<br>        <br>        mStopped = <span class="hljs-keyword">true</span>;<br>        dispatchActivityPostStopped();<br>    &#125;<br>    mResumed = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Activity-onStop"><a href="#Activity-onStop" class="headerlink" title="Activity#onStop"></a>Activity#onStop</h3><p>onStop方法中需要停止UI的刷新，停止运行中的动画，以及隐藏自动填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallSuper</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mActionBar != <span class="hljs-keyword">null</span>) mActionBar.setShowHideAnimationEnabled(<span class="hljs-keyword">false</span>);<br>    mActivityTransitionState.onStop();<br>    dispatchActivityStopped();<br>    mTranslucentCallback = <span class="hljs-keyword">null</span>;<br>    mCalled = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        getAutofillManager().onInvisibleForAutofill();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isFinishing()) &#123;<br>        <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>            getAutofillManager().onActivityFinishing();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mIntent != <span class="hljs-keyword">null</span><br>                &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123;<br>            getAutofillManager().onPendingSaveUi(AutofillManager.PENDING_UI_OPERATION_CANCEL,<br>                    mIntent.getIBinderExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN));<br>        &#125;<br>    &#125;<br>    mEnterAnimationComplete = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Destroy阶段"><a href="#Destroy阶段" class="headerlink" title="Destroy阶段"></a>Destroy阶段</h2><p>Destroy阶段App除了要完成Activity本身的销毁逻辑外，还需要通知System Server来处理Activity栈相关的逻辑。</p>
<p>按照经验，我们来到ActivityThread的handleDestroyActivity方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>  <br>    <span class="hljs-comment">// 销毁Activity</span><br>    ActivityClientRecord r = performDestroyActivity(token, finishing,<br>            configChanges, getNonConfigInstance, reason);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 处理Window相关</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通知ATMS此Activity已经被销毁</span><br>            ActivityTaskManager.getService().activityDestroyed(token);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>            <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此方法首先调用了<code>performDestroyActivity</code>执行了本地的销毁逻辑，然后通知ATMS更新系统服务。</p>
<h3 id="ActivityThread-performDestroyActivity"><a href="#ActivityThread-performDestroyActivity" class="headerlink" title="ActivityThread#performDestroyActivity"></a>ActivityThread#performDestroyActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    Class&lt;? extends Activity&gt; activityClass = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Performing finish of &quot;</span> + r);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        activityClass = r.activity.getClass();<br>        r.activity.mConfigChangeFlags |= configChanges;<br>        <span class="hljs-keyword">if</span> (finishing) &#123;<br>            r.activity.mFinished = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 保证Activity调用了onPause</span><br>        performPauseActivityIfNeeded(r, <span class="hljs-string">&quot;destroy&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>            <span class="hljs-comment">// 保证Activity调用了onStop</span><br>            callActivityOnStop(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* saveState */</span>, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        &#125;<br>      <br>        ···<br>          <br>        <span class="hljs-keyword">try</span> &#123;<br>            r.activity.mCalled = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 调用onDestroy生命周期方法</span><br>            mInstrumentation.callActivityOnDestroy(r.activity);<br><br>            <span class="hljs-comment">// 关闭所有window</span><br>            <span class="hljs-keyword">if</span> (r.window != <span class="hljs-keyword">null</span>) &#123;<br>                r.window.closeAllPanels();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ···<br>            &#125;<br>        &#125;<br>        r.setState(ON_DESTROY);<br>    &#125;<br>    schedulePurgeIdler();<br><br>    <span class="hljs-comment">// 删除本地Activity对应数据结构</span><br>    <span class="hljs-keyword">synchronized</span> (mResourcesManager) &#123;<br>        mActivities.remove(token);<br>    &#125;<br>    StrictMode.decrementExpectedActivityCount(activityClass);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Instrumentation.callActivityOnDestroy回调用Activity的performDestroy方法，与之前的生命周期类似，performDestroy方法主要是分发preDestroy、destroy和postDestroy事件，并且会调用onDestroy生命周期回调。</p>
<p>主要来看看onDestroy方法做了什么。</p>
<h3 id="Activity-onDestroy"><a href="#Activity-onDestroy" class="headerlink" title="Activity#onDestroy"></a>Activity#onDestroy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    mCalled = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 关闭所有的dialog</span><br>    <span class="hljs-comment">// 使用Activity.showDialog显示的Dialog都会存入到mManagedDialogs中</span><br>    <span class="hljs-keyword">if</span> (mManagedDialogs != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numDialogs = mManagedDialogs.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numDialogs; i++) &#123;<br>            <span class="hljs-keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);<br>            <span class="hljs-keyword">if</span> (md.mDialog.isShowing()) &#123;<br>                md.mDialog.dismiss();<br>            &#125;<br>        &#125;<br>        mManagedDialogs = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有的游标</span><br>    <span class="hljs-comment">// 使用startManagingCursor可以让Activity自动管理此游标避免泄漏</span><br>    <span class="hljs-keyword">synchronized</span> (mManagedCursors) &#123;<br>        <span class="hljs-keyword">int</span> numCursors = mManagedCursors.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCursors; i++) &#123;<br>            ManagedCursor c = mManagedCursors.get(i);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>                c.mCursor.close();<br>            &#125;<br>        &#125;<br>        mManagedCursors.clear();<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭所有的SearchDialog</span><br>    <span class="hljs-keyword">if</span> (mSearchManager != <span class="hljs-keyword">null</span>) &#123;<br>        mSearchManager.stopSearch();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mActionBar != <span class="hljs-keyword">null</span>) &#123;<br>        mActionBar.onDestroy();<br>    &#125;<br><br>    <span class="hljs-comment">// 分发Destroy事件</span><br>    dispatchActivityDestroyed();<br><br>    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>onDestroy方法中主要是保证Activity销毁时已经关闭了所有的由此Activity管理的Dialog、Cursor和SearchDialog，可以避免一些内存泄漏。</p>
<h2 id="非生命周期关键方法分析"><a href="#非生命周期关键方法分析" class="headerlink" title="非生命周期关键方法分析"></a>非生命周期关键方法分析</h2><p>上面分析完了Activity的生命周期的相关源码， 我们平时开发中除了与Activity生命周期回调方法打交道之外，通常还会涉及到少数非生命周期方法，例如<strong>onSaveInstanceState/onRestoreInstanceState</strong>、<strong>onRetainNonConfigurationInstance</strong>等，下面就来分析一下这几个函数的原理。</p>
<h3 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h3><p>saveInstanceState中文翻译叫<strong>保存实例状态</strong>，它允许我们在Activity暂停或不可见时保存一些数据，然后通过onRestoreInstanceState来恢复这些数据，<strong>并且即使App被杀死，我们依然可以在onCreate方法中获取到保存的数据</strong>，这是如何做到的呢？</p>
<p>在上文的Stop阶段已经提到了<code>onSaveInstanceState</code>方法在<code>callActivityOnSaveInstanceState</code>中调用，并且对于不同的API版本调用时机是有区别的：</p>
<ol>
<li>在Android Honeycomb（11）之前，callActivityOnSaveInstanceState在<strong>onPause</strong>调用<strong>之前</strong>被调用</li>
<li>在Android Honeycomb（11）之后，Android P之前，callActivityOnSaveInstanceState在<strong>onStop</strong>调用<strong>之前</strong>被调用</li>
<li>在Android P之后，callActivityOnSaveInstanceState在<strong>onStop</strong>调用<strong>之后</strong>被调用</li>
</ol>
<p>下面来跟踪一下在Android Q中<code>callActivityOnSaveInstanceState</code>的调用流程。</p>
<h4 id="ActivityThread-callActivityOnSaveInstanceState"><a href="#ActivityThread-callActivityOnSaveInstanceState" class="headerlink" title="ActivityThread#callActivityOnSaveInstanceState"></a>ActivityThread#callActivityOnSaveInstanceState</h4><p><code>callActivityOnSaveInstanceState</code>方法定义在ActivityThread里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnSaveInstanceState</span><span class="hljs-params">(ActivityClientRecord r)</span> </span>&#123;<br>    r.state = <span class="hljs-keyword">new</span> Bundle();<br>    r.state.setAllowFds(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">// 是否设置了persistableMode为ActivityInfo.PERSIST_ACROSS_REBOOTS</span><br>    <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>        r.persistentState = <span class="hljs-keyword">new</span> PersistableBundle();<br>        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,<br>                r.persistentState);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到这里新建了一个Bundle对象，并且赋值给了<strong>ActivityClientRecord</strong>的state属性，接着调用了Instrumentation中的<code>callActivityOnSaveInstanceState</code>方法。</p>
<p><code>Instrumentation.callActivityOnSaveInstanceState</code>将会直接调用activity的<code>performSaveInstanceState</code>方法，我们直接来到Activity中。</p>
<h4 id="Activity-performSaveInstanceState"><a href="#Activity-performSaveInstanceState" class="headerlink" title="Activity#performSaveInstanceState"></a>Activity#performSaveInstanceState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState)</span> </span>&#123;<br>    dispatchActivityPreSaveInstanceState(outState);<br>    onSaveInstanceState(outState);<br>    <span class="hljs-comment">// 调用此Activity管理的Dialog的onSaveInstanceState方法</span><br>    saveManagedDialogs(outState);<br>    mActivityTransitionState.saveState(outState);<br>    storeHasCurrentPermissionRequest(outState);<br>    <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">&quot;onSaveInstanceState &quot;</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;: &quot;</span> + outState);<br>    dispatchActivityPostSaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到<code>onSaveInstanceState</code>是在这里被调用的，重点也是这个方法。除此之外这里调用了<code>saveManagedDialogs</code>来调用此Activity管理的所有Dialog的<code>onSaveInstanceState</code>来保存数据。</p>
<p>继续来看<code>onSaveInstanceState</code>方法。</p>
<h4 id="Activity-onSaveInstanceState"><a href="#Activity-onSaveInstanceState" class="headerlink" title="Activity#onSaveInstanceState"></a>Activity#onSaveInstanceState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState)</span> </span>&#123;<br>    <span class="hljs-comment">// 存储视图状态</span><br>    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());<br><br>    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);<br>    <span class="hljs-comment">// 存储Fragment信息</span><br>    Parcelable p = mFragments.saveAllState();<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>        outState.putParcelable(FRAGMENTS_TAG, p);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mAutoFillResetNeeded) &#123;<br>        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="hljs-keyword">true</span>);<br>        getAutofillManager().onSaveInstanceState(outState);<br>    &#125;<br>    dispatchActivitySaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此方法中调用了Window中的<code>saveHierarchyState</code>来保存所有视图的状态，另外调用了FragmentController的<code>saveAllState</code>方法来保存所有活动的Fragment信息。</p>
<p>分析一下这两个方法。</p>
<h4 id="PhoneWindow-saveHierarchyState"><a href="#PhoneWindow-saveHierarchyState" class="headerlink" title="PhoneWindow#saveHierarchyState"></a>PhoneWindow#saveHierarchyState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Bundle <span class="hljs-title">saveHierarchyState</span><span class="hljs-params">()</span> </span>&#123;<br>    Bundle outState = <span class="hljs-keyword">new</span> Bundle();<br>  <br>    <span class="hljs-comment">// 如果没有调用setContentView，无需保存状态</span><br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> outState;<br>    &#125;<br><br>    SparseArray&lt;Parcelable&gt; states = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>    <span class="hljs-comment">// 调用ContentView的saveHierarchyState方法</span><br>    <span class="hljs-comment">// 会将onSaveInstanceState的调用分发给所有View</span><br>    mContentParent.saveHierarchyState(states);<br>    outState.putSparseParcelableArray(VIEWS_TAG, states);<br><br>    <span class="hljs-comment">// 保存当前FocusView的ID</span><br>    <span class="hljs-keyword">final</span> View focusedView = mContentParent.findFocus();<br>    <span class="hljs-keyword">if</span> (focusedView != <span class="hljs-keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;<br>        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());<br>    &#125;<br><br>    <span class="hljs-comment">// 保存所有Panel的状态</span><br>    SparseArray&lt;Parcelable&gt; panelStates = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>    savePanelState(panelStates);<br>    <span class="hljs-keyword">if</span> (panelStates.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        outState.putSparseParcelableArray(PANELS_TAG, panelStates);<br>    &#125;<br><br>    <span class="hljs-comment">// 保存ActionBar的状态</span><br>    <span class="hljs-keyword">if</span> (mDecorContentParent != <span class="hljs-keyword">null</span>) &#123;<br>        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="hljs-keyword">new</span> SparseArray&lt;Parcelable&gt;();<br>        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);<br>        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> outState;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 此方法中会保存所有此Activity中的视图信息，包括actionBar。另外View的onSaveInstanceState也会在这里被递归的调用。</p>
<h4 id="FragmentController-saveAllState"><a href="#FragmentController-saveAllState" class="headerlink" title="FragmentController#saveAllState"></a>FragmentController#saveAllState</h4><p>此方法将saveState事件传递给FragmentManager。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Parcelable <span class="hljs-title">saveAllState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mHost.mFragmentManager.saveAllState();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="FragmentManager-saveAllState"><a href="#FragmentManager-saveAllState" class="headerlink" title="FragmentManager#saveAllState"></a>FragmentManager#saveAllState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Parcelable <span class="hljs-title">saveAllState</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    ···<br><br>    <span class="hljs-comment">// 收集所有当前处于活动状态的Fragment的FragmentState</span><br>    <span class="hljs-comment">// 会调用Fragment的onSaveInstanceState方法</span><br>    <span class="hljs-comment">// 同时也会保存绑定的View的视图信息</span><br>    ArrayList&lt;FragmentState&gt; active = mFragmentStore.saveActiveFragments();<br><br>    <span class="hljs-keyword">if</span> (active.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class="hljs-string">&quot;saveAllState: no fragments!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 收集所有添加过的Fragment的FragmentState</span><br>    <span class="hljs-comment">// 会调用Fragment的onSaveInstanceState方法</span><br>    <span class="hljs-comment">// 同时也会保存绑定的View的视图信息</span><br>    ArrayList&lt;String&gt; added = mFragmentStore.saveAddedFragments();<br><br>    <span class="hljs-comment">// 收集回退栈信息</span><br>    BackStackState[] backStack = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (mBackStack != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> size = mBackStack.size();<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            backStack = <span class="hljs-keyword">new</span> BackStackState[size];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                backStack[i] = <span class="hljs-keyword">new</span> BackStackState(mBackStack.get(i));<br>                <span class="hljs-keyword">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;<br>                    Log.v(TAG, <span class="hljs-string">&quot;saveAllState: adding back stack #&quot;</span> + i<br>                            + <span class="hljs-string">&quot;: &quot;</span> + mBackStack.get(i));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将收集到的信息封装成FragmentManagerState对象，它是个Parcelable</span><br>    FragmentManagerState fms = <span class="hljs-keyword">new</span> FragmentManagerState();<br>    fms.mActive = active;<br>    fms.mAdded = added;<br>    fms.mBackStack = backStack;<br>    fms.mBackStackIndex = mBackStackIndex.get();<br>    <span class="hljs-keyword">if</span> (mPrimaryNav != <span class="hljs-keyword">null</span>) &#123;<br>        fms.mPrimaryNavActiveWho = mPrimaryNav.mWho;<br>    &#125;<br>    fms.mResultKeys.addAll(mResults.keySet());<br>    fms.mResults.addAll(mResults.values());<br>    fms.mLaunchedFragments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(mLaunchedFragments);<br>    <span class="hljs-keyword">return</span> fms;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到此方法主要做三件事：</p>
<ol>
<li>收集所有当前处于活动状态的FragmentState</li>
<li>收集所有添加过的FragmentState</li>
<li>收集当前回退栈信息</li>
<li>将所有信息封装成FragmentManagerState对象并返回</li>
</ol>
<p>到这里整个<code>callActivityOnSaveInstanceState</code>过程是如何收集需要保存的数据的已经分析完毕了。</p>
<p>前面说了，保存的数据会放到<strong>ActivityClientRecord</strong>的state对象里，根据前面的文章我们知道ActivityClientRecord仅仅是本地App中表示Activity的数据结构，而SaveInstanceState可以做到App被杀死后也能恢复数据，这说明数据并不单单是存储在本地App进程中，否则无法做到这一点。</p>
<p>不过在整个<code>callActivityOnSaveInstanceState</code>的调用过程中我们无法找到有<strong>持久化</strong>或者<strong>IPC调用</strong>任何操作，因此需要在<code>callActivityOnSaveInstanceState</code>调用后的代码中寻找。</p>
<p>最终在<strong>ActivityThread#performStopActivityInner</strong>找到关联的代码。</p>
<h4 id="ActivityThread-performStopActivityInner-1"><a href="#ActivityThread-performStopActivityInner-1" class="headerlink" title="ActivityThread#performStopActivityInner"></a>ActivityThread#performStopActivityInner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStopActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;<br>  <br>    ···<br>      <br>    <span class="hljs-keyword">final</span> StopInfo stopInfo = <span class="hljs-keyword">new</span> StopInfo();<br>    performStopActivityInner(r, stopInfo, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, finalStateRequest,<br>            reason);<br>  <br>    ··· <br>    <br>    stopInfo.setActivity(r);<br>    <span class="hljs-comment">// 将保存的数据设置到了StopInfo中</span><br>    stopInfo.setState(r.state);<br>    stopInfo.setPersistentState(r.persistentState);<br>    pendingActions.setStopInfo(stopInfo);<br>    mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里<strong>StopInfo</strong>它是一个Runnable，而我们收集到的数据state将会传递给它，然后将它设置给了<strong>PendingTransactionActions</strong>。既然是一个Runnable，那么它一定会在某个时间被调用，我们只需要关注其<code>run</code>方法即可。</p>
<h4 id="StopInfo-run"><a href="#StopInfo-run" class="headerlink" title="StopInfo#run"></a>StopInfo#run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通知ATMS此Activity已经Stopped</span><br>    ···<br>    ActivityTaskManager.getService().activityStopped(<br>                mActivity.token, mState, mPersistentState, mDescription);<br>    ···<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此方法中通过调用<strong>ATMS</strong>的<code>activityStopped</code>方法来通知ATMS此Activity已经Stopped，并将mState属性传递给了方法。</p>
<p>由于篇幅限制，这里不再深入到ATMS中，实际上最终mState将会赋值给<strong>ActivityRecord</strong>的<strong>icicle</strong>属性中，它也是一个Bundle对象。</p>
<p>到这里我们已经可以得出结论：<strong>由<code>onSaveInstanceState</code>方法保存的数据将会通过IPC传递到SystemServer的ATMS中</strong>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上述分析，我们知道了一下几点：</p>
<ul>
<li>onSaveInstanceState方法将会在每次Activity onStop之前或者之后回调（不考虑Android 3.0以下的情况），在Android 9之前是onStop之前，Android 9之后是onStop之后。也就是说，只要Activity不可见了，就会回调onSaveInstanceState方法。</li>
<li>在调用onSaveInstanceState时，会保存由当前绑定的Window来完成整个View树的状态保存，由FragmentManager来完成对Activity绑定的所有Fragment的状态保存。</li>
<li>所有状态信息将会被存放到Bundle对象中，并且最终通过IPC传递给ATMS管理的ActivityRecord对象的icicle属性，因此是属于远端存储，这也是onSaveInstance只支持序列化数据的原因。</li>
</ul>
<h3 id="onRestoreInstanceState"><a href="#onRestoreInstanceState" class="headerlink" title="onRestoreInstanceState"></a>onRestoreInstanceState</h3><p>缓存的数据会在Create阶段传入，另外Activity Start时候也会调用<code>onRestoreInstanceState</code>方法来恢复数据。</p>
<h3 id="retainNonConfigurationInstances"><a href="#retainNonConfigurationInstances" class="headerlink" title="retainNonConfigurationInstances"></a>retainNonConfigurationInstances</h3><p>如果读者用过ViewModel，会发现在Activity发生了Configuration改变导致的重建时，我们在Activity中（以此Activity为<strong>ViewModelStoreOwner</strong>）创建的ViewModel对象并不会发生改变。</p>
<p>如果查找过它的源码的话，实际上它是利用的Activity的<code>retainNonConfigurationInstances</code>方法来保存了一些<strong>非配置实例</strong>，其中包括由此Activity构建的ViewModel的存储类<strong>ViewModelStore</strong>。</p>
<p>该方法声明在Activity.java类中，来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">NonConfigurationInstances <span class="hljs-title">retainNonConfigurationInstances</span><span class="hljs-params">()</span> </span>&#123;<br>    Object activity = onRetainNonConfigurationInstance();<br>    HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances();<br>    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();<br>  <br>    ····<br><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.activity = activity;<br>    nci.children = children;<br>    nci.fragments = fragments;<br>    nci.loaders = loaders;<br>    <span class="hljs-keyword">if</span> (mVoiceInteractor != <span class="hljs-keyword">null</span>) &#123;<br>        mVoiceInteractor.retainInstance();<br>        nci.voiceInteractor = mVoiceInteractor;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nci;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到此方法中调用了三个关键方法来获取所有需要保存的非配置实例，并且封装成NonConfigurationInstances对象，三个方法分辨是：</p>
<ol>
<li><strong>onRetainNonConfigurationInstance</strong>：获取此Activity需要保存的非配置实例</li>
<li><strong>onRetainNonConfigurationChildInstances</strong>：获取子Activity需要保存的非配置实例</li>
<li><strong>FragmentController#retainNestedNonConfig</strong>：获取此Activity管理的所有Fragment需要保存的非配置实例</li>
</ol>
<p>其中Fragment的非配置实例保存已经被废弃了，由于ComponentActivity在配置变更时会保存ViewModel实例，所以Fragment也采用了ViewModel来保存它的非配置实例，由于篇幅有限这里不再深入。</p>
<p>我们重点来看<code>onRetainNonConfigurationInstance</code>方法，在Activity中是空实现，来看ComponentActivity的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">onRetainNonConfigurationInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 此方法被final修饰了，所以额外提供一个onRetainCustomNonConfigurationInstance方法给开发者使用</span><br>    Object custom = onRetainCustomNonConfigurationInstance();<br><br>    ViewModelStore viewModelStore = mViewModelStore;<br>  <br>    <span class="hljs-comment">// getViewModelStore未被调用</span><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 此时要考虑我们的ViewModel是不是是在上个NonConfigurationInstances对象中取出来的</span><br>        NonConfigurationInstances nc =<br>                (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span>) &#123;<br>            viewModelStore = nc.viewModelStore;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (viewModelStore == <span class="hljs-keyword">null</span> &amp;&amp; custom == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.custom = custom;<br>    nci.viewModelStore = viewModelStore;<br>    <span class="hljs-keyword">return</span> nci;<br></code></pre></td></tr></table></figure>
<p>此方法将创建的<strong>ViewModelStore</strong>对象保存到了<strong>NonConfigurationInstances</strong>实例中，可以看到ComponentActivity并不是直接保存所有的ViewModel，而是保存ViewModelStore，这样一次性就保存了所有从此ViewModelStoreOwner创建出来的ViewModel对象。</p>
<p>系统不希望我们继承这个方法，所以这里使用了final来修饰此方法，额外提供了一个<code>onRetainCustomNonConfigurationInstance</code>来允许开发者保存自己的非配置实例数据。</p>
<p>不过在有了ViewModel之后就不再需要利用此方法了，数据完全可以丢到ViewModel里。</p>
<p>到这里我们已经清楚了ViewModel对象是如何保存的，但是<code>retainNonConfigurationInstances</code>时机我们还不清楚。全局搜索一下，发现<code>retainNonConfigurationInstances</code>只有一次调用点，就是在ActivityThread的<code>performDestroyActivity</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>  <br>        ActivityClientRecord r = mActivities.get(token);<br>  <br>        ···<br>      <br>        <span class="hljs-comment">// 在relaunch时，getNonConfigInstance为true</span><br>        <span class="hljs-keyword">if</span> (getNonConfigInstance) &#123;<br>            <span class="hljs-keyword">try</span> &#123; <br><br>                r.lastNonConfigurationInstances<br>                        = r.activity.retainNonConfigurationInstances();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                            <span class="hljs-string">&quot;Unable to retain activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>    ···<br>      <br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>performDestroyActivity</code>我们已经有印象了，是在Activity的Destroy阶段会被调用，不过正常的Destroy流程中传入的<strong>getNonConfigInstance</strong>标志位为false，只有Activity Relaunch时才会为true。</p>
<p>方法中调用了Activity的<code>retainNonConfigurationInstances</code>方法并将结果赋值给了<strong>ActivityClientRecord</strong>中<strong>lastNonConfigurationInstances</strong>属性，与onSaveInstanceState不同的是，<code>retainNonConfigurationInstances</code>存储的数据允许为Object类型，因为它并不需要IPC，仅仅只存储到本地App进程。</p>
<p>因此我们可以得出结论：<strong>当App退出或者被系统杀死时，ViewModel是无法还原数据的，其只适用于Activity由于Configuration的改变导致的重建情况。</strong></p>
<p>最后来看一下这个lastNonConfigurationInstances如何重新交换给Activity，</p>
<p>在Activity的<code>attach</code>方法中有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>        r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>        r.embeddedID, r.lastNonConfigurationInstances, config,<br>        r.referrer, r.voiceInteractor, window, r.configCallback,<br>        r.assistToken);<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,</span></span><br><span class="hljs-function"><span class="hljs-params">        Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,</span></span><br><span class="hljs-function"><span class="hljs-params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="hljs-function"><span class="hljs-params">        CharSequence title, Activity parent, String id,</span></span><br><span class="hljs-function"><span class="hljs-params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;<br>  <br>    ···<br>    <br>    <span class="hljs-comment">// 将lastNonConfigurationInstances重新赋值给Activity</span><br>    mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>  <br>    ···<br>&#125;<br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android-Framework/">Android Framework</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/AOSP/">AOSP</a>
                    
                      <a class="hover-with-bg" href="/tags/Activity/">Activity</a>
                    
                      <a class="hover-with-bg" href="/tags/ViewModel/">ViewModel</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/30/8c057ce7/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android Framework（六）——ANR机制从产生到消费</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/05/7219b693/">
                        <span class="hidden-mobile">最佳实践 | 基于注解处理器实现视图绑定</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'sukaidev/sukaidev.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Powered by  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> , Theme  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>





  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
