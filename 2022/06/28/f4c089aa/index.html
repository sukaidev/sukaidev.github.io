

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Android Developer">
  <meta name="author" content="sukaidev">
  <meta name="keywords" content="Android sukaidev 苏海鸿">
  <title>Android性能优化（一）——卡顿优化 - Sukai&#39;s Blog - Android Developer</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.sukaidev.top","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sukai's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android性能优化（一）——卡顿优化">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-28 15:04" pubdate>
        2022年6月28日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      136
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android性能优化（一）——卡顿优化</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>本文转载自努比亚技术团队公众号。</p>
</blockquote>
<p>在分析任何问题之前，我们都需要先弄清楚其基本原理，也就是要掌握了这个“道”，才能真正着手去分析问题，否者只能是弄得一头雾水，也没法真正的理解和解决问题。所以要想分析并解决界面掉帧卡顿问题，我们就先需要知道在<code>Android</code>系统上应用<code>UI</code>线程到底是如何完成一帧画面的上帧显示动作的（本文讲解的内容主要基于<code>Android</code>原生应用的绘制渲染流程，对于游戏应用和<code>Flutter</code>开发的应用流程会不太一样，由于篇幅所限，本文暂不涉及，可以关注团队后续其它文章的内容）。由于大部分应用界面的上帧更新画面动作都是由用户手指触摸屏幕而触发，所以本文以手指上下滑动应用界面的操作场景为例，结合<code>Systrace</code>分析一下<code>Android</code>应用上帧显示的原理。</p>
<h2 id="1-Input事件处理机制"><a href="#1-Input事件处理机制" class="headerlink" title="1 Input事件处理机制"></a>1 Input事件处理机制</h2><h3 id="1-1-系统机制分析"><a href="#1-1-系统机制分析" class="headerlink" title="1.1 系统机制分析"></a>1.1 系统机制分析</h3><p><code>Android</code> 系统是由事件驱动的，而 <code>Input</code> 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 <code>Input</code> 事件驱动，其中的核心就是 <code>InputReader</code> 和 <code>InputDispatcher</code>。<code>InputReader</code> 和 <code>InputDispatcher</code> 是跑在 <code>system_server</code>进程中的两个 <code>Native</code>循环线程，负责读取和分发 <code>Input</code> 事件。整个处理过程大致流程如下：</p>
<ol>
<li>触摸屏会按照屏幕硬件的触控采样率周期，每隔几毫秒扫描一次，如果有触控事件就会上报到对应的设备驱动；系统封装了一个叫<code>EventHub</code>的对象，它利用<code>inotify</code>和<code>epoll</code>机制监听<code>/dev/input</code>目录下的<code>input</code>设备驱动节点，通过<code>EventHub</code>的<code>getEvents</code>接口就可以监听并获取到<code>Input</code>事件；</li>
<li><code>InputReader</code>负责从<code>EventHub</code>里面把<code>Input</code>事件读取出来，然后交给 <code>InputDispatcher</code> 进行事件分发；</li>
<li><code>InputDispatcher</code>在拿到 <code>InputReader</code>获取的事件之后，对事件进行包装后，寻找并分发到目标窗口;</li>
<li><code>InboundQueue</code>队列（<code>“iq”</code>）中放着<code>InputDispatcher</code>从<code>InputReader</code>中拿到的<code>input</code>事件；</li>
<li><code>OutboundQueue</code>（<code>“oq”</code>）队列里面放的是即将要被派发给各个目标窗口<code>App</code>的事件；</li>
<li><code>WaitQueue</code>队列里面记录的是已经派发给 <code>App</code>（<code>“wq”</code>），但是 <code>App</code>还在处理没有返回处理成功的事件；</li>
<li><code>PendingInputEventQueue</code>队列（“aq”）中记录的是应用需要处理的<code>Input</code>事件，这里可以看到<code>input</code>事件已经传递到了应用进程；</li>
<li><code>deliverInputEvent</code> 标识 <code>App</code>  <code>UI Thread</code> 被 <code>Input</code> 事件唤醒；</li>
<li><code>InputResponse</code> 标识 <code>Input</code> 事件区域，这里可以看到一个 <code>Input_Down</code> 事件 + 若干个 <code>Input_Move</code> 事件 + 一个 <code>Input_Up</code> 事件的处理阶段都被算到了这里；</li>
<li><code>App</code> 响应处理<code>Input</code> 事件，内部会在其界面<code>View</code>树中逐层分发和处理。</li>
</ol>
<p>用一张图描述整个过程大致如下（关于这部分详细的<code>Android</code>系统源码实现流程可以参考<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://juejin.cn/post/6956500920108580878">这篇文章</a>）：</p>
<p><img src="/img/26874665-ab756e88f0bb89c2.webp" srcset="/img/loading.gif" alt="input模型"></p>
<h3 id="1-2-结合Systrace分析"><a href="#1-2-结合Systrace分析" class="headerlink" title="1.2 结合Systrace分析"></a>1.2 结合Systrace分析</h3><p>从上面的系统机制的分析可以看出，整个<code>Input</code>触控事件的分发与处理主要涉及到两个进程：一个是<code>system_server</code>系统进程，另一个是当前焦点窗口所属的<code>Setting</code>应用进程。</p>
<p><strong>一、<code>system_server</code>进程的处理过程：</strong></p>
<ol>
<li><p>当用户手指在<code>Setting</code>应用界面滑动时，系统<code>system_server</code>进程中的<code>native</code>线程<code>InputReader</code>会从<code>EventHub</code>中读取其利用<code>linux</code>的<code>epoll</code>机制监听到的屏幕驱动上报的<code>Input</code>触控事件，然后唤醒另外一条native线程<code>InputDispatcher</code>负责进行事件的进一步分发处理。</p>
</li>
<li><p><code>InputDispatcher</code>被唤醒后会先将事件放到<code>InboundQueue</code>队列（也就是<code>Systrace</code>上看到的“<code>iq”</code>队列）中，然后找到具体处理此<code>input</code>事件的应用目标窗口，并将<code>Input</code>事件放入对应的应用目标窗口的<code>OutboundQueue</code>队列（也就是<code>Systrace</code>上看到的<code>“oq”</code>队列）中，等待进一步通过<code>SocketPair</code>双工信道发送<code>input</code>事件到应用目标窗口中；</p>
</li>
<li><p>最后当事件发送给具体的应用目标窗口后，会将事件移动到<code>WaitQueue</code>队列中（也就是<code>Systrace</code>上看到的<code>“wq”</code>队列）并一直等待收到到目标应用处理<code>Input</code>事件完成后的反馈后再从队列中移除，<strong>如果5秒内没有收到目标应用窗口处理完成此次<code>Input</code>事件的反馈，就会报该应用ANR异常事件</strong>。以上整个过程在<code>Android</code>系统<code>AOSP</code>源码中都加有相应的<code>Systrace tag</code>，如下<code>Systrace</code>截图所示：</p>
<p><img src="/img/26874665-26d272761a9069fa.webp" srcset="/img/loading.gif" alt="input1"></p>
</li>
</ol>
<p><strong>二、应用进程的处理过程：</strong></p>
<p>当<code>Input</code>触控事件通过<code>socket</code>传递到<code>Settings</code>应用进程这边后，会唤醒应用的<code>UI</code>线程在<code>ViewRootImpl#deliverInputEvent</code>的流程中进行<code>Input</code>事件的具体分发与处理。具体的处理流程：</p>
<ol>
<li><p>先交给之前在添加应用<code>PhoneWindow</code>窗口时的<code>ViewRootImpl#setView</code>流程中创建的多个不同类型的<code>InputUsage</code>中依次进行处理（比如对输入法处理逻辑的封装<code>ImeInputUsage</code>，某些<code>key</code>类型的<code>Input</code>事件会由它先交给输入法进程处理完后再交给应用窗口的<code>InputUsage</code>处理），<strong>整个处理流程是按照责任链的设计模式进行</strong>；</p>
</li>
<li><p>最后会交给负责应用窗口<code>Input</code>事件分发处理的<code>ViewPostImeInputUsage</code>中具体处理，这里面会从<code>View</code>布局树的根节点<code>DecorView</code>开始遍历整个<code>View</code>树上的每一个子<code>View</code>或<code>ViewGroup</code>控件执行事件的分发、拦截、处理的逻辑；</p>
</li>
<li><p>最后触控事件处理完成后会调用<code>finishInputEvent</code>结束应用对触控事件处理逻辑，<strong>这里面会通过<code>JNI</code>调用到<code>native</code>层<code>InputConsumer</code>的<code>sendFinishedSignal</code>函数中通过socket消息通知系统框架中的<code>InputDispatcher</code>该<code>Input</code>事件处理完成</strong>，触发从<code>&quot;wq&quot;</code>队列中及时移除待处理事件以免报<code>ANR</code>异常。</p>
</li>
<li><p><strong>一次滑动过程的触控交互的<code>InputResponse</code>区域中一般会包含一个<code>Input</code>的<code>ACTION_DOWN</code>事件+多个<code>ACTION_MOVE</code>事件+一个<code>ACTION_UP</code>事件</strong>，<code>Settings</code>应用界面中的相关<code>View</code>控件在收到多个<code>ACTION_MOVE</code>触控事件后，经过判断为用户手指滑动行为，<strong>一般会调用<code>View#invalidate</code>等相关接口触发<code>UI</code>线程的绘制上帧更新画面的操作</strong>，具体流程后文会继续详细分析。以上过程如下<code>Systrace</code>截图所示：</p>
<p><img src="img/26874665-f7b8127610f84a36.webp" srcset="/img/loading.gif" alt="input2"></p>
</li>
</ol>
<h2 id="2-应用UI线程消息循环机制"><a href="#2-应用UI线程消息循环机制" class="headerlink" title="2 应用UI线程消息循环机制"></a>2 应用UI线程消息循环机制</h2><p><code>App</code>应用启动时，在<code>Fork</code>创建进程后会通过反射创建代表应用主线程的<code>ActivityThread</code>对象并执行其<code>main</code>函数，进行<code>UI</code>主线程的初始化工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     ...<br>     <span class="hljs-comment">// 1.创建Looper、MessageQueue</span><br>     Looper.prepareMainLooper();<br>     ...<br>     <span class="hljs-comment">// 2.启动loop消息循环，开始准备接收消息</span><br>     Looper.loop();<br>     ...<br>&#125;<br><br><span class="hljs-comment">// 3.创建主线程Handler对象</span><br><span class="hljs-keyword">final</span> H mH = <span class="hljs-keyword">new</span> H();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>  ...<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/core/java/android/os/Looper.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareMainLooper</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-comment">// 准备主线程的Looper</span><br>     prepare(<span class="hljs-keyword">false</span>);<br>     <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>          <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>          &#125;<br>          sMainLooper = myLooper();<br>     &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 创建主线程的Looper对象，并通过ThreadLocal机制实现与主线程的一对一绑定</span><br>      sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Looper</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>      <span class="hljs-comment">// 创建MessageQueue消息队列</span><br>      mQueue = <span class="hljs-keyword">new</span> MessageQueue(quitAllowed);<br>      mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主线程初始化完成后，<strong>主线程就有了完整的 <code>Looper</code>、<code>MessageQueue</code>、<code>Handler</code>，此时 <code>ActivityThread</code> 的 <code>Handler</code> 就可以开始处理 <code>Message</code>，包括 <code>Application</code>、<code>Activity</code>、<code>ContentProvider</code>、<code>Service</code>、<code>Broadcast</code> 等组件的生命周期函数，都会以 <code>Message</code> 的形式，在主线程按照顺序处理</strong>，这就是 <code>App</code> 主线程的初始化和运行原理，部分处理的 <code>Message</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/app/ActivityThread.java*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_APPLICATION        = <span class="hljs-number">110</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RECEIVER                = <span class="hljs-number">113</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CREATE_SERVICE          = <span class="hljs-number">114</span>;<br>        <span class="hljs-meta">@UnsupportedAppUsage</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_SERVICE            = <span class="hljs-number">121</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> BIND_APPLICATION:<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;bindApplication&quot;</span>);<br>                    AppBindData data = (AppBindData)msg.obj;<br>                    handleBindApplication(data);<br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>                    ...<br>            &#125;<br>         &#125;<br>         ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主线程初始化完成后，主线程就进入阻塞状态（进入<code>epoll_wait</code>状态，并释放<code>CPU</code>运行资源），等待 <code>Message</code>，一旦有 <code>Message</code> 发过来，主线程就会被唤醒，处理 <code>Message</code>，处理完成之后，如果没有其他的 <code>Message</code> 需要处理，那么主线程就会进入休眠阻塞状态继续等待。<strong>可以说<code>Android</code>系统的运行是受消息机制驱动的</strong>，而整个消息机制是由上面所说的四个关键角色相互配合实现的（<code>Handler</code>、<code>Looper</code><strong>、</strong><code>MessageQueue</code><strong>、</strong><code>Message</code>），其运行原理如下图所示：</p>
<p><img src="/img/26874665-1c9a83dc71d8d91a.webp" srcset="/img/loading.gif" alt="Android消息机制"></p>
<h2 id="3-Android屏幕刷新机制"><a href="#3-Android屏幕刷新机制" class="headerlink" title="3 Android屏幕刷新机制"></a>3 Android屏幕刷新机制</h2><h3 id="3-1-双缓存-Vsync"><a href="#3-1-双缓存-Vsync" class="headerlink" title="3.1 双缓存+Vsync"></a>3.1 双缓存+Vsync</h3><p>在一个典型的显示系统中，一般包括<code>CPU</code>、<code>GPU</code>、<code>Display</code>三个部分<strong>：<code>CPU</code>负责计算帧数据，把计算好的数据交给<code>GPU</code>，<code>GPU</code>会对图形数据进行渲染，渲染好后放到<code>buffer</code>(图像缓冲区)里存起来，然后<code>Display</code>（屏幕或显示器）负责把<code>Buffer</code>里的数据呈现到屏幕上</strong>。</p>
<p>屏幕上显示的内容，是从<code>Buffer</code>图像帧缓冲区中读取的，大致读取过程为：从<code>Buffer</code>的起始地址开始，从上往下，从左往右扫描整个<code>Buffer</code>，将内容映射到显示屏上。如下图所示：</p>
<p><img src="/img/26874665-1c01a8e3a68137d5.webp" srcset="/img/loading.gif" alt="显示系统1"></p>
<p>当然，屏幕上显示的内容需要不断的更新，如果在同一个<code>Buffer</code>进行读取和写入操作，将会导致屏幕显示多帧内容而出现显示错乱。所以硬件层除了提供一个<code>Buffer</code>用于屏幕显示，还会提供了一个<code>Buffer</code>用于后台的<code>CPU/GPU</code>图形绘制与合成，也就是我们常说的<strong>双缓冲</strong>：让绘制和显示器拥有各自的<code>Buffer：CPU/GPU</code> 始终将完成的一帧图像数据写入到 后缓存区（<code>Back Buffer</code>），而显示器使用前缓存区（ <code>Front Buffer</code>），当屏幕刷新时，<code>Front Buffer</code> 并不会发生变化，当<code>Back Buffer</code>准备就绪后，它们才进行交换。如下图所示：</p>
<p><img src="/img/26874665-f41a4955d482cfdc.webp" srcset="/img/loading.gif" alt="图形显示2"></p>
<p> 理想情况下假设前一帧显示完成，后一帧数据就准备好了，屏幕开始读取下一帧内容进行显示，也就是开始读取上图中的后缓冲区的内容：</p>
<p><img src="/img/26874665-4f3e2ff95b14368f.webp" srcset="/img/loading.gif" alt="图形显示3"></p>
<p> 此时，前后缓冲区进行一次角色交换，之前的后缓冲区变为前缓冲区，进行图形的显示，之前的前缓冲区则变为后缓冲区，进行图形的绘制合成。然而，理想很丰满，现实很骨感，上面假设“当前一帧显示完毕，后一帧准备好了”的情况，在现实中这两个事件并非同时完成。那么，屏幕读取缓冲区的速度和系统绘制合成帧的速度之间有什么关系呢，带着这个疑惑我们看看下面两个基本概念：</p>
<ol>
<li><strong>屏幕刷新率（<code>Screen Refresh Rate</code>）</strong>: 屏幕刷新率是一个硬件的概念，单位是<code>Hz</code>（赫兹），是说屏幕这个硬件刷新画面的频率：举例来说，<code>60Hz</code> 刷新率意思是：这个屏幕在 1 秒内，会刷新显示内容60 次；那么对应的，<code>90Hz</code> 是说在 1 秒内刷新显示内容 90 次。</li>
<li><strong>帧率（<code>Frame Rate</code>）</strong>: 与屏幕刷新率对应的，帧率是一个软件的概念，单位是<code>FPS</code>（<code>Frame Per Second</code> ），表示 <strong><code>CPU/GPU</code> 在一秒内绘制合成产生的帧数</strong>，意思是每秒产生画面的个数，<code>FPS</code> 的值是由软件系统决定的。举例来说，<code>60FPS</code> 指的是每秒产生 60 个画面；<code>90FPS</code> 指的是每秒产生 90 个画面。</li>
</ol>
<p>我们用以下两个假设来分析两者的关系：</p>
<ol>
<li><p>屏幕刷新率比系统帧率快：<br> 此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，造成一帧显示多次，也就是<strong>卡顿</strong>。</p>
</li>
<li><p>系统帧率比屏幕刷新率快：</p>
<p>此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，造成屏幕上显示多帧，也就是屏幕撕裂现象，如下图所示：</p>
<p><img src="/img/26874665-53bc711026d2e290.webp" srcset="/img/loading.gif" alt="画面撕裂"></p>
</li>
</ol>
<p>所以上面两种情况，都会导致问题，根本原因就是两个缓冲区的操作速率不一致。解决办法就是：<strong>让屏幕控制前后缓冲区的切换时机，让系统帧速率配合屏幕刷新率的节奏</strong>。那么屏幕是如何控制这个节奏的呢？</p>
<p>答案就是<strong>垂直同步（VSync）：</strong>当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，中间会有一个时间间隙，称为<code>Vetrical Blanking Interval (VBI)</code>，这个时间点其实就是进行前后缓存区交换的最佳时机，此时屏幕并没有在刷新，也就避免了屏幕撕裂现象的产生，所以在此时发出的一个同步<code>Vsync</code>信号，该信号用来切换前缓冲区和后缓冲区(本质就是内存地址的交换，瞬间即可完成)，即可达到最佳效果。</p>
<p>通过上面的分析可以看出：<strong>屏幕的显示节奏是由屏幕刷新率的硬件参数决定且固定的，软件操作系统需要配合屏幕的显示，在固定的时间内准备好下一帧，以供屏幕进行显示，两者通过<code>VSync</code>信号来实现同步</strong>（<code>VSync</code>这个概念并不是<code>Google</code>首创的，它在早年的<code>PC</code>机领域就已经出现了）。</p>
<h3 id="3-2-Drawing-with-Vsync"><a href="#3-2-Drawing-with-Vsync" class="headerlink" title="3.2 Drawing with Vsync"></a>3.2 Drawing with Vsync</h3><p>在<code>Android 4.1</code>之前，屏幕刷新也遵循上面介绍的 <strong>双缓存+<code>VSync</code></strong> 机制，整个流程与架构借用<code>2012</code>年<code>Google I/O</code>大会上展示的一张图如下所示：</p>
<p><img src="/img/26874665-7fa5328dcd02825b.webp" srcset="/img/loading.gif" alt="Drawing without Vsync"></p>
<p> 上图中：<br> 一、纵轴表示<code>Buffer</code>的使用者，由如下三个角色构成：</p>
<ol>
<li><strong><code>CPU</code>：</strong>代表利用<code>CPU</code>对界面<code>View</code>的<code>Measure</code>尺寸测量、<code>Layout</code>位置布局、<code>Draw</code>绘制并最终生成纹理的操作；</li>
<li><strong><code>GPU</code>：</strong>代表使用<code>OpenGl</code>库指令操作<code>GPU</code>硬件对<code>CPU</code>生成的纹理数据进行渲染和栅格化以及合成等操作；</li>
<li><strong><code>Display</code>：</strong>代表底层的显示屏幕；</li>
</ol>
<p>二、横轴表示时间，每个长方形表示<code>Buffer</code>的使用，长方形的宽度代表使用时长，<code>VSync</code>代表垂直同步信号。</p>
<p>我们以时间为顺序来看看这种设计存在的潜在缺陷：</p>
<ol>
<li><code>Display</code>上显示第<code>0</code>帧数据，此时<code>CPU</code>和<code>GPU</code>正在处理准备第<code>1</code>帧的画面，且在<code>Display</code>显示下一帧前完成；</li>
<li>因为<code>CPU</code>和<code>GPU</code>的处理及时，<code>Display</code>在第<code>0</code>帧显示完成后，也就是第<code>1</code>个<code>VSync</code>后，缓存进行交换，然后正常显示第<code>1</code>帧；</li>
<li>接着第<code>2</code>帧开始处理，但是<code>CPU</code>并没有立刻开始准备第<code>2</code>帧的数据，而是直到第<code>2</code>个<code>VSync</code>快来前才开始处理的；</li>
<li>第<code>2</code>个<code>VSync</code>来时，由于第<code>2</code>帧数据还没有准备就绪，缓存没有交换，屏幕显示的还是第<code>1</code>帧画面，即产生了丢帧卡顿问题；</li>
<li>当第<code>2</code>帧数据准备完成后，它并不能立马被显示，而是要等到下一个<code>VSync</code> 带来后，进行前后缓存交换才能显示到屏幕上。</li>
</ol>
<p>出现此掉帧卡顿问题的根本原因是：<strong>上层的<code>CPU</code>和<code>GPU</code>并不知道<code>Vsync</code>信号的到来，所以在底层屏幕的<code>Vsync</code>信号发出后并没有及时收到并开始下一帧画面的操作处理</strong>。根据前面的分析我们知道：双缓存的交换是在<code>Vsyn</code>信号到来时进行，交换后屏幕会读取<code>Front Buffer</code>内的新数据更新显示到屏幕上，而此时的<code>Back Buffer</code> 就可以供<code>GPU</code>准备下一帧数据了。如果 <code>Vsyn</code>到来时  <code>CPU/GPU</code>就开始操作的话，是有完整的<code>Vsync</code>周期时长来处理一帧数据，以避免卡顿的出现。那如何让 <code>CPU/GPU</code>的处理在 <code>Vsyn</code>信号到来时就开始进行呢？</p>
<p>为了优化系统显示性能，<code>Google</code>在<code>Android 4.1</code>系统中对<code>Android Display</code>系统进行了重构，引入了<code>Project Butter</code>（黄油计划），其中很重要的一点修改就是实现了：<strong>在系统收到<code>VSync</code>信号后，上层<code>CPU</code>和<code>GPU</code>马上开始进行下一帧画面数据的处理，完成后及时将数据写入到<code>Buffer</code>中，<code>Google</code>称之为<code>Drawing with Vsync</code>。</strong>如下图所示：</p>
<p><img src="/img/26874665-0311c942520a58cf.webp" srcset="/img/loading.gif" alt="Drawing with Vsync"></p>
<h3 id="3-3-Choreographer"><a href="#3-3-Choreographer" class="headerlink" title="3.3 Choreographer"></a>3.3 Choreographer</h3><p>上一节中讲到的，为了优化显示系统性能，<code>Google</code>在<code>Android 4.1</code>系统中对<code>Android Display</code>系统进行了重构，引入了<code>Project Butter</code>（黄油计划），其中很重要的一点修改就是实现了：<strong>在系统收到<code>VSync</code>信号后，上层<code>CPU</code>和<code>GPU</code>马上开始进行下一帧画面数据的处理，完成后及时将数据写入到<code>Buffer</code>中</strong>。为了实现这个效果，控制上层<code>CPU</code>和<code>GPU</code>在收到<code>Vsync</code>信号后马上开始一帧数据的处理，谷歌为此专门设计了一个名为<code>Choreographer</code>（中文翻译为“编舞者”）的类，来控制上层绘制的节奏。</p>
<p><code>Choreographer</code> 的引入，主要是为了配合系统<code>Vsync</code>垂直同步机制，给上层 App 的渲染提供一个稳定的 <code>Message</code> 处理的时机，也就是 <code>Vsync</code> 到来的时候 ，系统通过对 <code>Vsync</code> 信号周期的调整，来控制每一帧绘制操作的时机。<code>Choreographer</code><strong>扮演 Android 渲染链路中承上启下的角色：</strong></p>
<ol>
<li><strong>承上</strong>：负责接收和处理 <code>App</code> 的各种更新消息和回调，等到 <code>Vsync</code> 到来的时候统一处理。比如集中处理 <code>Input</code>(主要是 <code>Input</code> 事件的处理) 、<code>Animation</code>(动画相关)、<code>Traversal</code>(包括 <code>measure、layout、draw</code> 等操作) ，判断卡顿掉帧情况，记录 <code>CallBack</code> 耗时等；</li>
<li><strong>启下</strong>：负责请求和接收 <code>Vsync</code> 信号。接收 <code>Vsync</code> 信号到来的事件后回调(通过 <code>FrameDisplayEventReceiver</code>.<code>onVsync</code> )，并请求 <code>Vsync</code>(<code>FrameDisplayEventReceiver</code>.<code>scheduleVsync</code>) 。</li>
</ol>
<p><strong>一般应用<code>App</code>有界面<code>UI</code>的变化时，最终都会调用走到<code>ViewRootImpl#scheduleTraversals()</code>方法中</strong>，该方法中会往<code>Choreographer</code>中放入一个<code>CALLBACK_TRAVERSAL</code>类型的绘制任务，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>         ...<br>         <span class="hljs-comment">// 通过Choreographer往主线程消息队列添加CALLBACK_TRAVERSAL绘制类型的待执行消息，用于触发后续UI线程真正实现绘制动作</span><br>         mChoreographer.postCallback(<br>                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>         ...<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Choreographer</code>在收到的绘制任务后，其内部的工作流程如下图所示：</p>
<p><img src="/img/26874665-6f851c8e1d5bfcdf.webp" srcset="/img/loading.gif" alt="Choreographer工作原理"></p>
<p><strong>从以上流程图可以看出上层一般<code>App</code>应用<code>UI</code>中<code>View</code>的绘制流程（包含SurfaceView的游戏应用的绘制流程会有一些差异，篇幅有限此处不再展开分析）</strong>：</p>
<ol>
<li><code>View#invalidate</code>触发更新视图请求，此动作会调用<code>ViewRootImpl#scheduleTraversals</code>函数；</li>
<li><code>ViewRootImpl#scheduleTraversals</code>中会向<code>Choreographer</code>中<code>postCallback</code>放入一个<code>CALLBACK_TRAVERSAL</code>类型绘制待执行任务；</li>
<li><code>Choreographer</code>通过<code>DisplayEventReceiver</code>向系统<code>SurfaceFlinger</code>注册下一个<code>VSync</code>信号;</li>
<li>当底层产生下一个<code>VSync</code>消息时，将该信号发送给<code>DisplayEventReceiver</code>，最后传递给<code>Choreographer</code>；</li>
<li><code>Choreographer</code>收到<code>VSync</code>信号之后，向主线程<code>MessageQueue</code>发送了一个异步消息；</li>
<li>最后，异步消息的执行者是跑在主线程中的<code>ViewRootImpl#doTraversal</code>，也就是真正开始绘制一帧的操作（包含<code>measure、layout、draw</code>三个过程）；</li>
</ol>
<p>至此，底层的<code>VSync</code>控制上层绘制的逻辑就解释完了。</p>
<h2 id="4-UI-线程绘制流程"><a href="#4-UI-线程绘制流程" class="headerlink" title="4 UI 线程绘制流程"></a>4 UI 线程绘制流程</h2><p>在前几节中分析了应用<code>UI</code>线程的消息循环机制和<code>Android</code>屏幕刷新机制之后，我们接着<code>1</code>小节中关于<code>Input</code>触控事件的处理流程继续往下分析。在<code>1</code>小节的分析中我们了解到：用户手指在应用界面上下滑动时，应用的<code>UI</code>线程中会收到<code>system_server</code>系统进程发送来的一系列<code>Input</code>事件（包含一个<code>ACTION_DOWN</code>、多个<code>ACTION_MOVE</code>和一个<code>ACTION_UP</code>事件），应用界面布局中的相关<code>View</code>控件在收到多个<code>ACTION_MOVE</code>触控事件后，判断为用户手指的滑动行为后，一般会调用<code>View#invalidate</code>等接口触发<code>UI</code>线程的绘制上帧更新画面的操作。</p>
<p>在开始分析之前，我们先来看看<code>Android</code>系统的<code>GUI</code>显示系统在<code>APP</code>应用进程侧的核心架构，其整体架构如下图所示：</p>
<p><img src="/img/26874665-51a975ff2b3a2186.webp" srcset="/img/loading.gif" alt="GUI_APP"></p>
<ul>
<li><code>Window</code>是一个抽象类，<strong>通过控制<code>DecorView</code>提供了一些标准的UI方案，比如<code>背景、标题、虚拟按键等</code>，</strong>而<code>PhoneWindow</code>是<code>Window</code>的唯一实现类，在<code>Activity</code>创建后的attach流程中创建，应用启动显示的内容装载到其内部的<code>mDecor</code>（<code>DecorView</code>）；</li>
<li><code>DecorView</code>是整个界面布局View控件树的根节点，通过它可以遍历访问到整个<code>View</code>控件树上的任意节点；</li>
<li><code>WindowManager</code>是一个接口，继承自<code>ViewManager</code>接口，提供了<code>View</code>的基本操作方法；<code>WindowManagerImp</code>实现了<code>WindowManager</code>接口，内部通过<code>组合</code>方式持有<code>WindowManagerGlobal</code>，用来操作<code>View</code>；<code>WindowManagerGlobal</code><strong>是一个全局单例，内部通过<code>ViewRootImpl</code>将<code>View</code>添加至窗口中</strong>；</li>
<li><strong><code>ViewRootImpl</code>是所有<code>View</code>的<code>Parent</code>，用来总体管理<code>View</code>的绘制以及与系统<code>WMS</code>窗口管理服务的<code>IPC</code>交互从而实现窗口的开辟</strong>；<code>ViewRootImpl</code>是应用进程运转的发动机，可以看到<code>ViewRootImpl</code>内部包含<code>mView</code>（就是<code>DecorView</code>）、<code>mSurface</code>、<code>Choregrapher</code>：<code>mView</code>代表整个控件树，<code>mSurfacce</code>代表画布，应用的UI渲染会直接放到<code>mSurface</code>中，<code>Choregorapher</code>使得应用请求<code>vsync</code>信号，接收信号后开始绘制流程。</li>
</ul>
<p>我们从<code>ViewRootImpl</code>的<code>invalidate</code>流程继续往下分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;<br>    mDirty.set(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,mWidth,mHeight);<br>    <span class="hljs-keyword">if</span> (!mWillDrawSoon) &#123;<br>         <span class="hljs-comment">// 调用scheduleTraversals函数触发绘制操作</span><br>         scheduleTraversals();<br>     &#125;<br>&#125;<br><br><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>         ...<br>         <span class="hljs-comment">// 通过Choreographer往主线程消息队列添加CALLBACK_TRAVERSAL绘制类型的待执行消息，用于触发后续UI线程真正实现绘制动作</span><br>         mChoreographer.postCallback(<br>                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>         ...<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从以上分析可以看出，应用UI线程的绘制最终是通过往<code>Choreographer</code>中放入一个<code>CALLBACK_TRAVERSAL</code>类型的绘制任务而触发，下面的流程就和<code>3.3.3</code>小节中的分析的一致，<code>Choreographer</code>会先向系统申请<code>Vsync</code>信号，待<code>Vsync</code>信号到来后，向应用主线程<code>MessageQueue</code>发送一个异步消息，触发在主线程中执行<code>ViewRootImpl#doTraversal</code>绘制任务动作。我们接着看看<code>ViewRootImpl</code>的<code>doTraversal</code>函数执行绘制流程的简化代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>         mTraversalScheduled = <span class="hljs-keyword">false</span>;<br>         <span class="hljs-comment">// 调用removeSyncBarrier及时移除主线程MessageQueue中的Barrier同步栏删，以避免主线程发生“假死”</span><br>         mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br>         ...<br>         <span class="hljs-comment">// 执行具体的绘制任务</span><br>         performTraversals();<br>         ...<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>     ...<br>     <span class="hljs-comment">// 1.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的measure测量操作</span><br>     windowSizeMayChange |= measureHierarchy(...);<br>     ...<br>     <span class="hljs-keyword">if</span> (mFirst...) &#123;<br>    <span class="hljs-comment">// 2.第一次执行traversals绘制任务时，Binder调用访问系统窗口管理服务WMS的relayoutWindow接口，实现WMS计算应用窗口尺寸并向系统surfaceflinger正式申请Surface“画布”操作</span><br>         relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);<br>     &#125;<br>     ...<br>     <span class="hljs-comment">// 3.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的layout测量操作</span><br>     performLayout(lp, mWidth, mHeight);<br>     ...<br>     <span class="hljs-comment">// 4.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的draw测量操作</span><br>     performDraw();<br>     ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childWidthMeasureSpec, <span class="hljs-keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 原生标识View树的measure测量过程的trace tag</span><br>        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">&quot;measure&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从mView指向的View控件树的根节点DecorView出发，遍历访问整个View树，并完成整个布局View树的测量工作</span><br>            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDraw</span><span class="hljs-params">()</span> </span>&#123;<br>     ...<br>     <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);<br>     ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>        ...<br>        <span class="hljs-comment">// 如果开启并支持硬件绘制加速，则走硬件绘制的流程（从Android 4.+开始，默认情况下都是支持跟开启了硬件加速的）</span><br>        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则走drawSoftware软件绘制的流程</span><br>        <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                        scalingRequired, dirty, surfaceInsets)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码流程可以看出，<code>ViewRootImpl</code><strong>中负责的整个应用界面绘制的主要流程如下</strong>：</p>
<ol>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个<code>View</code>控件树，完成对整个<code>View</code><strong>控件树的<code>measure</code>测量操作</strong>，由于篇幅所限，本文就不展开分析这块的详细流程；</li>
<li>界面第一次执行绘制任务时，会通过<code>Binder</code> <code>IPC</code>访问系统窗口管理服务WMS的relayout接口，实现窗口尺寸的计算并向系统申请用于本地绘制渲染的<code>Surface</code>“画布”的操作（具体由<code>SurfaceFlinger</code>负责创建应用界面对应的<code>Layer</code>对象，并通过内存共享的方式通过<code>Binder</code>将地址引用透过WMS回传给应用进程这边）；</li>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个<code>View</code>控件树，完成对整个<code>View</code><strong>控件树的<code>layout</code>布局操作</strong>；</li>
<li>从界面View控件树的根节点<code>DecorView</code>出发，递归遍历整个<code>View</code>控件树，完成对整个<code>View</code><strong>控件树的<code>draw</code>绘制操作</strong>，如果开启并支持硬件绘制加速（从Android 4.X开始谷歌已经默认开启硬件加速），则走<code>GPU</code>硬件绘制的流程，否则走<code>CPU</code>软件绘制的流程；</li>
</ol>
<p>以上绘制过程从<code>systrace</code>上看如下图所示：</p>
<p><img src="/img/26874665-bc0bedd86a62d3a1.webp" srcset="/img/loading.gif" alt="UI traversal"></p>
<h2 id="5-RenderThread-线程渲染流程"><a href="#5-RenderThread-线程渲染流程" class="headerlink" title="5 RenderThread 线程渲染流程"></a>5 RenderThread 线程渲染流程</h2><p>截止到目前，在<code>ViewRootImpl</code>中完成了对界面的<code>measure</code>、<code>layout</code>和<code>draw</code>等绘制流程后，用户依然还是看不到屏幕上显示的应用界面内容，因为整个<code>Android</code>系统的显示流程除了前面讲到的UI线程的绘制外，界面还需要经过<code>RenderThread</code>线程的渲染处理，渲染完成后，还需要通过<code>Binder</code>调用“上帧”交给<code>surfaceflinger</code>进程中进行合成后送显才能最终显示到屏幕上。本小节中，我们将接上一节中<code>ViewRootImpl</code>中最后draw的流程继续往下分析开启硬件加速情况下，<code>RenderThread</code>渲染线程的工作流程。由于目前Android 4.X之后系统默认界面是开启硬件加速的，所以本文我们重点分析硬件加速条件下的界面渲染流程，我们先分析一下简化的代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/view/ViewRootImpl.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>        ...<br>        <span class="hljs-comment">// 硬件加速条件下的界面渲染流程</span><br>        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/core/java/android/view/ThreadedRenderer.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 1.从DecorView根节点出发，递归遍历View控件树，记录每个View节点的绘制操作命令，完成绘制操作命令树的构建</span><br>    updateRootDisplayList(view, callbacks);<br>    ...<br>    <span class="hljs-comment">// 2.JNI调用同步Java层构建的绘制命令树到Native层的RenderThread渲染线程，并唤醒渲染线程利用OpenGL执行渲染任务；</span><br>    <span class="hljs-keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<strong>硬件加速绘制主要包括两个阶段</strong>：</p>
<ol>
<li>从<code>DecorView</code>根节点出发，递归遍历<code>View</code>控件树，记录每个<code>View</code>节点的<code>drawOp</code>绘制操作命令，完成绘制操作命令树的构建；</li>
<li><code>JNI</code>调用同步<code>Java</code>层构建的绘制命令树到<code>Native</code>层的<code>RenderThread</code>渲染线程，并唤醒渲染线程利用<code>OpenGL</code>执行渲染任务；</li>
</ol>
<h3 id="5-1-构建绘制命令树"><a href="#5-1-构建绘制命令树" class="headerlink" title="5.1 构建绘制命令树"></a>5.1 构建绘制命令树</h3><p>我们先来看看第一阶段构建绘制命令树的代码简化流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/android/view/ThreadedRenderer.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateRootDisplayList</span><span class="hljs-params">(View view, DrawCallbacks callbacks)</span> </span>&#123;<br>        <span class="hljs-comment">// 原生标记构建View绘制操作命令树过程的systrace tag</span><br>        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">&quot;Record View#draw()&quot;</span>);<br>        <span class="hljs-comment">// 递归子View的updateDisplayListIfDirty实现构建DisplayListOp</span><br>        updateViewTreeDisplayList(view);<br>        ...<br>        <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;<br>            <span class="hljs-comment">// 获取根View的SkiaRecordingCanvas</span><br>            RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);<br>            <span class="hljs-keyword">try</span> &#123;<br>                ...<br>                <span class="hljs-comment">// 利用canvas缓存DisplayListOp绘制命令</span><br>                canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>                ...<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 将所有DisplayListOp绘制命令填充到RootRenderNode中</span><br>                mRootNode.endRecording();<br>            &#125;<br>        &#125;<br>        Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewTreeDisplayList</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 从DecorView根节点出发，开始递归调用每个View树节点的updateDisplayListIfDirty函数</span><br>        view.updateDisplayListIfDirty();<br>        ...<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/core/java/android/view/View.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;<br>     ...<br>     <span class="hljs-comment">// 1.利用`View`对象构造时创建的`RenderNode`获取一个`SkiaRecordingCanvas`“画布”；</span><br>     <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);<br>     <span class="hljs-keyword">try</span> &#123;<br>         ...<br>         <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>              <span class="hljs-comment">// 如果仅仅是ViewGroup，并且自身不用绘制，直接递归子View</span><br>              dispatchDraw(canvas);<br>              ...<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 2.利用SkiaRecordingCanvas，在每个子View控件的onDraw绘制函数中调用drawLine、drawRect等绘制操作时，创建对应的DisplayListOp绘制命令，并缓存记录到其内部的SkiaDisplayList持有的DisplayListData中；</span><br>              draw(canvas);<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// 3.将包含有`DisplayListOp`绘制命令缓存的`SkiaDisplayList`对象设置填充到`RenderNode`中；</span><br>         renderNode.endRecording();<br>         ...<br>     &#125;<br>     ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// draw the content(View自己实现的onDraw绘制，由应用开发者自己实现)</span><br>    onDraw(canvas);<br>    ...<br>    <span class="hljs-comment">// draw the children</span><br>    dispatchDraw(canvas);<br>    ...<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/graphics/java/android/graphics/RenderNode.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endRecording</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>        <span class="hljs-comment">// 从SkiaRecordingCanvas中获取SkiaDisplayList对象</span><br>        <span class="hljs-keyword">long</span> displayList = canvas.finishRecording();<br>        <span class="hljs-comment">// 将SkiaDisplayList对象填充到RenderNode中</span><br>        nSetDisplayList(mNativeRenderNode, displayList);<br>        canvas.recycle();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从以上代码可以看出，<strong>构建绘制命令树的过程是从<code>View</code>控件树的根节点<code>DecorView</code>触发，递归调用每个子<code>View</code>节点的<code>updateDisplayListIfDirty</code>函数，最终完成绘制树的创建，简述流程如下</strong>：</p>
<ol>
<li>利用<code>View</code>对象构造时创建的<code>RenderNode</code>获取一个<code>SkiaRecordingCanvas</code>“画布”；</li>
<li>利用<code>SkiaRecordingCanvas</code>，<strong>在每个子<code>View</code>控件的<code>onDraw</code>绘制函数中调用<code>drawLine</code>、<code>drawRect</code>等绘制操作时，创建对应的<code>DisplayListOp</code>绘制命令，并缓存记录到其内部的<code>SkiaDisplayList</code>持有的<code>DisplayListData</code>中</strong>；</li>
<li>将包含有<code>DisplayListOp</code>绘制命令缓存的<code>SkiaDisplayList</code>对象设置填充到<code>RenderNode</code>中；</li>
<li>最后将根<code>View</code>的缓存<code>DisplayListOp</code>设置到<code>RootRenderNode</code>中，完成构建。</li>
</ol>
<p>以上整个构建绘制命令树的过程可以用如下流程图表示：</p>
<p><img src="/img/26874665-20529fa058c44a07.webp" srcset="/img/loading.gif" alt="硬件加速绘制之绘制命令树构建"></p>
<p> 硬件加速下的整个界面的<code>View</code>树的结构如下图所示：</p>
<p><img src="/img/26874665-6f1b95b11f3fe294.webp" srcset="/img/loading.gif"></p>
<p> 最后从<code>Systrace</code>上看这个过程如下图所示：</p>
<p><img src="/img/26874665-b94a5aeb293a3dad.webp" srcset="/img/loading.gif" alt="构建View绘制命令树"></p>
<h3 id="5-2-执行渲染绘制任务"><a href="#5-2-执行渲染绘制任务" class="headerlink" title="5.2 执行渲染绘制任务"></a>5.2 执行渲染绘制任务</h3><p>经过上一小节中的分析，应用在<code>UI</code>线程中从根节点<code>DecorView</code>出发，递归遍历每个子<code>View</code>节点，搜集其<code>drawXXX</code>绘制动作并转换成<code>DisplayListOp</code>命令，将其记录到<code>DisplayListData</code>并填充到<code>RenderNode</code>中，最终完成整个<code>View</code>绘制命令树的构建。从此UI线程的绘制任务就完成了。下一步<code>UI</code>线程将唤醒<code>RenderThread</code>渲染线程，触发其利用<code>OpenGL</code>执行界面的渲染任务，本小节中我们将重点分析这个流程。我们还是先看看这块代码的简化流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/base/graphics/java/android/graphics/HardwareRenderer.java*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">syncAndDrawFrame</span><span class="hljs-params">(@NonNull FrameInfo frameInfo)</span> </span>&#123;<br>    <span class="hljs-comment">// JNI调用native层的相关函数</span><br>    <span class="hljs-keyword">return</span> nSyncAndDrawFrame(mNativeProxy, frameInfo.frameInfo, frameInfo.frameInfo.length);<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/libs/hwui/jni/android_graphics_HardwareRenderer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-function"><span class="hljs-params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;<br>    ...<br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    env-&gt;GetLongArrayRegion(frameInfo, <span class="hljs-number">0</span>, frameInfoSize, proxy-&gt;frameInfo());<br>    <span class="hljs-keyword">return</span> proxy-&gt;syncAndDrawFrame();<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/libs/hwui/renderthread/RenderProxy.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RenderProxy::syncAndDrawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 唤醒RenderThread渲染线程，执行DrawFrame绘制任务</span><br>    <span class="hljs-keyword">return</span> mDrawFrameTask.drawFrame();<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DrawFrameTask::drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    postAndWait();<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::postAndWait</span><span class="hljs-params">()</span> </span>&#123;<br>    AutoMutex _lock(mLock);<br>    <span class="hljs-comment">// 向RenderThread渲染线程的MessageQueue消息队列放入一个待执行任务，以将其唤醒执行run函数</span><br>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().post([<span class="hljs-keyword">this</span>]() &#123; run(); &#125;);<br>    <span class="hljs-comment">// UI线程暂时进入wait等待状态</span><br>    mSignal.wait(mLock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 原生标识一帧渲染绘制任务的systrace tag</span><br>    ATRACE_NAME(<span class="hljs-string">&quot;DrawFrame&quot;</span>);<br>    ...<br>    &#123;<br>        <span class="hljs-function">TreeInfo <span class="hljs-title">info</span><span class="hljs-params">(TreeInfo::MODE_FULL, *mContext)</span></span>;<br>        <span class="hljs-comment">//1.将UI线程构建的DisplayListOp绘制命令树同步到RenderThread渲染线程</span><br>        canUnblockUiThread = syncFrameState(info);<br>        ...<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 同步完成后则可以唤醒UI线程</span><br>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;<br>        unblockUiThread();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;<br>        <span class="hljs-comment">// 2.执行draw渲染绘制动作</span><br>        context-&gt;draw();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;<br>    ATRACE_CALL();<br>    ...<br>    <span class="hljs-comment">// 调用CanvasContext的prepareTree函数实现绘制命令树同步的流程</span><br>    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);<br>    ...<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/libs/hwui/renderthread/CanvasContext.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info, <span class="hljs-keyword">int64_t</span>* uiFrameInfo, <span class="hljs-keyword">int64_t</span> syncQueued,</span></span><br><span class="hljs-function"><span class="hljs-params">                                RenderNode* target)</span> </span>&#123;<br>     ...<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;<br>        ...<br>        <span class="hljs-comment">// 递归调用各个子View对应的RenderNode执行prepareTree动作</span><br>        node-&gt;prepareTree(info);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-comment">/*frameworks/base/libs/hwui/RenderNode.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ...<br>    prepareTreeImpl(observer, info, <span class="hljs-literal">false</span>);<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTreeImpl</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;<br>        <span class="hljs-comment">// 同步绘制命令树</span><br>        pushStagingDisplayListChanges(observer, info);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;<br>        <span class="hljs-comment">// 遍历调用各个子View对应的RenderNode的prepareTreeImpl</span><br>        <span class="hljs-keyword">bool</span> isDirty = mDisplayList-&gt;prepareListAndChildren(<br>                observer, info, childFunctorsNeedLayer,<br>                [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info,<br>                   <span class="hljs-keyword">bool</span> functorsNeedLayer) &#123;<br>                    child-&gt;prepareTreeImpl(observer, info, functorsNeedLayer);<br>                &#125;);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::pushStagingDisplayListChanges</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info)</span> </span>&#123;<br>    ...<br>    syncDisplayList(observer, &amp;info);<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::syncDisplayList</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo* info)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 完成赋值同步DisplayList对象</span><br>    mDisplayList = mStagingDisplayList;<br>    mStagingDisplayList = <span class="hljs-literal">nullptr</span>;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 1.调用OpenGL库使用GPU，按照构建好的绘制命令完成界面的渲染</span><br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,<br>                                      &amp;(profiler()));<br>    ...<br>    <span class="hljs-comment">// 2.将前面已经绘制渲染好的图形缓冲区Binder上帧给SurfaceFlinger合成和显示</span><br>    <span class="hljs-keyword">bool</span> didSwap =<br>            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从以上代码可以看出：<code>UI</code>线程利用<code>RenderProxy</code>向<code>RenderThread</code>线程发送一个<code>DrawFrameTask</code>任务请求，<code>RenderThread</code><strong>被唤醒，开始渲染，大致流程如下</strong>：</p>
<ol>
<li><code>syncFrameState</code>中遍历<code>View</code>树上每一个<code>RenderNode</code>，执行<code>prepareTreeImpl</code>函数，实现同步绘制命令树的操作；</li>
<li>调用<code>OpenGL</code>库<code>API</code>使用<code>GPU</code>硬件，按照构建好的绘制命令完成界面的渲染（具体过程，由于本文篇幅所限，暂不展开分析）；</li>
<li>将前面已经绘制渲染好的图形缓冲区<code>Binder</code>上帧给<code>SurfaceFlinger</code>合成和显示；</li>
</ol>
<p>整个过程可以用如下流程图表示：</p>
<p><img src="/img/26874665-a849cafb9e09dc39.webp" srcset="/img/loading.gif" alt="RenderThread线程渲染流程"></p>
<p> 从<code>Systrace</code>上这个过程如下图所示：</p>
<p><img src="/img/26874665-f4ce565d0be1d9da.webp" srcset="/img/loading.gif" alt="RenderThread渲染流程"></p>
<h2 id="6-SurfaceFlinger图形合成"><a href="#6-SurfaceFlinger图形合成" class="headerlink" title="6 SurfaceFlinger图形合成"></a>6 SurfaceFlinger图形合成</h2><p><code>SurfaceFlinger</code>合成显示部分属于<code>Android</code>系统<code>GUI</code>中图形显示的内容，简单的说<code>SurfaceFlinger</code>作为系统中独立运行的一个<code>Native</code>进程，<strong>借用<code>Android</code>官网的描述，其职责就是负责接受来自多个来源的数据缓冲区，对它们进行合成，然后发送到显示设备。</strong>如下图所示：</p>
<p><img src="/img/26874665-e7f57fd02b8effb1.webp" srcset="/img/loading.gif" alt="SurfaceFlinger工作原理"></p>
<p> 从上图可以看出，其实<code>SurfaceFlinger</code>在<code>Android</code>系统的整个图形显示系统中是起到一个<strong>承上启下的作用</strong>：</p>
<ul>
<li><strong>对上</strong>：通过<code>Surface</code>与不同的应用进程建立联系，接收它们写入<code>Surface</code>中的绘制缓冲数据，对它们进行统一合成。</li>
<li><strong>对下</strong>：通过屏幕的后缓存区与屏幕建立联系，发送合成好的数据到屏幕显示设备。</li>
</ul>
<p>图形的传递是通过<code>Buffer</code>作为载体，<code>Surface</code>是对<code>Buffer</code>的进一步封装，也就是说<code>Surface</code>内部具有多个<code>Buffer</code>供上层使用，如何管理这些<code>Buffer</code>呢？答案就是<code>BufferQueue</code> ，下面我们来看看<code>BufferQueue</code>的工作原理。</p>
<h3 id="6-1-BufferQueue机制"><a href="#6-1-BufferQueue机制" class="headerlink" title="6.1 BufferQueue机制"></a>6.1 BufferQueue机制</h3><p>借用一张经典的图来描述<code>BufferQueue</code>的工作原理：</p>
<p><img src="/img/26874665-23d55ad35fecf5dd.webp" srcset="/img/loading.gif" alt="BufferQueue状态转换图"></p>
<p><code>BufferQueue</code>是一个<strong>典型的生产者-消费者模型中的数据结构</strong>。在<code>Android</code>应用的渲染流程中，应用扮演的就是“生产者”的角色，而<code>SurfaceFlinger</code>扮演的则是“消费者”的角色，<strong>其配合工作的流程如下</strong>：</p>
<ol>
<li>应用进程中在开始界面的绘制渲染之前，需要通过<code>Binder</code>调用<code>dequeueBuffer</code>接口从<code>SurfaceFlinger</code>进程中管理的<code>BufferQueue</code> 中申请一张处于<code>free</code>状态的可用<code>Buffer</code>，如果此时没有可用<code>Buffer</code>则阻塞等待；</li>
<li>应用进程中拿到这张可用的<code>Buffer</code>之后，选择使用<code>CPU</code>软件绘制渲染或<code>GPU</code>硬件加速绘制渲染，渲染完成后再通过<code>Binder</code>调用<code>queueBuffer</code>接口将缓存数据返回给应用进程对应的<code>BufferQueue</code>（如果是 <code>GPU</code> 渲染的话，这里还有个 <code>GPU</code>处理的过程，所以这个 <code>Buffer</code> 不会马上可用，需要等 <code>GPU</code> 渲染完成的<code>Fence</code>信号），并申请<code>sf</code>类型的<code>Vsync</code>以便唤醒“消费者”<code>SurfaceFlinger</code>进行消费；</li>
<li><code>SurfaceFlinger</code> 在收到 <code>Vsync</code> 信号之后，开始准备合成，使用 <code>acquireBuffer</code>获取应用对应的 <code>BufferQueue</code> 中的 <code>Buffer</code> 并进行合成操作；</li>
<li>合成结束后，<code>SurfaceFlinger</code> 将通过调用 <code>releaseBuffer</code>将 <code>Buffer</code> 置为可用的<code>free</code>状态，返回到应用对应的 <code>BufferQueue</code>中。</li>
</ol>
<h3 id="6-2-Vsync同步机制"><a href="#6-2-Vsync同步机制" class="headerlink" title="6.2 Vsync同步机制"></a>6.2 Vsync同步机制</h3><p>在之前<code>3.3</code>小节关于<code>Android</code>系统屏幕刷新机制中我们分析了<code>Vsync</code>机制的来龙去脉。其实<code>Android</code>系统中的<code>Vsync</code>信号的产生与管理都是由<code>SurfaceFlinger</code>模块统一负责的，<code>Vysnc</code>信号一般分为两种类型：</p>
<ol>
<li><code>app</code>类型的<code>Vsync</code>：<code>app</code><strong>类型的<code>Vysnc</code>信号由上层应用中的<code>Choreographer</code>根据绘制需求进行注册和接收，用于控制应用UI绘制上帧的生产节奏</strong>。根据<code>3.4</code>小结中的分析：应用在UI线程中调用<code>invalidate</code>刷新界面绘制时，需要先透过<code>Choreographer</code>向系统申请注册<code>app</code>类型的<code>Vsync</code>信号，待<code>Vsync</code>信号到来后，才能往主线程的消息队列放入待绘制任务进行真正<code>UI</code>的绘制动作；</li>
<li><code>sf</code>类型的<code>Vsync</code>:<strong><code>sf</code>类型的<code>Vsync</code>是用于控制<code>SurfaceFlinger</code>的合成消费节奏</strong>。应用完成界面的绘制渲染后，通过<code>Binder</code>调用<code>queueBuffer</code>接口将缓存数据返还给应用对应的<code>BufferQueue</code>时，会申请<code>sf</code>类型的<code>Vsync</code>，待<code>SurfaceFlinger</code> 在其UI线程中收到 <code>Vsync</code> 信号之后，便开始进行界面的合成操作。</li>
</ol>
<p><strong><code>Vsync</code>信号的生成是参考屏幕硬件的刷新周期的</strong>，其架构如下图所示：</p>
<p><img src="/img/26874665-04b831a664ca42a5.webp" srcset="/img/loading.gif" alt="vsync"></p>
<h3 id="6-3-帧数据的提交消费过程"><a href="#6-3-帧数据的提交消费过程" class="headerlink" title="6.3 帧数据的提交消费过程"></a>6.3 帧数据的提交消费过程</h3><p>我们接着<code>3.5.2</code>小节中的分析，应用进程的<code>RenderThread</code>渲染线程在执行完一帧画面的渲染操作的最后，会通过<code>Binder</code>调用<code>queueBuffer</code>接口将一帧数据提交给<code>SurfaceFlinger</code>进程进行消费合成显示。我们结合相关简化的源码流程（这里基于<code>Android 11</code>源代码分析）来看看<code>SurfaceFlinger</code>中是如何处理应用的请求的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/libs/gui/BufferQueueProducer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>     <span class="hljs-keyword">if</span> (frameAvailableListener != <span class="hljs-literal">nullptr</span>) &#123;<br>        frameAvailableListener-&gt;onFrameAvailable(item);<br>     &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的<code>frameAvailableListener</code>是<code>BufferQueueLayer</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferQueueLayer::onFrameAvailable</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BufferItem&amp; item)</span> </span>&#123;<br>    ......<br>     mFlinger-&gt;signalLayerUpdate();<span class="hljs-comment">//这里触发申请一下个Vsync-sf信号</span><br>    ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    ......<br>    mEventQueue-&gt;invalidate();<br>    ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::invalidate</span><span class="hljs-params">()</span> </span>&#123;<br>    ......<br>    mEvents-&gt;requestNextVsync();<span class="hljs-comment">// 申请一下个Vsync-sf信号</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上过程从<code>Systrace</code>上看如下图所示：</p>
<p><img src="/img/26874665-f6784d876edd3964-6410947.webp" srcset="/img/loading.gif" alt="sf_Vsync1"></p>
<p><img src="/img/26874665-db743387780c416e.webp" srcset="/img/loading.gif" alt="sf_Vsync2"></p>
<p> 由上面分析可知，只要有<code>layer</code>上帧，那么就会申请下一次的<code>Vsync-sf</code>信号， 当<code>Vsync-sf</code>信号来时会调用<code>onMessageReceived</code>函数来处理帧数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageInvalidate</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> expectedVSyncTime)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    refreshNeeded |= handleMessageInvalidate();<br>    ......<br>    signalRefresh();<span class="hljs-comment">//再次向消息队列发送一个消息，消息到达时会调用onMessageRefresh</span><br>    ......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SurfaceFlinger::handleMessageInvalidate</span><span class="hljs-params">()</span> </span>&#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">bool</span> refreshNeeded = handlePageFlip();<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>handleMessageInvalidate</code>里一个比较重要的函数是<code>handlePageFlip</code>():</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span><br><span class="hljs-built_in">bool</span> SurfaceFlinger::handlePageFlip()<br>&#123;<br>    ATRACE_CALL();<br>    ......<br>    mDrawingState.traverse([&amp;](Layer* layer) &#123;<br>        <span class="hljs-keyword">if</span> (layer-&gt;hasReadyFrame()) &#123;<br>            frameQueued = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (layer-&gt;shouldPresentNow(expectedPresentTime)) &#123;<br>                mLayersWithQueuedFrames.push_back(layer);<br>            &#125; <br>            .......<br>        &#125; <br>        ......<br>    &#125;);<br>    ......<br>    <span class="hljs-keyword">for</span> (auto&amp; layer : mLayersWithQueuedFrames) &#123;<br>            <span class="hljs-keyword">if</span> (layer-&gt;latchBuffer(visibleRegions, latchTime, expectedPresentTime)) &#123;<br>                mLayersPendingRefresh.push_back(layer);<br>            &#125;<br>            .......<br>     &#125;<br>     ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里可以看出来，<code>handlePageFlip</code>里一个重要的工作是检查所有的<code>Layer</code>是否有新<code>Buffer</code>提交，如果有则调用其<code>latchBuffer</code>来处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/BufferLayer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BufferLayer::latchBuffer</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>&amp; recomputeVisibleRegions, <span class="hljs-keyword">nsecs_t</span> latchTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">nsecs_t</span> expectedPresentTime)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    <span class="hljs-keyword">status_t</span> err = updateTexImage(recomputeVisibleRegions, latchTime, expectedPresentTime);<br>    ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/BufferQueuedLayer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueLayer::updateTexImage</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>&amp; recomputeVisibleRegions, <span class="hljs-keyword">nsecs_t</span> latchTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                                          <span class="hljs-keyword">nsecs_t</span> expectedPresentTime)</span> </span>&#123;<br>     ......<br>     <span class="hljs-keyword">status_t</span> updateResult = mConsumer-&gt;updateTexImage(&amp;r, expectedPresentTime, &amp;mAutoRefresh,<br>                                                      &amp;queuedBuffer, maxFrameNumberToAcquire);<br>     ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferLayerConsumer::updateTexImage</span><span class="hljs-params">(BufferRejecter* rejecter, <span class="hljs-keyword">nsecs_t</span> expectedPresentTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                                             <span class="hljs-keyword">bool</span>* autoRefresh, <span class="hljs-keyword">bool</span>* queuedBuffer,</span></span><br><span class="hljs-function"><span class="hljs-params">                                             <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    <span class="hljs-keyword">status_t</span> err = acquireBufferLocked(&amp;item, expectedPresentTime, maxFrameNumber);<br>    ......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">ConsumerBase::acquireBufferLocked</span><span class="hljs-params">(BufferItem *item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">nsecs_t</span> presentWhen, <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>    ......<br>    <span class="hljs-keyword">status_t</span> err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里调用到了<code>BufferLayerConsumer</code>的基类<code>ConsumerBase</code>里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/libs/gui/ConsumerBase.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">ConsumerBase::acquireBufferLocked</span><span class="hljs-params">(BufferItem *item,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">nsecs_t</span> presentWhen, <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>    ......<br>    <span class="hljs-keyword">status_t</span> err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里<code>onMessageInvalidate</code>中的主要工作结束，在这个函数的处理中：<code>SurfaceFlinger</code><strong>主要是检查每个<code>Layer</code>是否有新提交的<code>Buffer</code>， 如果有则调用<code>latchBuffer</code>将每个<code>BufferQueue</code>中的<code>Slot</code> 通过<code>acquireBuffer</code>拿走。</strong>此过程从<code>Systrace</code>上看如下图有所示：</p>
<p><img src="/img/26874665-5ae751371232e148.webp" srcset="/img/loading.gif" alt="sf_Vsync3"><br> 之后<code>acquireBuffer</code>拿走的<code>Buffer</code>(<code>Slot</code>对应的状态是<code>ACQUIRED</code>状态)会被交由<code>HWC``Service</code>处理，这部分是在<code>onMessageRefresh</code>中处理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    mCompositionEngine-&gt;present(refreshArgs);<br>    ......<br>｝<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/CompositionEngine/src/CompositionEngine.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CompositionEngine::present</span><span class="hljs-params">(CompositionRefreshArgs&amp; args)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; output : args.outputs) &#123;<br>        output-&gt;present(args);<br>    &#125;<br>    ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Output::present</span><span class="hljs-params">(<span class="hljs-keyword">const</span> compositionengine::CompositionRefreshArgs&amp; refreshArgs)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    updateAndWriteCompositionState(refreshArgs);<span class="hljs-comment">//告知HWC service有哪些layer要参与合成</span><br>    ......<br>    beginFrame();<br>    prepareFrame();<br>    ......<br>    finishFrame(refreshArgs);<br>    postFramebuffer();<span class="hljs-comment">//这里会调用到HWC service的接口去present display合成画面</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Output::postFramebuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    ......<br>    <span class="hljs-keyword">auto</span> frame = presentAndGetFrameFences();<br>    ......<br>&#125;<br><br><span class="hljs-comment">/*frameworks/native/services/surfaceflinger/displayhardware/HWComposer.cpp*/</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">HWComposer::presentAndGetReleaseFences</span><span class="hljs-params">(DisplayId displayId)</span> </span>&#123;<br>    ATRACE_CALL();<br>    ......<br>    <span class="hljs-keyword">auto</span> error = hwcDisplay-&gt;present(&amp;displayData.lastPresentFence);<span class="hljs-comment">//送去HWC service合成</span><br>    ......<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;<br>    error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);<br>    RETURN_IF_HWC_ERROR_FOR(<span class="hljs-string">&quot;getReleaseFences&quot;</span>, error, displayId, UNKNOWN_ERROR);<br><br>    displayData.releaseFences = <span class="hljs-built_in">std</span>::move(releaseFences);<span class="hljs-comment">//获取releaseFence, 以便通知到各个Slot, buffer被release后会通过dequeueBuffer给到应用，应用在绘图前会等待releaseFence</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上过程从<code>systrace</code>上看如下图所示：</p>
<p><img src="/img/26874665-2644e13bdbda7cb0.webp" srcset="/img/loading.gif" alt="sf_Vsync4"></p>
<p> 最后总结一下应用调用<code>queueBuffer</code>将一帧<code>Buffer</code>数据提到<code>SurfaceFlinger</code>后<code>SurfaceFlinger</code>的主要处理流程，：</p>
<ol>
<li>首先<code>Binder</code>线程会通过<code>BufferQueue</code>机制把应用上帧的<code>Slot</code>状态改为<code>QUEUED</code>, 然后把这个<code>Slot</code>放入<code>mQueue</code>队列， 然后通过<code>onFrameAvailable</code>回调通知到<code>BufferQueueLayer</code>, 在处理函数里会请求下一次的<code>Vsync-sf</code>信号；</li>
<li>在<code>Vsync-sf</code>信号到来后，<code>SurfaceFlinger</code>主线程要执行两次<code>onMessageReceived</code>, 第一次要检查所有的<code>Layer</code>看是否有上帧， 如果有<code>Layer</code>上帧就调用它的<code>latchBuffer</code>把它的<code>Buffer</code>  <code>acquireBuffer</code>取走；并发送一个消息到主消息队列，让主线程再次走进<code>onMessageReceived</code>,；</li>
<li>第二次走进来时，主要执行<code>present</code>方法，在这些方法里会和<code>HWC service</code>沟通，调用它的跨进程接口通知它去做图层的合成后送显示器显示。</li>
</ol>
<p>后续<code>HWC service</code>的合成以及屏幕的详细显示原理由于篇幅有限就不展开说明，感兴趣的读者可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df46e4b39428">系列文章</a>。</p>
<h2 id="7-流程总结与卡顿定义"><a href="#7-流程总结与卡顿定义" class="headerlink" title="7 流程总结与卡顿定义"></a>7 流程总结与卡顿定义</h2><h3 id="7-1-应用绘制上帧流程总结"><a href="#7-1-应用绘制上帧流程总结" class="headerlink" title="7.1 应用绘制上帧流程总结"></a>7.1 应用绘制上帧流程总结</h3><p>在本节中我们以用户手指上下滑动应用界面的操作场景为例，结合系统源码和<code>Systrace</code>工具，按照执行顺序分析了<code>Android</code>应用绘制上帧显示的系统运行机制与总体流程，我们以一张图描述如下：</p>
<p><img src="/img/26874665-7d1cb09267361b98.webp" srcset="/img/loading.gif" alt="Android应用滑动上帧显示流程"></p>
<p><strong>最后总结整个流程大致如下</strong>：</p>
<ol>
<li>用户手指触摸屏幕后，屏幕驱动产生<code>Input</code>触控事件；框架<code>system_server</code>进程中的<code>EventHub</code>通过<code>epoll</code>机制监听到驱动产生的<code>Input</code>触控事件上报，由<code>InputReader</code>读取到<code>Input</code>事件后，唤醒<code>InputDispatcher</code>找到当前触控焦点应用窗口，并通过事先建立的<code>socket</code>通道发送<code>Input</code>事件到对应的应用进程；</li>
<li>应用进程收到<code>Input</code>触控事件后<code>UI</code>线程被唤醒进行事件的分发，相关<code>View</code>控件中根据多个<code>ACTION_MOVE</code>类型的<code>Input</code>事件判断为用户手指滑动行为后，通过<code>Choreographer</code>向系统注册申请<code>app</code>类型的<code>Vsync</code>信号，并等待<code>Vsync</code>信号到来后触发绘制操作；</li>
<li><code>app</code>类型的<code>Vsync</code>信号到来后，唤醒应用<code>UI</code>线程并向其消息队列中放入一个待执行的绘制任务，在<code>UI</code>线程中先后遍历执行<code>View</code>控件树的测量、布局和绘制（硬件加速默认开启的状态下会遍历并记录每个<code>View</code>的<code>draw</code>操作生成对应的绘制命令树）操作；</li>
<li><code>View</code>控件树的绘制任务执行完成后会唤醒应用的<code>RenderThread</code>渲染线程执行界面渲染任务；整个渲染任务中会先同步<code>UI</code>线程中构建好的绘制命令树，然后通过<code>dequeueBuffer</code>申请一张处于<code>free</code>状态的可用<code>Buffer</code>，然后调用<code>SkiaOpenGLPipeline</code>渲染管道中使用<code>GPU</code>进行渲染操作，渲染完成后<code>swapBuffer</code>触发<code>queueBuffer</code>动作进行上帧；</li>
<li>应用渲染线程最后的<code>queueBuffer</code>上帧动作，会唤醒对端<code>SurfaceFlinger</code>进程中的<code>Binder</code>处理线程，其中将对应用<code>BufferQuque</code>中的<code>Buffer</code>标记为<code>Queued</code>状态，然后注册申请<code>sf</code>类型的<code>Vsync</code>信号；</li>
<li>待<code>sf</code>类型的<code>Vsync</code>信号到来后会唤醒<code>SurfaceFlinger</code>的主线程执行一帧的合成任务，其中会先通过<code>handlePageFlip</code>操作遍历所有的应用<code>Layer</code>找到有上帧操作的处于<code>Queued</code>状态的<code>Buffer</code>进行<code>AcquireBuffer</code>获取标记锁定，然后执行<code>persent</code>动作调用唤醒<code>HWC service</code>进程的工作线程执行具体的图层的合成送显操作；</li>
<li><code>HWC service</code>中最终会收到<code>SurfaceFlinger</code>的请求后，进行图层合成操作，最终通过调用<code>libDrm</code>库相关接口<code>Commit</code>提交<code>Buffer</code>数据到Kernel内核中的屏幕驱动，并最终送到屏幕硬件上显示。</li>
</ol>
<h3 id="7-2-卡顿的定义"><a href="#7-2-卡顿的定义" class="headerlink" title="7.2 卡顿的定义"></a>7.2 卡顿的定义</h3><p>根据本节中我们对<code>Android</code>应用上帧显示的原理分析，我们初步可以判断：如果在一个<code>Vsync</code>周期内（<code>60HZ</code>的屏幕上就是<code>16.6ms</code>），按照整个上帧显示的执行的顺序来看，应用<code>UI</code>线程的绘制、<code>RenderThread</code>线程的渲染、<code>SurfaceFlinger/HWC</code>的图层合成以及最终屏幕上的显示这些动作没有全部都执行完成的话，屏幕上就会显示上一帧画面的内容，也就是掉帧，而人的肉眼就可能会感觉到画面卡顿（由于 <code>Triple Buffer</code> 的存在，这里也有可能不掉帧）。</p>
<p>这里借用高爷的一段经典描述从三个方面定义卡顿：</p>
<ol>
<li>从现象上来说，在 <code>App</code> 连续的动画播放或者手指滑动列表时（关键是连续），如果连续 <code>2</code> 帧或者 <code>2</code> 帧以上，应用的画面都没有变化，那么我们认为这里发生了卡顿；</li>
<li>从 <code>SurfaceFlinger</code> 的角度来说，在 <code>App</code> 连续的动画播放或者手指滑动列表时（关键是连续），如果有一个 <code>Vsync</code> 到来的时候 ，<code>App</code> 没有可以用来合成的 <code>Buffer</code>，那么这个 <code>Vsync</code> 周期 <code>SurfaceFlinger</code> 就不会走合成的逻辑（或者是去合成其他的 <code>Layer</code>），那么这一帧就会显示 <code>App</code> 的上一帧的画面，我们认为这里发生了卡顿；</li>
<li>从 <code>App</code> 的角度来看，如果渲染线程在一个 <code>Vsync</code> 周期内没有 <code>queueBuffer</code> 到 <code>SurfaceFlinger</code> 中 <code>App</code> 对应的 <code>BufferQueue</code> 中，那么我们认为这里发生了卡顿。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android-Performance-Optimization/">Android Performance Optimization</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Carried-Over/">Carried Over</a>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                      <a class="hover-with-bg" href="/tags/Performance-Optimization/">Performance Optimization</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/12/d2738127/">
                        <span class="hidden-mobile">Java并发编程——从ReentrantLock来看AQS的应用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'sukaidev/sukaidev.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Powered by  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> , Theme  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>





  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
